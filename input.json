{"language":"Solidity","sources":{"src/input/compact/InputSettlerCompactLIFI.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\nimport { EfficiencyLib } from \"the-compact/src/lib/EfficiencyLib.sol\";\nimport { IdLib } from \"the-compact/src/lib/IdLib.sol\";\nimport { BatchClaim } from \"the-compact/src/types/BatchClaims.sol\";\nimport { BatchClaimComponent, Component } from \"the-compact/src/types/Components.sol\";\n\nimport { InputSettlerCompact } from \"OIF/src/input/compact/InputSettlerCompact.sol\";\nimport { StandardOrder, StandardOrderType } from \"OIF/src/input/types/StandardOrderType.sol\";\nimport { IOIFCallback } from \"OIF/src/interfaces/IOIFCallback.sol\";\n\nimport { GovernanceFee } from \"../../libs/GovernanceFee.sol\";\nimport { RegisterIntentLib } from \"../../libs/RegisterIntentLib.sol\";\n\n/**\n * @title Catalyst Settler supporting The Compact\n * @notice This Catalyst Settler implementation uses The Compact as the deposit scheme.\n * It is a delivery first, inputs second scheme that allows users with a deposit inside The Compact.\n *\n * Users are expected to have an existing deposit inside the Compact or purposefully deposit for the intent.\n * They then need to either register or sign a supported claim with the intent outputs as the witness.\n * Without the deposit extension, this contract does not have a way to emit on-chain orders.\n *\n * The ownable component of the smart contract is only used for fees.\n */\ncontract InputSettlerCompactLIFI is InputSettlerCompact, GovernanceFee {\n    error NotRegistered();\n\n    event IntentRegistered(bytes32 indexed orderId, StandardOrder order);\n\n    constructor(address compact, address initialOwner) InputSettlerCompact(compact) {\n        _initializeOwner(initialOwner);\n    }\n\n    /// @notice EIP712\n    function _domainNameAndVersion()\n        internal\n        pure\n        virtual\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"InputSettlerCompact\";\n        version = \"LIFI_1\";\n    }\n\n    /**\n     * @notice Valdiates that an intent has been registered against TheCompact and broadcasts and event for\n     * permissionless consumption.\n     * @param order Order to be broadcasts for consumption by off-chain solvers.\n     */\n    function broadcast(\n        StandardOrder calldata order\n    ) external {\n        RegisterIntentLib._validateChain(order.originChainId);\n        RegisterIntentLib._validateExpiry(order.fillDeadline, order.expires);\n\n        bool registered = COMPACT.isRegistered(\n            order.user,\n            RegisterIntentLib.compactClaimHash(address(this), order),\n            RegisterIntentLib.STANDARD_ORDER_BATCH_COMPACT_TYPE_HASH\n        );\n        if (!registered) revert NotRegistered();\n\n        bytes32 orderId = _orderIdentifier(order);\n        emit IntentRegistered(orderId, order);\n    }\n\n    /**\n     * @notice Finalises an order when called directly by the solver\n     * @dev The caller must be the address corresponding to the first solver in the solvers array.\n     * If destination is bytes32(0), the order owner will be used as the destination.\n     * @param order StandardOrder signed in conjunction with a Compact to form an order\n     * @param signatures A signature for the sponsor and the allocator. abi.encode(bytes(sponsorSignature),\n     * bytes(allocatorData))\n     * @param timestamps Array of timestamps when each output was filled\n     * @param solvers Array of solvers who filled each output (in order). For single solver, pass an array with only one\n     * element\n     * @param destination Where to send the inputs. If the solver wants to send the inputs to themselves, they should\n     * pass their address to this parameter.\n     * @param call Optional callback data. If non-empty, will call orderFinalised on the destination\n     */\n    function finalise(\n        StandardOrder calldata order,\n        bytes calldata signatures,\n        uint32[] calldata timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes calldata call\n    ) external override {\n        if (destination == bytes32(0)) revert NoDestination();\n\n        bytes32 orderId = _orderIdentifier(order);\n        bytes32 orderOwner = _purchaseGetOrderOwner(orderId, solvers[0], timestamps);\n        _orderOwnerIsCaller(orderOwner);\n\n        _finalise(order, signatures, orderId, solvers[0], destination);\n        if (call.length > 0) {\n            IOIFCallback(EfficiencyLib.asSanitizedAddress(uint256(destination))).orderFinalised(order.inputs, call);\n        }\n\n        _validateFills(order, orderId, solvers, timestamps);\n    }\n\n    /**\n     * @notice Finalises a cross-chain order on behalf of someone else using their signature\n     * @dev This function serves to finalise intents on the origin chain with proper authorization from the order owner.\n     * @param order StandardOrder signed in conjunction with a Compact to form an order\n     * @param signatures A signature for the sponsor and the allocator. abi.encode(bytes(sponsorSignature),\n     * bytes(allocatorData))\n     * @param timestamps Array of timestamps when each output was filled\n     * @param solvers Array of solvers who filled each output (in order). For single solver, pass an array with only\n     * element\n     * @param destination Where to send the inputs\n     * @param call Optional callback data. If non-empty, will call orderFinalised on the destination\n     * @param orderOwnerSignature Signature from the order owner authorizing this external call\n     */\n    function finaliseWithSignature(\n        StandardOrder calldata order,\n        bytes calldata signatures,\n        uint32[] calldata timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes calldata call,\n        bytes calldata orderOwnerSignature\n    ) external override {\n        if (destination == bytes32(0)) revert NoDestination();\n\n        bytes32 orderId = _orderIdentifier(order);\n        bytes32 orderOwner = _purchaseGetOrderOwner(orderId, solvers[0], timestamps);\n        // Validate the external claimant with signature\n        _allowExternalClaimant(\n            orderId, EfficiencyLib.asSanitizedAddress(uint256(orderOwner)), destination, call, orderOwnerSignature\n        );\n\n        _finalise(order, signatures, orderId, solvers[0], destination);\n        if (call.length > 0) {\n            IOIFCallback(EfficiencyLib.asSanitizedAddress(uint256(destination))).orderFinalised(order.inputs, call);\n        }\n\n        _validateFills(order, orderId, solvers, timestamps);\n    }\n\n    //--- The Compact & Resource Locks ---//\n\n    function _resolveLock(\n        StandardOrder calldata order,\n        bytes calldata sponsorSignature,\n        bytes calldata allocatorData,\n        bytes32 claimant\n    ) internal override {\n        BatchClaimComponent[] memory batchClaimComponents;\n        {\n            uint256 numInputs = order.inputs.length;\n            batchClaimComponents = new BatchClaimComponent[](numInputs);\n            uint256[2][] calldata maxInputs = order.inputs;\n            uint64 fee = governanceFee;\n            for (uint256 i; i < numInputs; ++i) {\n                uint256[2] calldata input = maxInputs[i];\n                uint256 tokenId = input[0];\n                uint256 allocatedAmount = input[1];\n\n                Component[] memory components;\n\n                // If the governance fee is set, we need to add a governance fee split.\n                uint256 governanceShare = _calcFee(allocatedAmount, fee);\n                if (governanceShare != 0) {\n                    unchecked {\n                        // To reduce the cost associated with the governance fee,\n                        // we want to do a 6909 transfer instead of burn and mint.\n                        // Note: While this function is called with replaced token, it\n                        // replaces the rightmost 20 bytes. So it takes the locktag from TokenId\n                        // and places it infront of the current vault owner.\n                        uint256 ownerId = IdLib.withReplacedToken(tokenId, owner());\n                        components = new Component[](2);\n                        // For the user\n                        components[0] =\n                            Component({ claimant: uint256(claimant), amount: allocatedAmount - governanceShare });\n                        // For governance\n                        components[1] = Component({ claimant: uint256(ownerId), amount: governanceShare });\n                        batchClaimComponents[i] = BatchClaimComponent({\n                            id: tokenId, // The token ID of the ERC6909 token to allocate.\n                            allocatedAmount: allocatedAmount, // The original allocated amount of ERC6909 tokens.\n                            portions: components\n                        });\n                        continue;\n                    }\n                }\n\n                components = new Component[](1);\n                components[0] = Component({ claimant: uint256(claimant), amount: allocatedAmount });\n                batchClaimComponents[i] = BatchClaimComponent({\n                    id: tokenId, // The token ID of the ERC6909 token to allocate.\n                    allocatedAmount: allocatedAmount, // The original allocated amount of ERC6909 tokens.\n                    portions: components\n                });\n            }\n        }\n\n        require(\n            COMPACT.batchClaim(\n                BatchClaim({\n                    allocatorData: allocatorData,\n                    sponsorSignature: sponsorSignature,\n                    sponsor: order.user,\n                    nonce: order.nonce,\n                    expires: order.expires,\n                    witness: StandardOrderType.witnessHash(order),\n                    witnessTypestring: string(StandardOrderType.BATCH_COMPACT_SUB_TYPES),\n                    claims: batchClaimComponents\n                })\n            ) != bytes32(0)\n        );\n    }\n}\n"},"lib/the-compact/src/lib/EfficiencyLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Scope } from \"../types/Scope.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\n/**\n * @title EfficiencyLib\n * @notice Library contract implementing logic for efficient value comparisons,\n * conversions, typecasting, and sanitization. Also provides functions to prevent\n * the function specializer from being triggered when using static arguments.\n */\nlibrary EfficiencyLib {\n    /**\n     * @notice Internal view function to convert the provided account address to the caller if that\n     *         address is the null address (0x0).\n     * @dev    Uses bitwise operations to avoid branching, making this function more gas efficient\n     *         than using a traditional if-else statement. The implementation follows the pattern\n     *         `result = xor(a, mul(xor(a, b), condition))` which resolves to either a or b based\n     *         on the condition; as the condition in this case is contingent on the first argument\n     *         having a value of zero, the nested xor can safely be omitted.\n     * @param  account               The address to check and potentially replace.\n     * @return accountOrCallerIfNull The original address if non-zero, otherwise msg.sender.\n     */\n    function usingCallerIfNull(address account) internal view returns (address accountOrCallerIfNull) {\n        assembly (\"memory-safe\") {\n            accountOrCallerIfNull := xor(account, mul(caller(), iszero(account)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that performs a bitwise AND on two booleans.\n     * Avoids Solidity's conditional evaluation of logical AND. Only safe when\n     * inputs are known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The first boolean value.\n     * @param b  The second boolean value.\n     * @return c The result of the bitwise AND.\n     */\n    function and(bool a, bool b) internal pure returns (bool c) {\n        assembly (\"memory-safe\") {\n            c := and(a, b)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that performs a bitwise OR on two booleans.\n     * Avoids Solidity's conditional evaluation of logical OR. Only safe when\n     * inputs are known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The first boolean value.\n     * @param b  The second boolean value.\n     * @return c The result of the bitwise OR.\n     */\n    function or(bool a, bool b) internal pure returns (bool c) {\n        assembly (\"memory-safe\") {\n            c := or(a, b)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint256 to a boolean. Only\n     * safe when the input is known to be exactly 0 or 1 with no dirty bits.\n     * @param a  The uint256 to convert.\n     * @return b The resulting boolean.\n     */\n    function asBool(uint256 a) internal pure returns (bool b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint256 to a bytes12. Only\n     * safe when the input is known to have no dirty lower bits.\n     * @param a  The uint256 to convert.\n     * @return b The resulting bytes12 value.\n     */\n    function asBytes12(uint256 a) internal pure returns (bytes12 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that sanitizes an address by clearing the\n     * upper 96 bits. Used for ensuring consistent address handling.\n     * @param accountValue The value to sanitize.\n     * @return account     The sanitized address.\n     */\n    function asSanitizedAddress(uint256 accountValue) internal pure returns (address account) {\n        assembly (\"memory-safe\") {\n            account := shr(96, shl(96, accountValue))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that checks if an address has its lower 160\n     * bits set to zero.\n     * @param account The address to check.\n     * @return isNull Whether the address is null.\n     */\n    function isNullAddress(address account) internal pure returns (bool isNull) {\n        assembly (\"memory-safe\") {\n            isNull := iszero(shl(96, account))\n        }\n    }\n\n    /**\n     * @notice Internal pure function that checks if a bytes12 value is zero. Only\n     * safe to use if the value is known to not have any dirty lower bits set.\n     * @param value The value to check.\n     * @return isNull Whether the value is zero.\n     */\n    function isZero(bytes12 value) internal pure returns (bool isNull) {\n        assembly (\"memory-safe\") {\n            isNull := iszero(value)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a boolean to a uint256.\n     * @param a  The boolean to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(bool a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint96 to a uint256.\n     * @param a  The uint96 to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(uint96 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a bytes12 to a uint256.\n     * @param a  The bytes12 to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(bytes12 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a Scope enum to a uint256.\n     * @param a  The Scope enum to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(Scope a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts an address to a uint256.\n     * @param a  The address to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(address a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a ResetPeriod enum to a uint256.\n     * @param a  The ResetPeriod enum to convert.\n     * @return b The resulting uint256.\n     */\n    function asUint256(ResetPeriod a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that converts a uint256 to a ResetPeriod enum without\n     * performing any bounds checks. Do not use in cases where the reset period may be\n     * outside the acceptable bounds.\n     * @param a  The uint256 to convert.\n     * @return b The resulting ResetPeriod enum.\n     */\n    function asResetPeriod(uint256 a) internal pure returns (ResetPeriod b) {\n        assembly (\"memory-safe\") {\n            b := a\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * optimizing uint256 arguments. XORs the value with calldatasize(), which\n     * will always be non-zero in a real call.\n     * @param a  The uint256 value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(uint256 a) internal pure returns (uint256 b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * inlining functions that take fixed bytes32 arguments. Since calldatasize()\n     * will always be non-zero when making a standard function call, an OR\n     * against iszero(calldatasize()) will always result in the original value.\n     * @param a  The bytes32 value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(bytes32 a) internal pure returns (bytes32 b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that prevents the function specializer from\n     * inlining functions that take fixed boolean arguments. Since calldatasize()\n     * will always be non-zero when making a standard function call, an OR\n     * against iszero(calldatasize()) will always result in the original value.\n     * @param a  The boolean value to make stubborn.\n     * @return b The original value, preventing specialization.\n     */\n    function asStubborn(bool a) internal pure returns (bool b) {\n        assembly (\"memory-safe\") {\n            b := or(iszero(calldatasize()), a)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/IdLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\n\n/**\n * @title IdLib\n * @notice Library contract implementing logic for deriving IDs for allocators and\n * for resource locks, converting between various IDs, and for extracting details\n * related to those IDs. This includes logic for registering allocators and for\n * assigning them an allocator ID.\n */\nlibrary IdLib {\n    using IdLib for bytes12;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using IdLib for ResetPeriod;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint8;\n    using EfficiencyLib for uint96;\n    using EfficiencyLib for bytes12;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for address;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for Scope;\n    using EfficientHashLib for bytes;\n\n    error NoAllocatorRegistered(uint96 allocatorId);\n    error AllocatorAlreadyRegistered(uint96 allocatorId, address allocator);\n\n    // Storage slot seed for mapping allocator IDs to allocator addresses.\n    uint256 private constant _ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED = 0x000044036fc77deaed2300000000000000000000000;\n\n    // keccak256(bytes(\"AllocatorRegistered(uint96,address)\")).\n    uint256 private constant _ALLOCATOR_REGISTERED_EVENT_SIGNATURE =\n        0xc54dcaa67a8fd7b4a9aa6fd57351934c792613d5ec1acbd65274270e6de8f7e4;\n\n    // Error selectors for NoAllocatorRegistered and AllocatorAlreadyRegistered.\n    uint256 private constant _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE = 0xcf90c3a8;\n    uint256 private constant _ALLOCATOR_ALREADY_REGISTERED_ERROR_SIGNATURE = 0xc18b0e97;\n\n    /**\n     * @notice Internal function for registering an allocator. Derives an ID for the\n     * allocator and stores the allocator's address for that ID, reverting if an\n     * allocator has already been registered for the ID in question.\n     * @param allocator The address to register as an allocator.\n     * @return allocatorId The derived ID for the registered allocator.\n     */\n    function register(address allocator) internal returns (uint96 allocatorId) {\n        // Derive the allocator ID for the provided allocator address.\n        allocatorId = allocator.toAllocatorId();\n\n        assembly (\"memory-safe\") {\n            // Derive storage slot for allocator registration by ID.\n            let allocatorSlot := or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId)\n\n            // Retrieve the allocator value at the derived storage slot.\n            let registeredAllocator := sload(allocatorSlot)\n\n            // Revert if an allocator has already been registered for the ID.\n            if registeredAllocator {\n                mstore(0, _ALLOCATOR_ALREADY_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                mstore(0x40, registeredAllocator)\n                revert(0x1c, 0x44)\n            }\n\n            // Store allocator address (sanitize first as an added precaution).\n            allocator := shr(0x60, shl(0x60, allocator))\n            sstore(allocatorSlot, allocator)\n\n            // Emit AllocatorRegistered(allocatorId, allocator) event.\n            mstore(0x00, allocatorId)\n            mstore(0x20, allocator)\n            log1(0x00, 0x40, _ALLOCATOR_REGISTERED_EVENT_SIGNATURE)\n        }\n    }\n\n    /**\n     * @notice Internal view function for constructing a resource lock ID assuming that the\n     * provided allocator has been registered. Derives the allocator ID from the registered\n     * allocator, and combines it with the provided scope, reset period, and token address\n     * to form a single ID value. Reverts if the allocator is not registered.\n     * @param token   The address of the underlying token.\n     * @param lockTag The lock tag containing allocator ID, reset period, and scope.\n     * @return id     The derived resource lock ID.\n     */\n    function toIdIfRegistered(address token, bytes12 lockTag) internal view returns (uint256 id) {\n        // Derive the allocator ID for the provided allocator address.\n        lockTag.toAllocatorId().mustHaveARegisteredAllocator();\n\n        // Derive resource lock ID (pack scope, reset period, allocator ID, & token).\n        id = lockTag.asUint256() | token.asUint256();\n    }\n\n    /**\n     * @notice Internal view function for extracting and validating an allocator ID from\n     * a resource lock ID. Reverts if the allocator is not registered.\n     * @param id           The resource lock ID to extract from.\n     * @return allocatorId The validated allocator ID.\n     */\n    function toAllocatorIdIfRegistered(uint256 id) internal view returns (uint96 allocatorId) {\n        allocatorId = id.toAllocatorId();\n        allocatorId.mustHaveARegisteredAllocator();\n    }\n\n    /**\n     * @notice Internal view function for retrieving an allocator's address from their ID.\n     * Reverts if no allocator is registered with the provided ID.\n     * @param allocatorId The ID to look up.\n     * @return allocator  The registered allocator's address.\n     */\n    function toRegisteredAllocator(uint96 allocatorId) internal view returns (address allocator) {\n        assembly (\"memory-safe\") {\n            // Retrieve allocator from storage based on allocator ID.\n            allocator := sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))\n\n            // Revert if no registered allocator is located.\n            if iszero(allocator) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that checks if an allocator ID has a registered\n     * allocator. Reverts if no allocator is registered.\n     * @param allocatorId The allocator ID to check.\n     */\n    function mustHaveARegisteredAllocator(uint96 allocatorId) internal view {\n        assembly (\"memory-safe\") {\n            // Derive storage slot using scope + allocatorId & ensure allocator is set.\n            if iszero(sload(or(_ALLOCATOR_BY_ALLOCATOR_ID_SLOT_SEED, allocatorId))) {\n                mstore(0, _NO_ALLOCATOR_REGISTERED_ERROR_SIGNATURE)\n                mstore(0x20, allocatorId)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that checks if an allocator can be registered.\n     * Returns true if any of the following are true:\n     *  - The caller is the allocator\n     *  - The allocator address contains code\n     *  - The proof is a valid create2 deployment that derives the allocator address\n     *    (e.g. proof must take the form of 0xff ++ factory ++ salt ++ initcode hash)\n     * @param allocator The address to check.\n     * @param proof     An 85-byte value containing create2 address derivation parameters.\n     * @return          Whether the allocator can be registered.\n     */\n    function canBeRegistered(address allocator, bytes calldata proof) internal view returns (bool) {\n        return (msg.sender == allocator).or(allocator.code.length > 0).or(\n            proof.length == 85 && (proof[0] == 0xff).and(allocator == address(uint160(uint256(proof.hashCalldata()))))\n        );\n    }\n\n    /**\n     * @notice Internal pure function for building the \"lock tag\" from an\n     * allocatorId, scope, and reset period.\n     * @param allocatorId The allocator ID.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param resetPeriod The duration after which the resource lock can be reset.\n     * @return            The lock tag.\n     */\n    function toLockTag(uint96 allocatorId, Scope scope, ResetPeriod resetPeriod) internal pure returns (bytes12) {\n        // Derive lock tag (pack scope, reset period, & allocator ID).\n        return ((scope.asUint256() << 255) | (resetPeriod.asUint256() << 252) | (allocatorId.asUint256() << 160))\n            .asBytes12();\n    }\n\n    /**\n     * @notice Internal pure function for extracting the \"lock tag\" from an ID.\n     * @param id The resource lock ID.\n     * @return lockTag The lock tag.\n     */\n    function toLockTag(uint256 id) internal pure returns (bytes12 lockTag) {\n        // Extract the lock tag.\n        assembly (\"memory-safe\") {\n            lockTag := shl(160, shr(160, id))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the last 20 bytes of an\n     * underlying uint256 as an address. This represents either the token\n     * address (for a resource lock ID) or the claimant address (for a claimant\n     * value).\n     * @param id The uint256 to extract from.\n     * @return   The address.\n     */\n    function toAddress(uint256 id) internal pure returns (address) {\n        return id.asSanitizedAddress();\n    }\n\n    /**\n     * @notice Internal pure function for creating a new resource lock ID with a\n     * different token address.\n     * @param id         The resource lock ID to modify.\n     * @param token      The new token address.\n     * @return updatedId The modified resource lock ID.\n     */\n    function withReplacedToken(uint256 id, address token) internal pure returns (uint256 updatedId) {\n        assembly (\"memory-safe\") {\n            updatedId := or(shl(160, shr(160, id)), shr(96, shl(96, token)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for creating a new resource lock ID from an\n     * existing id and a lock tag.\n     * @param id         The resource lock ID to modify.\n     * @param lockTag    The new lock tag.\n     * @return updatedId The modified resource lock ID.\n     */\n    function withReplacedLockTag(uint256 id, bytes12 lockTag) internal pure returns (uint256 updatedId) {\n        assembly (\"memory-safe\") {\n            updatedId := or(shl(160, shr(160, lockTag)), shr(96, shl(96, id)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the scope from a resource lock ID.\n     * @param id     The resource lock ID to extract from.\n     * @return scope The scope (uppermost bit).\n     */\n    function toScope(uint256 id) internal pure returns (Scope scope) {\n        assembly (\"memory-safe\") {\n            // extract uppermost bit\n            scope := shr(255, id)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the reset period from a resource\n     * lock ID.\n     * @param id           The resource lock ID to extract from.\n     * @return resetPeriod The reset period (bits 252-254).\n     */\n    function toResetPeriod(uint256 id) internal pure returns (ResetPeriod resetPeriod) {\n        assembly (\"memory-safe\") {\n            // extract 2nd, 3rd & 4th uppermost bits\n            resetPeriod := and(shr(252, id), 7)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the reset period from a resource\n     * lock tag.\n     * @param lockTag      The resource lock tag to extract from.\n     * @return resetPeriod The reset period (bits 252-254).\n     */\n    function toResetPeriod(bytes12 lockTag) internal pure returns (ResetPeriod resetPeriod) {\n        assembly (\"memory-safe\") {\n            // extract 2nd, 3rd & 4th uppermost bits\n            resetPeriod := and(shr(252, lockTag), 7)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the allocator ID from a resource\n     * lock ID. The allocator ID is a 92-bit value, with the first 4 bits representing\n     * the compact flag and the last 88 bits matching the last 88 bits of the underlying\n     * allocator, but is represented by a uint96 as solidity only supports uint values\n     * for multiples of 8 bits.\n     * @param id           The resource lock ID to extract from.\n     * @return allocatorId The allocator ID (bits 160-251).\n     */\n    function toAllocatorId(uint256 id) internal pure returns (uint96 allocatorId) {\n        assembly (\"memory-safe\") {\n            // Extract bits 5-96.\n            allocatorId := shr(164, shl(4, id))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for converting a reset period to its duration in\n     * seconds. There are eight distinct reset periods ranging from one second to\n     * thirty days. Specific periods include some additional padding:\n     *  - One hour is padded by five minutes\n     *  - Seven days is padded by one hour\n     * @dev No bounds check performed; ensure that the enum value is in range.\n     * @param resetPeriod The reset period to convert.\n     * @return duration   The duration in seconds.\n     */\n    function toSeconds(ResetPeriod resetPeriod) internal pure returns (uint256 duration) {\n        assembly (\"memory-safe\") {\n            // Bitpacked durations in 24-bit segments:\n            // 278d00  094890  015180  000f3c  000258  00003c  00000f  000001\n            // 30 days 7 days  1 day   1 hour  10 min  1 min   15 sec  1 sec\n            let bitpacked := 0x278d00094890015180000f3c00025800003c00000f000001\n\n            // Shift right by period * 24 bits & mask the least significant 24 bits.\n            duration := and(shr(mul(resetPeriod, 24), bitpacked), 0xffffff)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for computing an address's compact flag. The flag\n     * is a 4-bit value that represents how \"compact\" the address of an allocator is. A\n     * fully \"compact\" allocator address will have nine leading zero bytes, or eighteen\n     * leading zero nibbles. To be considered even partially compact, the account must\n     * have at least two leading zero bytes, or four leading zero nibbles. The full\n     * scoring formula is therefore:\n     *  - 0-3 leading zero nibbles: 0\n     *  - 4-17 leading zero nibbles: number of leading zeros minus 3\n     *  - 18+ leading zero nibbles: 15\n     * @param allocator    The address to compute the flag for.\n     * @return compactFlag The computed compact flag.\n     */\n    function toCompactFlag(address allocator) internal pure returns (uint8 compactFlag) {\n        assembly (\"memory-safe\") {\n            // Extract the uppermost 72 bits of the address.\n            let x := shr(184, shl(96, allocator))\n\n            // Propagate the highest set bit.\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n            x := or(x, shr(32, x))\n            x := or(x, shr(64, x))\n\n            // Count set bits to derive most significant bit in the last byte.\n            let y := sub(x, and(shr(1, x), 0x5555555555555555))\n            y := add(and(y, 0x3333333333333333), and(shr(2, y), 0x3333333333333333))\n            y := and(add(y, shr(4, y)), 0x0f0f0f0f0f0f0f0f)\n            y := add(y, shr(8, y))\n            y := add(y, shr(16, y))\n            y := add(y, shr(32, y))\n\n            // Look up final value in the sequence.\n            compactFlag := and(shr(and(sub(72, and(y, 127)), not(3)), 0xfedcba9876543210000), 15)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for computing an allocator's ID from their address.\n     * Combines the compact flag (4 bits) with the last 88 bits of the address.\n     * @param allocator    The address to compute the ID for.\n     * @return allocatorId The computed allocator ID.\n     */\n    function toAllocatorId(address allocator) internal pure returns (uint96 allocatorId) {\n        uint8 compactFlag = allocator.toCompactFlag();\n\n        assembly (\"memory-safe\") {\n            allocatorId := or(shl(88, compactFlag), shr(168, shl(168, allocator)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for extracting the allocator ID from a resource\n     * lock tag. The allocator ID is a 92-bit value, with the first 4 bits representing\n     * the compact flag and the last 88 bits matching the last 88 bits of the underlying\n     * allocator, but is represented by a uint96 as solidity only supports uint values\n     * for multiples of 8 bits.\n     * @param lockTag      The resource lock tag to extract from.\n     * @return allocatorId The allocator ID (bits 160-251).\n     */\n    function toAllocatorId(bytes12 lockTag) internal pure returns (uint96 allocatorId) {\n        assembly (\"memory-safe\") {\n            // Extract bits 5-96.\n            allocatorId := shr(164, shl(4, lockTag))\n        }\n    }\n\n    /**\n     * @notice Internal view function for ensuring that the allocator ID from a resource\n     * lock tag is registered to an allocator.\n     * @param lockTag The resource lock tag to check allocator registration for.\n     */\n    function hasRegisteredAllocatorId(bytes12 lockTag) internal view {\n        lockTag.toAllocatorId().mustHaveARegisteredAllocator();\n    }\n\n    /**\n     * @notice Internal pure function for deriving a resource lock ID from a Lock struct.\n     * The ID consists of:\n     *  - Bit 255: scope\n     *  - Bits 252-254: reset period\n     *  - Bits 160-251: allocator ID (first 4 bits are compact flag, next 88 from allocator address)\n     *  - Bits 0-159: token address\n     * @dev Note that this will return an ID even if the allocator is unregistered.\n     * @param token        The address of the underlying token (or address(0) for native tokens).\n     * @param allocator    The address of the allocator mediating the resource lock.\n     * @param resetPeriod  The duration after which the underlying tokens can be withdrawn once a forced withdrawal is initiated.\n     * @param scope        The scope of the resource lock (multichain or single chain).\n     * @return id          The derived resource lock ID.\n     */\n    function toId(address token, address allocator, ResetPeriod resetPeriod, Scope scope)\n        internal\n        pure\n        returns (uint256 id)\n    {\n        id = (\n            (scope.asUint256() << 255) | (resetPeriod.asUint256() << 252)\n                | (allocator.toAllocatorId().asUint256() << 160) | token.asUint256()\n        );\n    }\n}\n"},"lib/the-compact/src/types/BatchClaims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ComponentsById, BatchClaimComponent } from \"./Components.sol\";\n\nstruct AllocatedBatchTransfer {\n    bytes allocatorData; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    ComponentsById[] transfers; // The recipients and amounts of each transfer for each ID.\n}\n\nstruct BatchClaim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    BatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n}\n"},"lib/the-compact/src/types/Components.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nstruct Component {\n    uint256 claimant; // The lockTag + recipient of the transfer or withdrawal.\n    uint256 amount; // The amount of tokens to transfer or withdraw.\n}\n\nstruct ComponentsById {\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    Component[] portions; // claimants and amounts.\n}\n\nstruct TransferComponent {\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    uint256 amount; // The token amount to transfer or withdraw.\n}\n\nstruct BatchClaimComponent {\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    Component[] portions; // claimants and amounts.\n}\n"},"lib/OIF/src/input/compact/InputSettlerCompact.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { TheCompact } from \"the-compact/src/TheCompact.sol\";\nimport { EfficiencyLib } from \"the-compact/src/lib/EfficiencyLib.sol\";\nimport { IdLib } from \"the-compact/src/lib/IdLib.sol\";\nimport { BatchClaim } from \"the-compact/src/types/BatchClaims.sol\";\nimport { BatchClaimComponent, Component } from \"the-compact/src/types/Components.sol\";\n\nimport { IOIFCallback } from \"../../interfaces/IOIFCallback.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\n\nimport { IInputSettlerCompact } from \"../../interfaces/IInputSettlerCompact.sol\";\nimport { BytesLib } from \"../../libs/BytesLib.sol\";\nimport { MandateOutputEncodingLib } from \"../../libs/MandateOutputEncodingLib.sol\";\n\nimport { BaseInputSettler } from \"../BaseInputSettler.sol\";\nimport { MandateOutput } from \"../types/MandateOutputType.sol\";\nimport { OrderPurchase } from \"../types/OrderPurchaseType.sol\";\nimport { StandardOrder, StandardOrderType } from \"../types/StandardOrderType.sol\";\n\n/**\n * @title Input Settler supporting `The Compact` and `StandardOrder` orders. For `ERC-7683` orders refer to\n * `InputSettler7683`\n * @notice This Input Settler implementation uses The Compact as the deposit scheme. It is a Output first scheme that\n * allows users with a deposit inside The Compact to execute transactions that will be paid **after** the outputs have\n * been proven. This has the advantage that failed orders can be quickly retried. These orders are also entirely gasless\n * since neither valid nor failed transactions does not require any transactions to redeem.\n *\n * Users are expected to have an existing deposit inside the Compact or purposefully deposit for the intent. Then either\n * register or sign a supported claim with the intent outputs as the witness.\n *\n * The contract is intended to be entirely ownerless, permissionlessly deployable, and unstoppable.\n */\ncontract InputSettlerCompact is BaseInputSettler, IInputSettlerCompact {\n    error UserCannotBeSettler();\n    error NotOrderOwner();\n    error NoDestination();\n    error InvalidTimestampLength();\n    error OrderIdMismatch(bytes32 provided, bytes32 computed);\n    error FilledTooLate(uint32 expected, uint32 actual);\n\n    TheCompact public immutable COMPACT;\n\n    constructor(\n        address compact\n    ) {\n        COMPACT = TheCompact(compact);\n    }\n\n    /// @notice EIP712\n    function _domainNameAndVersion()\n        internal\n        pure\n        virtual\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"CatalystSettler\";\n        version = \"Compact1\";\n    }\n\n    // --- Generic order identifier --- //\n\n    function _orderIdentifier(\n        StandardOrder calldata order\n    ) internal view returns (bytes32) {\n        return StandardOrderType.orderIdentifier(order);\n    }\n\n    function orderIdentifier(\n        StandardOrder calldata order\n    ) external view returns (bytes32) {\n        return _orderIdentifier(order);\n    }\n\n    // --- Output Proofs --- //\n\n    function _proofPayloadHash(\n        bytes32 orderId,\n        bytes32 solver,\n        uint32 timestamp,\n        MandateOutput calldata output\n    ) internal pure returns (bytes32 outputHash) {\n        return keccak256(MandateOutputEncodingLib.encodeFillDescription(solver, orderId, timestamp, output));\n    }\n\n    /**\n     * @notice Check if a series of outputs have been proven.\n     * @dev This function returns true if the order contains no outputs.\n     * That means any order that has no outputs specified can be claimed.\n     */\n    function _validateFills(\n        StandardOrder calldata order,\n        bytes32 orderId,\n        bytes32[] memory solvers,\n        uint32[] calldata timestamps\n    ) internal view {\n        MandateOutput[] calldata MandateOutputs = order.outputs;\n\n        uint256 numOutputs = MandateOutputs.length;\n        uint256 numTimestamps = timestamps.length;\n        if (numTimestamps != numOutputs) revert InvalidTimestampLength();\n\n        uint32 fillDeadline = order.fillDeadline;\n        bytes memory proofSeries = new bytes(32 * 4 * numOutputs);\n        for (uint256 i; i < numOutputs; ++i) {\n            uint32 outputFilledAt = timestamps[i];\n            if (fillDeadline < outputFilledAt) revert FilledTooLate(fillDeadline, outputFilledAt);\n\n            MandateOutput calldata output = MandateOutputs[i];\n            bytes32 payloadHash = _proofPayloadHash(orderId, solvers[i], outputFilledAt, output);\n\n            uint256 chainId = output.chainId;\n            bytes32 outputOracle = output.oracle;\n            bytes32 outputSettler = output.settler;\n            assembly (\"memory-safe\") {\n                let offset := add(add(proofSeries, 0x20), mul(i, 0x80))\n                mstore(offset, chainId)\n                mstore(add(offset, 0x20), outputOracle)\n                mstore(add(offset, 0x40), outputSettler)\n                mstore(add(offset, 0x60), payloadHash)\n            }\n        }\n        IOracle(order.localOracle).efficientRequireProven(proofSeries);\n    }\n\n    // --- Finalise Orders --- //\n\n    /**\n     * @notice Enforces that the caller is the order owner.\n     * @dev Only reads the rightmost 20 bytes to allow solvers to opt-in to Compact transfers instead of withdrawals.\n     * @param orderOwner The order owner. The leftmost 12 bytes are not read.\n     */\n    function _orderOwnerIsCaller(\n        bytes32 orderOwner\n    ) internal view {\n        if (EfficiencyLib.asSanitizedAddress(uint256(orderOwner)) != msg.sender) revert NotOrderOwner();\n    }\n\n    /**\n     * @notice Finalise an order, paying the inputs to the solver.\n     * @param order that has been filled.\n     * @param signatures For the signed intent. Is packed: abi.encode(sponsorSignature, allocatorData).\n     * @param orderId A unique identifier for the order.\n     * @param solver Solver of the outputs.\n     * @param destination Destination of the inputs funds signed for by the user.\n     */\n    function _finalise(\n        StandardOrder calldata order,\n        bytes calldata signatures,\n        bytes32 orderId,\n        bytes32 solver,\n        bytes32 destination\n    ) internal virtual {\n        bytes calldata sponsorSignature = BytesLib.toBytes(signatures, 0x00);\n        bytes calldata allocatorData = BytesLib.toBytes(signatures, 0x20);\n        _resolveLock(order, sponsorSignature, allocatorData, destination);\n        emit Finalised(orderId, solver, destination);\n    }\n\n    /**\n     * @notice Finalises an order when called directly by the solver\n     * @dev The caller must be the address corresponding to the first solver in the solvers array.\n     * If destination is bytes32(0), the order owner will be used as the destination.\n     * @param order StandardOrder signed in conjunction with a Compact to form an order\n     * @param signatures A signature for the sponsor and the allocator. abi.encode(bytes(sponsorSignature),\n     * bytes(allocatorData))\n     * @param timestamps Array of timestamps when each output was filled\n     * @param solvers Array of solvers who filled each output (in order). For single solver, pass an array with only one\n     * element\n     * @param destination Where to send the inputs. If the solver wants to send the inputs to themselves, they should\n     * pass their address to this parameter.\n     * @param call Optional callback data. If non-empty, will call orderFinalised on the destination\n     */\n    function finalise(\n        StandardOrder calldata order,\n        bytes calldata signatures,\n        uint32[] calldata timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes calldata call\n    ) external virtual {\n        if (destination == bytes32(0)) revert NoDestination();\n\n        bytes32 orderId = _orderIdentifier(order);\n        bytes32 orderOwner = _purchaseGetOrderOwner(orderId, solvers[0], timestamps);\n        _orderOwnerIsCaller(orderOwner);\n\n        _validateFills(order, orderId, solvers, timestamps);\n\n        _finalise(order, signatures, orderId, solvers[0], destination);\n\n        if (call.length > 0) {\n            IOIFCallback(EfficiencyLib.asSanitizedAddress(uint256(destination))).orderFinalised(order.inputs, call);\n        }\n    }\n\n    /**\n     * @notice Finalises a cross-chain order on behalf of someone else using their signature\n     * @dev This function serves to finalise intents on the origin chain with proper authorization from the order owner.\n     * @param order StandardOrder signed in conjunction with a Compact to form an order\n     * @param signatures A signature for the sponsor and the allocator. abi.encode(bytes(sponsorSignature),\n     * bytes(allocatorData))\n     * @param timestamps Array of timestamps when each output was filled\n     * @param solvers Array of solvers who filled each output (in order). For single solver, pass an array with only\n     * element\n     * @param destination Where to send the inputs\n     * @param call Optional callback data. If non-empty, will call orderFinalised on the destination\n     * @param orderOwnerSignature Signature from the order owner authorizing this external call\n     */\n    function finaliseWithSignature(\n        StandardOrder calldata order,\n        bytes calldata signatures,\n        uint32[] calldata timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes calldata call,\n        bytes calldata orderOwnerSignature\n    ) external virtual {\n        if (destination == bytes32(0)) revert NoDestination();\n\n        bytes32 orderId = _orderIdentifier(order);\n        bytes32 orderOwner = _purchaseGetOrderOwner(orderId, solvers[0], timestamps);\n\n        // Validate the external claimant with signature\n        _allowExternalClaimant(\n            orderId, EfficiencyLib.asSanitizedAddress(uint256(orderOwner)), destination, call, orderOwnerSignature\n        );\n\n        _validateFills(order, orderId, solvers, timestamps);\n\n        _finalise(order, signatures, orderId, solvers[0], destination);\n\n        if (call.length > 0) {\n            IOIFCallback(EfficiencyLib.asSanitizedAddress(uint256(destination))).orderFinalised(order.inputs, call);\n        }\n    }\n\n    //--- The Compact & Resource Locks ---//\n\n    /**\n     * @notice Resolves a Compact Claim for a Standard Order.\n     * @param order that should be converted into a Compact Claim.\n     * @param sponsorSignature The user's signature for the Compact Claim.\n     * @param allocatorData The allocator's signature for the Compact Claim.\n     * @param claimant Destination of the inputs funds signed for by the user.\n     */\n    function _resolveLock(\n        StandardOrder calldata order,\n        bytes calldata sponsorSignature,\n        bytes calldata allocatorData,\n        bytes32 claimant\n    ) internal virtual {\n        BatchClaimComponent[] memory batchClaimComponents;\n        {\n            uint256 numInputs = order.inputs.length;\n            batchClaimComponents = new BatchClaimComponent[](numInputs);\n            uint256[2][] calldata maxInputs = order.inputs;\n            for (uint256 i; i < numInputs; ++i) {\n                uint256[2] calldata input = maxInputs[i];\n                uint256 tokenId = input[0];\n                uint256 allocatedAmount = input[1];\n\n                Component[] memory components = new Component[](1);\n                components[0] = Component({ claimant: uint256(claimant), amount: allocatedAmount });\n                batchClaimComponents[i] = BatchClaimComponent({\n                    id: tokenId, // The token ID of the ERC6909 token to allocate.\n                    allocatedAmount: allocatedAmount, // The original allocated amount of ERC6909 tokens.\n                    portions: components\n                });\n            }\n        }\n\n        address user = order.user;\n        // The Compact skips signature checks for msg.sender. Ensure no accidental intents are issued.\n        if (user == address(this)) revert UserCannotBeSettler();\n        require(\n            COMPACT.batchClaim(\n                BatchClaim({\n                    allocatorData: allocatorData,\n                    sponsorSignature: sponsorSignature,\n                    sponsor: user,\n                    nonce: order.nonce,\n                    expires: order.expires,\n                    witness: StandardOrderType.witnessHash(order),\n                    witnessTypestring: string(StandardOrderType.BATCH_COMPACT_SUB_TYPES),\n                    claims: batchClaimComponents\n                })\n            ) != bytes32(0)\n        );\n    }\n\n    // --- Purchase Order --- //\n\n    /**\n     * @notice This function is called to buy an order from a solver.\n     * If the order was purchased in time, then when the order is settled, the inputs will go to the purchaser instead\n     * of the original solver.\n     * @param orderPurchase Order purchase description signed by solver.\n     * @param order Order to purchase.\n     * @param orderSolvedByIdentifier Solver of the order. Is not validated, if wrong the purchase will be skipped.\n     * @param purchaser The new order owner.\n     * @param expiryTimestamp Set to ensure if your transaction does not mine quickly, you don't end up purchasing an\n     * order that you can not prove OR is outside the timeToBuy window.\n     * @param solverSignature EIP712 Signature of OrderPurchase by orderOwner.\n     */\n    function purchaseOrder(\n        OrderPurchase calldata orderPurchase,\n        StandardOrder calldata order,\n        bytes32 orderSolvedByIdentifier,\n        bytes32 purchaser,\n        uint256 expiryTimestamp,\n        bytes calldata solverSignature\n    ) external virtual {\n        bytes32 computedOrderId = _orderIdentifier(order);\n        // Sanity check to ensure the user thinks they are buying the right order.\n        if (computedOrderId != orderPurchase.orderId) revert OrderIdMismatch(orderPurchase.orderId, computedOrderId);\n\n        _purchaseOrder(\n            orderPurchase, order.inputs, orderSolvedByIdentifier, purchaser, expiryTimestamp, solverSignature\n        );\n    }\n}\n"},"lib/OIF/src/input/types/StandardOrderType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { MandateOutput, MandateOutputType } from \"./MandateOutputType.sol\";\n\nstruct StandardOrder {\n    address user;\n    uint256 nonce;\n    uint256 originChainId;\n    uint32 expires;\n    uint32 fillDeadline;\n    address localOracle;\n    uint256[2][] inputs;\n    MandateOutput[] outputs;\n}\n\n/**\n * @notice This is the signed Compact witness structure. This allows us to more easily collect the order hash.\n * Notice that this is different to both the order data and the ERC7683 order.\n */\nstruct Mandate {\n    uint32 fillDeadline;\n    address localOracle;\n    MandateOutput[] outputs;\n}\n\n/**\n * @notice Helper library for the Catalyst order type.\n * TYPE_PARTIAL: An incomplete type. Is missing a field.\n * TYPE_STUB: Type has no subtypes.\n * TYPE: Is complete including sub-types.\n */\nlibrary StandardOrderType {\n    function orderIdentifier(\n        StandardOrder calldata order\n    ) internal view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                order.user,\n                order.nonce,\n                order.expires,\n                order.fillDeadline,\n                order.localOracle,\n                order.inputs,\n                abi.encode(order.outputs)\n            )\n        );\n    }\n\n    /// @dev TheCompact needs us to provide the type without the last \")\"\n    bytes constant BATCH_COMPACT_SUB_TYPES = bytes(\n        \"uint32 fillDeadline,address localOracle,MandateOutput[] outputs)MandateOutput(bytes32 oracle,bytes32 settler,uint256 chainId,bytes32 token,uint256 amount,bytes32 recipient,bytes call,bytes context\"\n    );\n\n    /// @dev For hashing of our subtypes, we need proper types.\n    bytes constant CATALYST_WITNESS_TYPE = abi.encodePacked(\n        \"Mandate(uint32 fillDeadline,address localOracle,MandateOutput[] outputs)MandateOutput(bytes32 oracle,bytes32 settler,uint256 chainId,bytes32 token,uint256 amount,bytes32 recipient,bytes call,bytes context)\"\n    );\n    bytes32 constant CATALYST_WITNESS_TYPE_HASH = keccak256(CATALYST_WITNESS_TYPE);\n\n    /**\n     * @notice Computes the Compact witness of derived from a StandardOrder\n     * @param order StandardOrder to derived the witness from.\n     * @return witness hash.\n     */\n    function witnessHash(\n        StandardOrder calldata order\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                CATALYST_WITNESS_TYPE_HASH,\n                order.fillDeadline,\n                order.localOracle,\n                MandateOutputType.hashOutputs(order.outputs)\n            )\n        );\n    }\n}\n"},"lib/OIF/src/interfaces/IOIFCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @notice Callback handling for OIF payouts, both outputs and inputs.\n */\ninterface IOIFCallback {\n    /**\n     * @notice If configured, is called when the output is filled on the output chain.\n     */\n    function outputFilled(bytes32 token, uint256 amount, bytes calldata executionData) external;\n\n    /**\n     * @notice If configured, is called when the input is sent to the filler.\n     * @param inputs Inputs of the order.\n     * @param executionData Custom data.\n     */\n    function orderFinalised(uint256[2][] calldata inputs, bytes calldata executionData) external;\n}\n"},"src/libs/GovernanceFee.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\nimport { Ownable } from \"solady/auth/Ownable.sol\";\n\n/**\n * @notice Governance fee timelock\n * Allows for safely setting and changing a governance fee through a built in time-lock. Also provides a generic\n * function to compute the the impact of the governance fee on an amount.\n */\nabstract contract GovernanceFee is Ownable {\n    error GovernanceFeeTooHigh();\n    error GovernanceFeeChangeNotReady();\n\n    /**\n     * @notice Governance fee will be changed shortly.\n     */\n    event NextGovernanceFee(uint64 nextGovernanceFee, uint64 nextGovernanceFeeTime);\n\n    /**\n     * @notice Governance fee changed. This fee is taken of the inputs.\n     */\n    event GovernanceFeeChanged(uint64 oldGovernanceFee, uint64 newGovernanceFee);\n\n    /**\n     * @notice When a new governance fee is set, when will it be applicable.\n     * @dev Is used to prevent changing governance from changing the fee mid-flight.\n     */\n    uint64 constant GOVERNANCE_FEE_CHANGE_DELAY = 7 days;\n    /**\n     * @dev Resolution of the governance fee. Need to fit in uint64.\n     */\n    uint256 constant GOVERNANCE_FEE_DENOM = 10 ** 18;\n    /**\n     * @dev Max possible fee.\n     */\n    uint64 constant MAX_GOVERNANCE_FEE = 10 ** 18 * 0.05; // 5%\n\n    /**\n     * @notice Current applied governance fee.\n     */\n    uint64 public governanceFee = 0;\n    /**\n     * @notice Next governance fee. Will be applied: nextGovernanceFeeTime < block.timestamp\n     */\n    uint64 public nextGovernanceFee = 0;\n    /**\n     * @notice When the next governance fee will be applied. Is type(uint64).max when no change is scheduled.\n     */\n    uint64 public nextGovernanceFeeTime = type(uint64).max;\n\n    /**\n     * @notice Sets a new governanceFee. Is immediately applied to orders initiated after this call.\n     * @param _nextGovernanceFee New governance fee. Is bounded by MAX_GOVERNANCE_FEE.\n     */\n    function setGovernanceFee(\n        uint64 _nextGovernanceFee\n    ) external onlyOwner {\n        if (_nextGovernanceFee > MAX_GOVERNANCE_FEE) revert GovernanceFeeTooHigh();\n        nextGovernanceFee = _nextGovernanceFee;\n        nextGovernanceFeeTime = uint64(block.timestamp) + GOVERNANCE_FEE_CHANGE_DELAY;\n\n        emit NextGovernanceFee(nextGovernanceFee, nextGovernanceFeeTime);\n    }\n\n    /**\n     * @notice Applies a scheduled governace fee change.\n     */\n    function applyGovernanceFee() external {\n        if (block.timestamp < nextGovernanceFeeTime) revert GovernanceFeeChangeNotReady();\n        // Load the previous governance fee.\n        uint64 oldGovernanceFee = governanceFee;\n        // Set the next governanceFee.\n        governanceFee = nextGovernanceFee;\n        // Ensure this function can't be called again.\n        nextGovernanceFeeTime = type(uint64).max;\n\n        // Emit associated event.\n        emit GovernanceFeeChanged(oldGovernanceFee, nextGovernanceFee);\n    }\n\n    /**\n     * @notice Helper function to compute the fee.\n     * @param amount To compute fee of.\n     * @param fee Fee to subtract from amount. Is percentage and GOVERNANCE_FEE_DENOM based.\n     * @return amountFee Fee\n     */\n    function _calcFee(uint256 amount, uint256 fee) internal pure returns (uint256 amountFee) {\n        unchecked {\n            // Check if amount * fee overflows. If it does, don't take the fee.\n            if (fee == 0 || amount >= type(uint256).max / fee) return amountFee = 0;\n            // The above check ensures that amount * fee < type(uint256).max.\n            // amount >= amount * fee / GOVERNANCE_FEE_DENOM since fee < GOVERNANCE_FEE_DENOM\n            return amountFee = amount * fee / GOVERNANCE_FEE_DENOM;\n        }\n    }\n}\n"},"src/libs/RegisterIntentLib.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.26;\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\nimport { TheCompact } from \"the-compact/src/TheCompact.sol\";\nimport { EfficiencyLib } from \"the-compact/src/lib/EfficiencyLib.sol\";\n\nimport { MandateOutputType } from \"OIF/src/input/types/MandateOutputType.sol\";\nimport { StandardOrder, StandardOrderType } from \"OIF/src/input/types/StandardOrderType.sol\";\n\n/**\n * @notice Governance fee timelock\n * Allows for safely setting and changing a governance fee through a built in time-lock. Also provides a generic\n * function to compute the the impact of the governance fee on an amount.\n */\nlibrary RegisterIntentLib {\n    error DeadlinePassed();\n    error WrongChain(uint256 expected, uint256 provided);\n\n    bytes32 constant STANDARD_ORDER_BATCH_COMPACT_TYPE_HASH = keccak256(\n        bytes(\n            \"BatchCompact(address arbiter,address sponsor,uint256 nonce,uint256 expires,Lock[] commitments,Mandate mandate)Lock(bytes12 lockTag,address token,uint256 amount)Mandate(uint32 fillDeadline,address localOracle,MandateOutput[] outputs)MandateOutput(bytes32 oracle,bytes32 settler,uint256 chainId,bytes32 token,uint256 amount,bytes32 recipient,bytes call,bytes context)\"\n        )\n    );\n\n    // Copy from OIF implementation with elements in memory for usage inside other contracts constructing the\n    // StandardOrder.\n    function witnessHash(\n        StandardOrder memory order\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                StandardOrderType.CATALYST_WITNESS_TYPE_HASH,\n                order.fillDeadline,\n                order.localOracle,\n                MandateOutputType.hashOutputsM(order.outputs)\n            )\n        );\n    }\n\n    function getLocksHash(\n        uint256[2][] calldata idsAndAmounts\n    ) public pure returns (bytes32) {\n        unchecked {\n            uint256 numIdsAndAmounts = idsAndAmounts.length;\n            bytes memory currentHash = new bytes(32 * numIdsAndAmounts);\n            for (uint256 i; i < numIdsAndAmounts; ++i) {\n                uint256[2] calldata idsAndAmount = idsAndAmounts[i];\n                bytes32 lockHash = keccak256(\n                    abi.encode(\n                        keccak256(bytes(\"Lock(bytes12 lockTag,address token,uint256 amount)\")),\n                        bytes12(bytes32(idsAndAmount[0])),\n                        address(uint160(idsAndAmount[0])),\n                        idsAndAmount[1]\n                    )\n                );\n                assembly (\"memory-safe\") {\n                    mstore(add(add(currentHash, 0x20), mul(i, 0x20)), lockHash)\n                }\n            }\n\n            return keccak256(currentHash);\n        }\n    }\n\n    function compactClaimHash(address settler, StandardOrder calldata order) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                STANDARD_ORDER_BATCH_COMPACT_TYPE_HASH,\n                settler,\n                order.user,\n                order.nonce,\n                order.expires,\n                getLocksHash(order.inputs),\n                StandardOrderType.witnessHash(order)\n            )\n        );\n    }\n\n    function _validateChain(\n        uint256 originChainId\n    ) internal view {\n        // Check that this is the right originChain\n        if (block.chainid != originChainId) revert WrongChain(block.chainid, originChainId);\n    }\n\n    function _validateExpiry(uint32 fillDeadline, uint32 expires) internal view {\n        // Check if the fill deadline has been passed\n        if (block.timestamp > fillDeadline) revert DeadlinePassed();\n        // Check if expiry has been passed\n        if (block.timestamp > expires) revert DeadlinePassed();\n    }\n\n    /**\n     * @notice Deposits and registerers the intent associated with an OIF StandardOrder.\n     * @param setApprovals Whether or not to set approvals for the intents inputs. Set as a constant such that the\n     * Solidity function specialiser either deletes or or inlines the loop.\n     */\n    function depositAndRegisterIntentFor(\n        address COMPACT,\n        address arbiter,\n        StandardOrder memory order,\n        bool setApprovals\n    ) internal returns (bytes32 claimHash) {\n        _validateChain(order.originChainId);\n        _validateExpiry(order.fillDeadline, order.expires);\n\n        uint256[2][] memory idsAndAmounts = order.inputs;\n        if (setApprovals) {\n            uint256 numInputs = idsAndAmounts.length;\n            // We need to collect the tokens from msg.sender.\n            for (uint256 i; i < numInputs; ++i) {\n                // Collect tokens from sender\n                uint256[2] memory idAndAmount = idsAndAmounts[i];\n                SafeTransferLib.safeApproveWithRetry(\n                    EfficiencyLib.asSanitizedAddress(idAndAmount[0]), address(COMPACT), idAndAmount[1]\n                );\n            }\n        }\n\n        (claimHash,) = TheCompact(COMPACT).batchDepositAndRegisterFor(\n            order.user,\n            idsAndAmounts,\n            arbiter,\n            order.nonce,\n            order.expires,\n            STANDARD_ORDER_BATCH_COMPACT_TYPE_HASH,\n            witnessHash(order)\n        );\n    }\n}\n"},"lib/the-compact/src/types/Scope.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nenum Scope {\n    Multichain,\n    ChainSpecific\n}\n"},"lib/the-compact/src/types/ResetPeriod.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nenum ResetPeriod {\n    OneSecond,\n    FifteenSeconds,\n    OneMinute,\n    TenMinutes,\n    OneHourAndFiveMinutes,\n    OneDay,\n    SevenDaysAndOneHour,\n    ThirtyDays\n}\n"},"lib/the-compact/src/types/CompactCategory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nenum CompactCategory {\n    Compact,\n    BatchCompact,\n    MultichainCompact\n}\n"},"lib/solady/src/utils/EfficientHashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      EQUALITY CHECKS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }\n\n    /// @dev Returns `abi.decode(a, (bytes32)) == a`.\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      SHA2-256 HELPERS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n}\n"},"lib/solady/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /// @dev The Permit2 approve operation has failed.\n    error Permit2ApproveFailed();\n\n    /// @dev The Permit2 lockdown operation has failed.\n    error Permit2LockdownFailed();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(\n                        add(m, 0x94),\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    )\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            let m := mload(0x40)\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\n            mstore(add(m, 0x20), and(addressMask, token))\n            mstore(add(m, 0x40), and(addressMask, spender))\n            mstore(add(m, 0x60), and(addressMask, amount))\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\n    function permit2Lockdown(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\n            mstore(add(m, 0x40), 1) // `approvals.length`.\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/TheCompact.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ITheCompact } from \"./interfaces/ITheCompact.sol\";\n\nimport { AllocatedBatchTransfer } from \"./types/BatchClaims.sol\";\nimport { AllocatedTransfer } from \"./types/Claims.sol\";\nimport { CompactCategory } from \"./types/CompactCategory.sol\";\nimport { Scope } from \"./types/Scope.sol\";\nimport { ResetPeriod } from \"./types/ResetPeriod.sol\";\nimport { ForcedWithdrawalStatus } from \"./types/ForcedWithdrawalStatus.sol\";\nimport { EmissaryStatus } from \"./types/EmissaryStatus.sol\";\nimport { DepositDetails } from \"./types/DepositDetails.sol\";\n\nimport { ERC6909 } from \"solady/tokens/ERC6909.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\nimport { TheCompactLogic } from \"./lib/TheCompactLogic.sol\";\n\n/**\n * @title The Compact\n * @custom:version 1\n * @author 0age (0age.eth)\n * @notice The Compact is an ownerless ERC6909 contract that facilitates the voluntary\n *         formation and mediation of reusable \"resource locks.\"\n *         This contract has not yet been properly tested, audited, or reviewed.\n */\ncontract TheCompact is ITheCompact, ERC6909, TheCompactLogic {\n    function depositNative(bytes12 lockTag, address recipient) external payable returns (uint256) {\n        return _performCustomNativeTokenDeposit(lockTag, recipient);\n    }\n\n    function depositERC20(address token, bytes12 lockTag, uint256 amount, address recipient)\n        external\n        returns (uint256 id)\n    {\n        (id,) = _performCustomERC20Deposit(token, lockTag, amount, recipient);\n    }\n\n    function batchDeposit(uint256[2][] calldata idsAndAmounts, address recipient) external payable returns (bool) {\n        _processBatchDeposit(idsAndAmounts, recipient, false);\n\n        return true;\n    }\n\n    function depositERC20ViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address, // depositor\n        bytes12, // lockTag\n        address recipient,\n        bytes calldata signature\n    ) external returns (uint256) {\n        return _depositViaPermit2(permit.permitted.token, recipient, signature);\n    }\n\n    function batchDepositViaPermit2(\n        address, // depositor\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata,\n        address recipient,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory) {\n        return _depositBatchViaPermit2(permitted, recipient, signature);\n    }\n\n    function allocatedTransfer(AllocatedTransfer calldata transfer) external returns (bool) {\n        return _processTransfer(transfer);\n    }\n\n    function allocatedBatchTransfer(AllocatedBatchTransfer calldata transfer) external returns (bool) {\n        return _processBatchTransfer(transfer);\n    }\n\n    function register(bytes32 claimHash, bytes32 typehash) external returns (bool) {\n        _register(msg.sender, claimHash, typehash);\n\n        return true;\n    }\n\n    function registerMultiple(bytes32[2][] calldata claimHashesAndTypehashes) external returns (bool) {\n        return _registerBatch(claimHashesAndTypehashes);\n    }\n\n    function registerFor(\n        bytes32 typehash,\n        address, // arbiter\n        address sponsor,\n        uint256, // nonce\n        uint256, // expires\n        bytes12, // lockTag\n        address, // token\n        uint256, // amount\n        bytes32, // witness\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash) {\n        return _registerFor(sponsor, typehash, sponsorSignature);\n    }\n\n    function registerBatchFor(\n        bytes32 typehash,\n        address, // arbiter\n        address sponsor,\n        uint256, // nonce\n        uint256, // expires\n        bytes32, // commitmentsHash\n        bytes32, // witness\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash) {\n        return _registerBatchFor(sponsor, typehash, sponsorSignature);\n    }\n\n    function registerMultichainFor(\n        bytes32 typehash,\n        address sponsor,\n        uint256, // nonce,\n        uint256, // expires,\n        bytes32, // elementsHash,\n        uint256 notarizedChainId,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash) {\n        return _registerMultichainFor(sponsor, typehash, notarizedChainId, sponsorSignature);\n    }\n\n    function depositNativeAndRegister(bytes12 lockTag, bytes32 claimHash, bytes32 typehash)\n        external\n        payable\n        returns (uint256 id)\n    {\n        id = _performCustomNativeTokenDeposit(lockTag, msg.sender);\n\n        _register(msg.sender, claimHash, typehash);\n    }\n\n    function depositNativeAndRegisterFor(\n        address recipient,\n        bytes12 lockTag,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (uint256 id, bytes32 claimHash) {\n        id = _performCustomNativeTokenDeposit(lockTag, recipient);\n\n        claimHash = _registerUsingCompact(recipient, id, msg.value, arbiter, nonce, expires, typehash, witness);\n    }\n\n    function depositERC20AndRegister(\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        bytes32 claimHash,\n        bytes32 typehash\n    ) external returns (uint256 id) {\n        (id,) = _performCustomERC20Deposit(token, lockTag, amount, msg.sender);\n\n        _register(msg.sender, claimHash, typehash);\n    }\n\n    function depositERC20AndRegisterFor(\n        address recipient,\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external returns (uint256 id, bytes32 claimHash, uint256 registeredAmount) {\n        (id, registeredAmount) = _performCustomERC20Deposit(token, lockTag, amount, recipient);\n\n        claimHash = _registerUsingCompact(recipient, id, registeredAmount, arbiter, nonce, expires, typehash, witness);\n    }\n\n    function batchDepositAndRegisterMultiple(\n        uint256[2][] calldata idsAndAmounts,\n        bytes32[2][] calldata claimHashesAndTypehashes\n    ) external payable returns (bool) {\n        _processBatchDeposit(idsAndAmounts, msg.sender, false);\n\n        return _registerBatch(claimHashesAndTypehashes);\n    }\n\n    function batchDepositAndRegisterFor(\n        address recipient,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (bytes32 claimHash, uint256[] memory registeredAmounts) {\n        registeredAmounts = _processBatchDeposit(idsAndAmounts, recipient, true);\n\n        claimHash = _registerUsingBatchCompact(\n            recipient, idsAndAmounts, arbiter, nonce, expires, typehash, witness, registeredAmounts\n        );\n    }\n\n    function depositERC20AndRegisterViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address depositor, // also recipient\n        bytes12, // lockTag\n        bytes32 claimHash,\n        CompactCategory, // compactCategory\n        string calldata witness,\n        bytes calldata signature\n    ) external returns (uint256) {\n        return _depositAndRegisterViaPermit2(permit.permitted.token, depositor, claimHash, witness, signature);\n    }\n\n    function batchDepositAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata,\n        bytes32, // claimHash\n        CompactCategory, // compactCategory\n        string calldata witness,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory) {\n        return _depositBatchAndRegisterViaPermit2(depositor, permitted, witness, signature);\n    }\n\n    function enableForcedWithdrawal(uint256 id) external returns (uint256) {\n        return _enableForcedWithdrawal(id);\n    }\n\n    function disableForcedWithdrawal(uint256 id) external returns (bool) {\n        _disableForcedWithdrawal(id);\n\n        return true;\n    }\n\n    function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool) {\n        _processForcedWithdrawal(id, recipient, amount);\n\n        return true;\n    }\n\n    function assignEmissary(bytes12 lockTag, address emissary) external returns (bool) {\n        return _assignEmissary(lockTag, emissary);\n    }\n\n    function scheduleEmissaryAssignment(bytes12 lockTag) external returns (uint256 emissaryAssignmentAvailableAt) {\n        return _scheduleEmissaryAssignment(lockTag);\n    }\n\n    function consume(uint256[] calldata nonces) external returns (bool) {\n        return _consume(nonces);\n    }\n\n    function __registerAllocator(address allocator, bytes calldata proof) external returns (uint96) {\n        return _registerAllocator(allocator, proof);\n    }\n\n    function __benchmark(bytes32 /* salt */ ) external payable {\n        _benchmark();\n    }\n\n    function getRequiredWithdrawalFallbackStipends()\n        external\n        view\n        returns (uint256 nativeTokenStipend, uint256 erc20TokenStipend)\n    {\n        return _getRequiredWithdrawalFallbackStipends();\n    }\n\n    function getForcedWithdrawalStatus(address account, uint256 id)\n        external\n        view\n        returns (ForcedWithdrawalStatus, uint256)\n    {\n        return _getForcedWithdrawalStatus(account, id);\n    }\n\n    function isRegistered(address sponsor, bytes32 claimHash, bytes32 typehash) external view returns (bool isActive) {\n        isActive = _isRegistered(sponsor, claimHash, typehash);\n    }\n\n    function getEmissaryStatus(address sponsor, bytes12 lockTag)\n        external\n        view\n        returns (EmissaryStatus status, uint256 emissaryAssignmentAvailableAt, address currentEmissary)\n    {\n        return _getEmissaryStatus(sponsor, lockTag);\n    }\n\n    function getLockDetails(uint256 id) external view returns (address, address, ResetPeriod, Scope, bytes12) {\n        return _getLockDetails(id);\n    }\n\n    function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool) {\n        return _hasConsumedAllocatorNonce(nonce, allocator);\n    }\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    /**\n     * @notice Returns the name for token `id`.\n     * @param id The ERC6909 token identifier to get the name for.\n     * @return The name of the token.\n     */\n    function name(uint256 id) public view virtual override returns (string memory) {\n        return _name(id);\n    }\n\n    /**\n     * @notice Returns the symbol for token `id`.\n     * @param id The ERC6909 token identifier to get the symbol for.\n     * @return The symbol of the token.\n     */\n    function symbol(uint256 id) public view virtual override returns (string memory) {\n        return _symbol(id);\n    }\n\n    /**\n     * @notice Returns the decimals for token `id`.\n     * @param id The ERC6909 token identifier to get the decimals for.\n     * @return The decimals of the token.\n     */\n    function decimals(uint256 id) public view virtual override returns (uint8) {\n        return _decimals(id);\n    }\n\n    /**\n     * @notice Returns the ERC6909 Uniform Resource Identifier (URI) for token `id`.\n     * @param id The ERC6909 token identifier to get the URI for.\n     * @return The URI of the token.\n     */\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\n        return _tokenURI(id);\n    }\n\n    /**\n     * @notice External pure function for returning the name of the contract.\n     * @return A string representing the name of the contract.\n     */\n    function name() external pure returns (string memory) {\n        // Return the name of the contract.\n        assembly (\"memory-safe\") {\n            mstore(0x20, 0x20)\n            mstore(0x4b, 0x0b54686520436f6d70616374)\n            return(0x20, 0x60)\n        }\n    }\n\n    /**\n     * @notice Hook that is called before any standard ERC6909 token transfer. Note that this hook\n     *         is not called when performing allocated transfers or when processing claims, nor are\n     *         standard token approvals required.\n     * @param from   The address tokens are transferred from.\n     * @param to     The address tokens are transferred to.\n     * @param id     The ERC6909 token identifier.\n     * @param amount The amount of tokens being transferred.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 id, uint256 amount) internal virtual override {\n        _ensureAttested(from, to, id, amount);\n    }\n}\n"},"lib/OIF/src/interfaces/IOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IOracle {\n    /**\n     * @notice Check if some data has been attested to on the remote chain.\n     * @param remoteChainId ChainId of data origin.\n     * @param remoteOracle Attestor on the data origin chain.\n     * @param application Application that the data originated from.\n     * @param dataHash Hash of data.\n     */\n    function isProven(\n        uint256 remoteChainId,\n        bytes32 remoteOracle,\n        bytes32 application,\n        bytes32 dataHash\n    ) external view returns (bool);\n\n    /**\n     * @notice Check if a series of data has been attested to.\n     * @dev More efficient implementation of isProven. Does not return a boolean, instead reverts if false.\n     * This function returns true if proofSeries is empty.\n     * @param proofSeries remoteChainId, remoteOracle, application, and dataHash encoded in chucks of 32*4=128 bytes.\n     */\n    function efficientRequireProven(\n        bytes calldata proofSeries\n    ) external view;\n}\n"},"lib/OIF/src/interfaces/IInputSettlerCompact.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport { MandateOutput } from \"../input/types/MandateOutputType.sol\";\nimport { OrderPurchase } from \"../input/types/OrderPurchaseType.sol\";\nimport { StandardOrder } from \"../input/types/StandardOrderType.sol\";\n\ninterface IInputSettlerCompact {\n    function finalise(\n        StandardOrder memory order,\n        bytes memory signatures,\n        uint32[] memory timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes memory call\n    ) external;\n\n    function finaliseWithSignature(\n        StandardOrder memory order,\n        bytes memory signatures,\n        uint32[] memory timestamps,\n        bytes32[] memory solvers,\n        bytes32 destination,\n        bytes memory call,\n        bytes memory orderOwnerSignature\n    ) external;\n\n    function orderIdentifier(\n        StandardOrder memory order\n    ) external view returns (bytes32);\n\n    function purchaseOrder(\n        OrderPurchase memory orderPurchase,\n        StandardOrder memory order,\n        bytes32 orderSolvedByIdentifier,\n        bytes32 purchaser,\n        uint256 expiryTimestamp,\n        bytes memory solverSignature\n    ) external;\n}\n"},"lib/OIF/src/libs/BytesLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Library for Bytes Manipulation\n/// Based on Gonalo S's BytesLib\nlibrary BytesLib {\n    /**\n     * @notice Takes a calldata reference, and decodes a bytes based on offset.\n     * @param _bytes Calldata reference.\n     * @param offset Offset for bytes array.\n     */\n    function toBytes(bytes calldata _bytes, uint256 offset) internal pure returns (bytes calldata res) {\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, offset)))\n            res.offset := add(lengthPtr, 0x20)\n            res.length := calldataload(lengthPtr)\n        }\n    }\n}\n"},"lib/OIF/src/libs/MandateOutputEncodingLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { MandateOutput } from \"../input/types/MandateOutputType.sol\";\n\n/**\n * @notice Converts MandateOutputs to and from byte payloads.\n * @dev This library defines 2 payload encodings, one for internal usage and one for cross-chain communication.\n * - MandateOutput serialisation of the exact output on a output chain (encodes the entirety MandateOutput struct). This\n * encoding may be used to obtain a collision free hash to uniquely identify a MandateOutput.\n * - FillDescription serialisation to describe describe what has been filled on a remote chain. Its purpose is to\n * provide a source of truth of a remote action.\n * The encoding scheme uses 2 bytes long length identifiers. As a result, neither call nor context exceed 65'535 bytes.\n *\n * Serialised MandateOutput\n *      REMOTE_ORACLE           0               (32 bytes)\n *      + REMOTE_FILLER         32              (32 bytes)\n *      + CHAIN_ID              64              (32 bytes)\n *      + COMMON_PAYLOAD        96\n *\n * Serialised FillDescription\n *      SOLVER                  0               (32 bytes)\n *      + ORDERID               32              (32 bytes)\n *      + TIMESTAMP             64              (4 bytes)\n *      + COMMON_PAYLOAD        68\n *\n * Common Payload. Is identical between both schemes\n *      + TOKEN                 Y               (32 bytes)\n *      + AMOUNT                Y+32            (32 bytes)\n *      + RECIPIENT             Y+64            (32 bytes)\n *      + CALL_LENGTH           Y+96            (2 bytes)\n *      + CALL                  Y+98            (LENGTH bytes)\n *      + CONTEXT_LENGTH        Y+98+RC_LENGTH  (2 bytes)\n *      + CONTEXT               Y+100+RC_LENGTH (LENGTH bytes)\n *\n * where Y is the offset from the specific encoding (either 68 or 96)\n */\nlibrary MandateOutputEncodingLib {\n    error ContextOutOfRange();\n    error CallOutOfRange();\n\n    // --- MandateOutput --- //\n\n    /**\n     * @notice Predictable encoding of MandateOutput that deliberately overlaps with the payload encoding.\n     * @dev The encoding scheme uses 2 bytes long length identifiers. As a result, neither call nor context exceed\n     * 65'535 bytes.\n     */\n    function encodeMandateOutput(\n        MandateOutput calldata mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        bytes calldata call = mandateOutput.call;\n        bytes calldata context = mandateOutput.context;\n        if (call.length > type(uint16).max) revert CallOutOfRange();\n        if (context.length > type(uint16).max) revert ContextOutOfRange();\n\n        return encodedOutput = abi.encodePacked(\n            mandateOutput.oracle,\n            mandateOutput.settler,\n            mandateOutput.chainId,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            uint16(call.length), // To protect against data collisions\n            call,\n            uint16(context.length), // To protect against data collisions\n            context\n        );\n    }\n\n    function encodeMandateOutputMemory(\n        MandateOutput memory mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        bytes memory call = mandateOutput.call;\n        bytes memory context = mandateOutput.context;\n        if (call.length > type(uint16).max) revert CallOutOfRange();\n        if (context.length > type(uint16).max) revert ContextOutOfRange();\n\n        return encodedOutput = abi.encodePacked(\n            mandateOutput.oracle,\n            mandateOutput.settler,\n            mandateOutput.chainId,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            uint16(call.length), // To protect against data collisions\n            call,\n            uint16(context.length), // To protect against data collisions\n            context\n        );\n    }\n\n    /**\n     * @notice Hash of an MandateOutput intended for output identification.\n     * @dev This identifier is purely intended for the remote chain. It should never be ferried cross-chain.\n     * Chains or VMs may hash data differently.\n     */\n    function getMandateOutputHash(\n        MandateOutput calldata output\n    ) internal pure returns (bytes32) {\n        return keccak256(encodeMandateOutput(output));\n    }\n\n    function getMandateOutputHashMemory(\n        MandateOutput memory output\n    ) internal pure returns (bytes32) {\n        return keccak256(encodeMandateOutputMemory(output));\n    }\n\n    // --- FillDescription Encoding --- //\n\n    /**\n     * @notice FillDescription encoding.\n     * @dev The encoding scheme uses 2 bytes long length identifiers. As a result, neither call nor context exceed\n     * 65'535 bytes.\n     */\n    function encodeFillDescription(\n        bytes32 solver,\n        bytes32 orderId,\n        uint32 timestamp,\n        bytes32 token,\n        uint256 amount,\n        bytes32 recipient,\n        bytes memory call,\n        bytes memory context\n    ) internal pure returns (bytes memory encodedOutput) {\n        if (call.length > type(uint16).max) revert CallOutOfRange();\n        if (context.length > type(uint16).max) revert ContextOutOfRange();\n\n        return encodedOutput = abi.encodePacked(\n            solver,\n            orderId,\n            timestamp,\n            token,\n            amount,\n            recipient,\n            uint16(call.length), // To protect against data collisions\n            call,\n            uint16(context.length), // To protect against data collisions\n            context\n        );\n    }\n\n    /**\n     * @notice Encodes an output description into a fill description.\n     */\n    function encodeFillDescription(\n        bytes32 solver,\n        bytes32 orderId,\n        uint32 timestamp,\n        MandateOutput calldata mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        return encodedOutput = encodeFillDescription(\n            solver,\n            orderId,\n            timestamp,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            mandateOutput.call,\n            mandateOutput.context\n        );\n    }\n\n    function encodeFillDescriptionM(\n        bytes32 solver,\n        bytes32 orderId,\n        uint32 timestamp,\n        MandateOutput memory mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        return encodedOutput = encodeFillDescription(\n            solver,\n            orderId,\n            timestamp,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            mandateOutput.call,\n            mandateOutput.context\n        );\n    }\n}\n"},"lib/OIF/src/input/BaseInputSettler.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\nimport { EfficiencyLib } from \"the-compact/src/lib/EfficiencyLib.sol\";\n\nimport { IOIFCallback } from \"../interfaces/IOIFCallback.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\nimport { AllowOpenType } from \"./types/AllowOpenType.sol\";\nimport { MandateOutput } from \"./types/MandateOutputType.sol\";\nimport { OrderPurchase, OrderPurchaseType } from \"./types/OrderPurchaseType.sol\";\n\n/**\n * @title Base Input Settler\n * @notice Defines common logic that can be reused by other input settlers to support a variety of asset management\n * schemes.\n */\nabstract contract BaseInputSettler is EIP712 {\n    error AlreadyPurchased();\n    error Expired();\n    error InvalidPurchaser();\n    error InvalidSigner();\n\n    event Finalised(bytes32 indexed orderId, bytes32 solver, bytes32 destination);\n    event OrderPurchased(bytes32 indexed orderId, bytes32 solver, bytes32 purchaser);\n\n    uint256 constant DISCOUNT_DENOM = 10 ** 18;\n\n    struct Purchased {\n        uint32 lastOrderTimestamp;\n        bytes32 purchaser;\n    }\n\n    mapping(bytes32 solver => mapping(bytes32 orderId => Purchased)) public purchasedOrders;\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // --- Timestamp Helpers --- //\n\n    /**\n     * @param timestamps Array of uint32s.\n     * @return timestamp Largest element of timestamps.\n     */\n    function _maxTimestamp(\n        uint32[] calldata timestamps\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = timestamps[0];\n\n        uint256 numTimestamps = timestamps.length;\n        for (uint256 i = 1; i < numTimestamps; ++i) {\n            uint32 nextTimestamp = timestamps[i];\n            if (timestamp < nextTimestamp) timestamp = nextTimestamp;\n        }\n    }\n\n    /**\n     * @param timestamps Array of uint32s.\n     * @return timestamp Smallest element of timestamps.\n     */\n    function _minTimestamp(\n        uint32[] calldata timestamps\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = timestamps[0];\n\n        uint256 numTimestamps = timestamps.length;\n        for (uint256 i = 1; i < numTimestamps; ++i) {\n            uint32 nextTimestamp = timestamps[i];\n            if (timestamp > nextTimestamp) timestamp = nextTimestamp;\n        }\n    }\n\n    // --- External Claimant --- //\n\n    /**\n     * @notice Check for a signed message by an order owner to allow someone else to redeem an order.\n     * @dev See AllowOpenType.sol\n     * @param orderId A unique identifier for an order.\n     * @param orderOwner Owner of the order, and signer of orderOwnerSignature.\n     * @param nextDestination New destination.\n     * @param call An external call required by orderOwner.\n     * @param orderOwnerSignature EIP712 Signature of AllowOpen by orderOwner.\n     */\n    function _allowExternalClaimant(\n        bytes32 orderId,\n        address orderOwner,\n        bytes32 nextDestination,\n        bytes calldata call,\n        bytes calldata orderOwnerSignature\n    ) internal view {\n        bytes32 digest = _hashTypedData(AllowOpenType.hashAllowOpen(orderId, nextDestination, call));\n        bool isValid = SignatureCheckerLib.isValidSignatureNowCalldata(orderOwner, digest, orderOwnerSignature);\n        if (!isValid) revert InvalidSigner();\n    }\n\n    // --- Order Purchase Helpers --- //\n\n    /**\n     * @notice Helper function to get the owner of order incase it may have been bought. In case an order has been\n     * bought, and bought in time, the owner will be set to the purchaser. Otherwise it will be set to the solver.\n     * @param orderId A unique identifier for an order.\n     * @param solver Solver identifier that filled the order.\n     * @param timestamps List of timestamps for when the outputs were filled.\n     * @return orderOwner Owner of the order.\n     */\n    function _purchaseGetOrderOwner(\n        bytes32 orderId,\n        bytes32 solver,\n        uint32[] calldata timestamps\n    ) internal returns (bytes32 orderOwner) {\n        Purchased storage purchaseDetails = purchasedOrders[solver][orderId];\n        uint32 lastOrderTimestamp = purchaseDetails.lastOrderTimestamp;\n        bytes32 purchaser = purchaseDetails.purchaser;\n\n        if (purchaser != bytes32(0)) {\n            // We use the last fill (oldest) to gauge if the order was purchased in time.\n            uint256 orderTimestamp = _maxTimestamp(timestamps);\n            delete purchaseDetails.lastOrderTimestamp;\n            delete purchaseDetails.purchaser;\n            // If the timestamp is less than or equal to lastOrderTimestamp, the order was purchased in time.\n            if (lastOrderTimestamp <= orderTimestamp) return purchaser;\n        }\n        return solver;\n    }\n\n    /**\n     * @notice Helper functions for purchasing orders.\n     *  @dev The integrating implementation needs to provide the correct orderId and inputs according to the order.\n     * @param orderPurchase Order purchase description signed by solver.\n     * @param inputs Order inputs that have to be bought.\n     * @param orderSolvedByIdentifier Solver of the order. Is not validated.\n     * @param purchaser The new order owner.\n     * @param expiryTimestamp Set to ensure if your transaction does not mine quickly, you don't end up purchasing an\n     * order that you can not prove OR is outside the timeToBuy window.\n     * @param solverSignature EIP712 Signature of OrderPurchase by orderOwner.\n     */\n    function _purchaseOrder(\n        OrderPurchase calldata orderPurchase,\n        uint256[2][] calldata inputs,\n        bytes32 orderSolvedByIdentifier,\n        bytes32 purchaser,\n        uint256 expiryTimestamp,\n        bytes calldata solverSignature\n    ) internal {\n        if (purchaser == bytes32(0)) revert InvalidPurchaser();\n        if (expiryTimestamp < block.timestamp) revert Expired();\n\n        {\n            Purchased storage purchased = purchasedOrders[orderSolvedByIdentifier][orderPurchase.orderId];\n            if (purchased.purchaser != bytes32(0)) revert AlreadyPurchased();\n\n            // Reentry protection. Ensure that you can't reenter this contract.\n            unchecked {\n                // unchecked: uint32(block.timestamp) > timeToBuy => uint32(block.timestamp) - timeToBuy > 0.\n                uint32 timeToBuy = orderPurchase.timeToBuy;\n                purchased.lastOrderTimestamp =\n                    timeToBuy < uint32(block.timestamp) ? uint32(block.timestamp) - timeToBuy : 0;\n                purchased.purchaser = purchaser; // This disallows reentries through purchased.purchaser != address(0)\n            }\n            // We can now make external calls without allowing local reentries into this call.\n        }\n\n        {\n            address orderSolvedByAddress = address(uint160(uint256(orderSolvedByIdentifier)));\n            bytes32 digest = _hashTypedData(OrderPurchaseType.hashOrderPurchase(orderPurchase));\n            bool isValid =\n                SignatureCheckerLib.isValidSignatureNowCalldata(orderSolvedByAddress, digest, solverSignature);\n            if (!isValid) revert InvalidSigner();\n        }\n\n        address newDestination = orderPurchase.destination;\n        {\n            uint256 discount = orderPurchase.discount;\n            uint256 numInputs = inputs.length;\n            for (uint256 i; i < numInputs; ++i) {\n                uint256[2] calldata input = inputs[i];\n                uint256 tokenId = input[0];\n                uint256 allocatedAmount = input[1];\n                uint256 amountAfterDiscount = (allocatedAmount * (DISCOUNT_DENOM - discount)) / DISCOUNT_DENOM;\n                // Throws if discount > DISCOUNT_DENOM => DISCOUNT_DENOM - discount < 0;\n                SafeTransferLib.safeTransferFrom(\n                    EfficiencyLib.asSanitizedAddress(tokenId), msg.sender, newDestination, amountAfterDiscount\n                );\n            }\n            // Emit the event now because of stack issues.\n            emit OrderPurchased(orderPurchase.orderId, orderSolvedByIdentifier, purchaser);\n        }\n        {\n            bytes calldata call = orderPurchase.call;\n            if (call.length > 0) IOIFCallback(newDestination).orderFinalised(inputs, call);\n        }\n    }\n}\n"},"lib/OIF/src/input/types/MandateOutputType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nstruct MandateOutput {\n    /// @dev Oracle implementation responsible for collecting the proof from settler on output chain.\n    bytes32 oracle;\n    /// @dev Output Settler on the output chain responsible for settling the output payment.\n    bytes32 settler;\n    uint256 chainId;\n    bytes32 token;\n    uint256 amount;\n    bytes32 recipient;\n    /// @dev Data that will be delivered to recipient through the settlement callback on the output chain. Can be used\n    /// to schedule additional actions.\n    bytes call;\n    /// @dev Additional output context for the output settlement, encoding order types or other information.\n    bytes context;\n}\n\n/**\n * @notice Helper library for the Output description order type.\n * TYPE_PARTIAL: An incomplete type. Is missing a field.'\n * TYPE_STUB: Type has no subtypes.\n * TYPE: Is complete including sub-types.\n */\nlibrary MandateOutputType {\n    //--- Outputs Types ---//\n\n    bytes constant MANDATE_OUTPUT_TYPE_STUB = bytes(\n        \"MandateOutput(bytes32 oracle,bytes32 settler,uint256 chainId,bytes32 token,uint256 amount,bytes32 recipient,bytes call,bytes context)\"\n    );\n\n    bytes32 constant MANDATE_OUTPUT_TYPE_HASH = keccak256(MANDATE_OUTPUT_TYPE_STUB);\n\n    function hashOutput(\n        MandateOutput calldata output\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                MANDATE_OUTPUT_TYPE_HASH,\n                output.oracle,\n                output.settler,\n                output.chainId,\n                output.token,\n                output.amount,\n                output.recipient,\n                keccak256(output.call),\n                keccak256(output.context)\n            )\n        );\n    }\n\n    function hashOutputs(\n        MandateOutput[] calldata outputs\n    ) internal pure returns (bytes32) {\n        unchecked {\n            bytes memory currentHash = new bytes(32 * outputs.length);\n\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                bytes32 outputHash = hashOutput(outputs[i]);\n                assembly {\n                    mstore(add(add(currentHash, 0x20), mul(i, 0x20)), outputHash)\n                }\n            }\n            return keccak256(currentHash);\n        }\n    }\n\n    // Memory copy of the above:\n    function hashOutputM(\n        MandateOutput memory output\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                MANDATE_OUTPUT_TYPE_HASH,\n                output.oracle,\n                output.settler,\n                output.chainId,\n                output.token,\n                output.amount,\n                output.recipient,\n                keccak256(output.call),\n                keccak256(output.context)\n            )\n        );\n    }\n\n    function hashOutputsM(\n        MandateOutput[] memory outputs\n    ) internal pure returns (bytes32) {\n        unchecked {\n            bytes memory currentHash = new bytes(32 * outputs.length);\n\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                bytes32 outputHash = hashOutputM(outputs[i]);\n                assembly {\n                    mstore(add(add(currentHash, 0x20), mul(i, 0x20)), outputHash)\n                }\n            }\n            return keccak256(currentHash);\n        }\n    }\n}\n"},"lib/OIF/src/input/types/OrderPurchaseType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/// @notice Signed struct\nstruct OrderPurchase {\n    bytes32 orderId;\n    /// @dev unlike other destinations, this needs to be an external address\n    address destination;\n    bytes call;\n    uint64 discount;\n    /// @dev The purchaser has timeToBuy to buy the order after the order has been filled.\n    uint32 timeToBuy;\n}\n\n/**\n * @notice Helper library for the Order Purchase type.\n * TYPE_PARTIAL: An incomplete type. Is missing a field.\n * TYPE_STUB: Type has no subtypes.\n * TYPE: Is complete including sub-types.\n */\nlibrary OrderPurchaseType {\n    bytes constant ORDER_PURCHASE_TYPE_STUB =\n        bytes(\"OrderPurchase(bytes32 orderId,address destination,bytes call,uint64 discount,uint32 timeToBuy)\");\n\n    bytes32 constant ORDER_PURCHASE_TYPE_HASH = keccak256(ORDER_PURCHASE_TYPE_STUB);\n\n    /**\n     * @notice Hashes an AllowOpen struct.\n     * @param orderPurchase Description of the conditions for purchasing an order.\n     * @return digest of OrderPurchase.\n     */\n    function hashOrderPurchase(\n        OrderPurchase calldata orderPurchase\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                ORDER_PURCHASE_TYPE_HASH,\n                orderPurchase.orderId,\n                orderPurchase.destination,\n                keccak256(orderPurchase.call),\n                orderPurchase.discount,\n                orderPurchase.timeToBuy\n            )\n        );\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         MODIFIERS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"lib/the-compact/src/interfaces/ITheCompact.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ForcedWithdrawalStatus } from \"../types/ForcedWithdrawalStatus.sol\";\nimport { EmissaryStatus } from \"../types/EmissaryStatus.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { DepositDetails } from \"../types/DepositDetails.sol\";\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\n\n/**\n * @title The Compact  Core Interface\n * @custom:version 1\n * @author 0age (0age.eth)\n * @notice The Compact is an ownerless ERC6909 contract that facilitates the voluntary\n * formation and mediation of reusable \"resource locks.\" This interface contract specifies\n * external functions for making deposits, for performing allocated transfers and\n * withdrawals, for initiating and performing forced withdrawals, and for registering\n * compact claim hashes and typehashes directly. It also contains methods for registering\n * allocators and for enabling allocators to consume nonces directly. Finally, it specifies\n * a number of view functions, events and errors.\n */\ninterface ITheCompact {\n    /**\n     * @notice Event indicating that a claim has been processed for a given compact.\n     * @param sponsor    The account sponsoring the claimed compact.\n     * @param allocator  The account mediating the resource locks utilized by the claim.\n     * @param arbiter    The account verifying and initiating the settlement of the claim.\n     * @param claimHash  A bytes32 hash derived from the details of the claimed compact.\n     * @param nonce      The nonce (scoped to the allocator) on the claimed compact.\n     */\n    event Claim(\n        address indexed sponsor, address indexed allocator, address indexed arbiter, bytes32 claimHash, uint256 nonce\n    );\n\n    /**\n     * @notice Event indicating that a nonce has been consumed directly.\n     * @param allocator  The account mediating the nonces.\n     * @param nonce      The nonce (scoped to the allocator) in question.\n     */\n    event NonceConsumedDirectly(address indexed allocator, uint256 nonce);\n\n    /**\n     * @notice Event indicating a change in forced withdrawal status.\n     * @param account        The account for which the withdrawal status has changed.\n     * @param id             The ERC6909 token identifier of the associated resource lock.\n     * @param activating     Whether the forced withdrawal is being activated or has been deactivated.\n     * @param withdrawableAt The timestamp when tokens become withdrawable if it is being activated.\n     */\n    event ForcedWithdrawalStatusUpdated(\n        address indexed account, uint256 indexed id, bool activating, uint256 withdrawableAt\n    );\n\n    /**\n     * @notice Event indicating that a compact has been registered directly.\n     * @param sponsor   The address registering the compact in question.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     */\n    event CompactRegistered(address indexed sponsor, bytes32 claimHash, bytes32 typehash);\n\n    /**\n     * @notice Event indicating that an emissary has been assigned for a given sponsor and lock tag.\n     * @param sponsor  The address for which the emissary has been assigned.\n     * @param lockTag  The lock tag for which the emissary has been assigned.\n     * @param emissary The account of the emissary that has been assigned.\n     */\n    event EmissaryAssigned(address indexed sponsor, bytes12 indexed lockTag, address indexed emissary);\n\n    /**\n     * @notice Event indicating that a new emissary assignment has been scheduled for a given sponsor\n     * and lock tag. Note that this is only required when a previous emissary has already been assigned\n     * for the given combination of sponsor and lock tag.\n     * @param sponsor      The address for which the emissary assignment has been scheduled.\n     * @param lockTag      The lock tag for which the emissary assignment has been scheduled.\n     * @param assignableAt The block timestamp at which a new emissary may be assigned.\n     */\n    event EmissaryAssignmentScheduled(address indexed sponsor, bytes12 indexed lockTag, uint256 assignableAt);\n\n    /**\n     * @notice Event indicating an allocator has been registered.\n     * @param allocatorId The unique identifier assigned to the allocator.\n     * @param allocator   The address of the registered allocator.\n     */\n    event AllocatorRegistered(uint96 allocatorId, address allocator);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock with\n     * custom reset period and scope parameters. The ERC6909 token amount received by the recipient\n     * will match the amount of native tokens sent with the transaction. Note that supplying the\n     * null address for the recipient will result in the caller being applied as the recipient.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param recipient The address that will receive the corresponding ERC6909 tokens.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositNative(bytes12 lockTag, address recipient) external payable returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens into a resource lock with custom reset\n     * period and scope parameters. The caller must directly approve The Compact to transfer a\n     * sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount received by\n     * the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token.  Note that supplying the null address for\n     * the recipient will result in the caller being applied as the recipient.\n     * @param token     The address of the ERC20 token to deposit.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param amount    The amount of tokens to deposit.\n     * @param recipient The address that will receive the corresponding ERC6909 tokens.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20(address token, bytes12 lockTag, uint256 amount, address recipient)\n        external\n        returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens in a single transaction.\n     * The first entry in idsAndAmounts can optionally represent native tokens by providing the\n     * null address and an amount matching msg.value. For ERC20 tokens, the caller must directly\n     * approve The Compact to transfer sufficient amounts on its behalf. The ERC6909 token amounts\n     * received by the recipient are derived from the differences between starting and ending\n     * balances held in the resource locks, which may differ from the amounts transferred depending\n     * on the implementation details of the respective tokens.  Note that supplying the null\n     * address for the recipient will result in the caller being applied as the recipient.\n     * @param idsAndAmounts Array of [id, amount] pairs with each pair indicating the resource lock and amount to deposit.\n     * @param recipient     The address that will receive the corresponding ERC6909 tokens.\n     * @return              Whether the batch deposit was successfully completed.\n     */\n    function batchDeposit(uint256[2][] calldata idsAndAmounts, address recipient) external payable returns (bool);\n\n    /**\n     * @notice External function for depositing ERC20 tokens using Permit2 authorization. The\n     * depositor must approve Permit2 to transfer the tokens on its behalf unless the token in\n     * question automatically grants approval to Permit2. The ERC6909 token amount received by the\n     * by the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token. The Permit2 authorization signed by the\n     * depositor must contain a CompactDeposit witness containing the allocator, the reset period,\n     * the scope, and the intended recipient of the deposit.\n     * @param permit      The permit data signed by the depositor.\n     * @param lockTag     The lock tag containing allocator ID, reset period, and scope.\n     * @param recipient   The address that will receive the corresponding the ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposit.\n     * @return id         The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20ViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address depositor,\n        bytes12 lockTag,\n        address recipient,\n        bytes calldata signature\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens using Permit2\n     * authorization in a single transaction. The first token id can optionally represent native\n     * tokens by providing the null address and an amount matching msg.value. The depositor must\n     * approve Permit2 to transfer the tokens on its behalf unless the tokens automatically\n     * grant approval to Permit2. The ERC6909 token amounts received by the recipient are derived\n     * from the differences between starting and ending balances held in the resource locks,\n     * which may differ from the amounts transferred depending on the implementation details of\n     * the respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * CompactDeposit witness containing the allocator, the reset period, the scope, and the\n     * intended recipient of the deposits.\n     * @param depositor   The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted   The permit data signed by the depositor.\n     * @param details     The details of the deposit.\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids        Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function batchDepositViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata details,\n        address recipient,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory ids);\n\n    /**\n     * @notice Transfers or withdraws ERC6909 tokens to multiple recipients with allocator approval.\n     * @param transfer A Transfer struct containing the following:\n     *  -  allocatorData Authorization signature from the allocator.\n     *  -  nonce         Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires       Timestamp after which the transfer cannot be executed.\n     *  -  id            The ERC6909 token identifier of the resource lock.\n     *  -  recipients    A Component array, each containing:\n     *     -  claimant   The account that will receive tokens.\n     *     -  amount     The amount of tokens the claimant will receive.\n     * @return Whether the transfer or withdrawal was successful.\n     */\n    function allocatedTransfer(AllocatedTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice Transfers or withdraws ERC6909 tokens from multiple resource locks to multiple\n     *         recipients with allocator approval.\n     * @param transfer A BatchTransfer struct containing the following:\n     *  -  allocatorData  Authorization signature from the allocator.\n     *  -  nonce          Parameter enforcing replay protection, scoped to the allocator.\n     *  -  expires        Timestamp after which the transfer cannot be executed.\n     *  -  transfers      Array of ComponentsById, each containing:\n     *     -  id          The ERC6909 token identifier of the resource lock.\n     *     -  portions    A Component array, each containing:\n     *        -  claimant The account that will receive tokens.\n     *        -  amount   The amount of tokens the claimant will receive.\n     * @return            Whether the transfer was successful.\n     */\n    function allocatedBatchTransfer(AllocatedBatchTransfer calldata transfer) external returns (bool);\n\n    /**\n     * @notice External function to register a claim hash and its associated EIP-712 typehash.\n     * The registered claim hash will remain valid until the allocator consumes the nonce.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered claim hash.\n     * @return          Whether the claim hash was successfully registered.\n     */\n    function register(bytes32 claimHash, bytes32 typehash) external returns (bool);\n\n    /**\n     * @notice External function to register multiple claim hashes and their associated EIP-712\n     * typehashes in a single call. Each registered claim hash will remain valid until the allocator\n     * consumes the nonce.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                         Whether all claim hashes were successfully registered.\n     */\n    function registerMultiple(bytes32[2][] calldata claimHashesAndTypehashes) external returns (bool);\n\n    /**\n     * @notice Register a claim on behalf of a sponsor with their signature.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param arbiter          The account tasked with verifying and submitting the claim.\n     * @param sponsor          The address of the sponsor for whom the claim is being registered.\n     * @param nonce            A parameter to enforce replay protection, scoped to allocator.\n     * @param expires          The time at which the claim expires.\n     * @param lockTag          The lock tag containing allocator ID, reset period, and scope.\n     * @param token            The address of the token associated with the claim.\n     * @param amount           The amount of tokens associated with the claim.\n     * @param witness          Hash of the witness data.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered compact.\n     */\n    function registerFor(\n        bytes32 typehash,\n        address arbiter,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        bytes12 lockTag,\n        address token,\n        uint256 amount,\n        bytes32 witness,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Register a batch claim on behalf of a sponsor with their signature.\n     * @param typehash          The EIP-712 typehash associated with the registered compact.\n     * @param arbiter           The account tasked with verifying and submitting the claim.\n     * @param sponsor           The address of the sponsor for whom the claim is being registered.\n     * @param nonce             A parameter to enforce replay protection, scoped to allocator.\n     * @param expires           The time at which the claim expires.\n     * @param idsAndAmountsHash Hash of array of [id, amount] pairs per resource lock.\n     * @param witness           Hash of the witness data.\n     * @param sponsorSignature  The signature from the sponsor authorizing the registration.\n     * @return claimHash        The hash of the registered compact.\n     */\n    function registerBatchFor(\n        bytes32 typehash,\n        address arbiter,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 idsAndAmountsHash,\n        bytes32 witness,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Register a multichain claim on behalf of a sponsor with their signature.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param sponsor          The address of the sponsor for whom the claim is being registered.\n     * @param nonce            A parameter to enforce replay protection, scoped to allocator.\n     * @param expires          The time at which the claim expires.\n     * @param elementsHash     Hash of elements (arbiter, chainId, idsAndAmounts, & mandate) per chain.\n     * @param notarizedChainId Chain ID of the domain used to sign the multichain compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered compact.\n     */\n    function registerMultichainFor(\n        bytes32 typehash,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 elementsHash,\n        uint256 notarizedChainId,\n        bytes calldata sponsorSignature\n    ) external returns (bytes32 claimHash);\n\n    /**\n     * @notice External payable function for depositing native tokens into a resource lock\n     * and simultaneously registering a compact. The allocator, the claim hash, and the typehash\n     * used for the claim hash are provided as additional arguments, and the default reset period\n     * (ten minutes) and scope (multichain) will be used for the resource lock. The ERC6909 token\n     * amount received by the caller will match the amount of native tokens sent with the transaction.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositNativeAndRegister(bytes12 lockTag, bytes32 claimHash, bytes32 typehash)\n        external\n        payable\n        returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing native tokens and simultaneously registering a\n     * compact on behalf of someone else. The amount of the claim must be explicitly provided otherwise\n     * a wrong claimhash may be derived.\n     * @param recipient   The recipient of the ERC6909 token.\n     * @param lockTag     The lock tag containing allocator ID, reset period, and scope.\n     * @param arbiter     The account tasked with verifying and submitting the claim.\n     * @param nonce       A parameter to enforce replay protection, scoped to allocator.\n     * @param expires     The time at which the claim expires.\n     * @param typehash    The EIP-712 typehash associated with the registered compact.\n     * @param witness     Hash of the witness data.\n     * @return id         The ERC6909 token identifier of the associated resource lock.\n     * @return claimhash  Hash of the claim. Can be used to verify the expected claim was registered.\n     */\n    function depositNativeAndRegisterFor(\n        address recipient,\n        bytes12 lockTag,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (uint256 id, bytes32 claimhash);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * compact. The default reset period (ten minutes) and scope (multichain) will be used. The\n     * caller must directly approve The Compact to transfer a sufficient amount of the ERC20 token\n     * on its behalf. The ERC6909 token amount received back by the caller is derived from the\n     * difference between the starting and ending balance held in the resource lock, which may differ\n     * from the amount transferred depending on the implementation details of the respective token.\n     * @param token     The address of the ERC20 token to deposit.\n     * @param lockTag   The lock tag containing allocator ID, reset period, and scope.\n     * @param amount    The amount of tokens to deposit.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered compact.\n     * @return id       The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20AndRegister(\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        bytes32 claimHash,\n        bytes32 typehash\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * compact on behalf of someone else. The caller must directly approve The Compact to transfer\n     * a sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount received by\n     * designated recipient the caller is derived from the difference between the starting and ending\n     * balance held in the resource lock, which may differ from the amount transferred depending on\n     * the implementation details of the respective token.\n     * @dev The final ERC6909 token amounts will be substituted into the compact which will be\n     * registered with the returned registeredAmount instead of the provided amount.\n     * Ensure the claim is processed using either the registeredAmount or the ERC6909 transfer event.\n     * This is especially important for fee-on-transfer tokens.\n     * @param recipient         The recipient of the ERC6909 token.\n     * @param token             The address of the ERC20 token to deposit.\n     * @param lockTag           Lock tag containing allocator ID, reset period, & scope.\n     * @param amount            The amount of tokens to deposit.\n     * @param arbiter           The account tasked with verifying and submitting the claim.\n     * @param nonce             A parameter to enforce replay protection, scoped to allocator.\n     * @param expires           The time at which the claim expires.\n     * @param typehash          The EIP-712 typehash associated with the registered compact.\n     * @param witness           Hash of the witness data.\n     * @return id               The ERC6909 token identifier of the associated resource lock.\n     * @return claimhash        Hash for verifying that the expected claim was registered.\n     * @return registeredAmount Final registered amount after potential transfer fees.\n     */\n    function depositERC20AndRegisterFor(\n        address recipient,\n        address token,\n        bytes12 lockTag,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external returns (uint256 id, bytes32 claimhash, uint256 registeredAmount);\n\n    /**\n     * @notice External payable function for depositing multiple tokens in a single transaction\n     * and registering a set of claim hashes. The first entry in idsAndAmounts can optionally\n     * represent native tokens by providing the null address and an amount matching msg.value. For\n     * ERC20 tokens, the caller must directly approve The Compact to transfer sufficient amounts\n     * on its behalf. The ERC6909 token amounts received by the recipient are derived from the\n     * differences between starting and ending balances held in the resource locks, which may\n     * differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. Note that resource lock ids must be supplied in alphanumeric order.\n     * @param idsAndAmounts           Array of [id, amount] pairs with each pair indicating the resource lock and amount to deposit.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                        Whether the batch deposit and claim hash registration was successfully completed.\n     */\n    function batchDepositAndRegisterMultiple(\n        uint256[2][] calldata idsAndAmounts,\n        bytes32[2][] calldata claimHashesAndTypehashes\n    ) external payable returns (bool);\n\n    /**\n     * @notice External function for depositing ERC20 tokens and simultaneously registering a\n     * batch compact on behalf of someone else. The caller must directly approve The Compact\n     * to transfer a sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount\n     * received by designated recipient the caller is derived from the difference between the\n     * starting and ending balance held in the resource lock, which may differ from the amount\n     * transferred depending on the implementation details of the respective token.\n     * @dev The final ERC6909 token amounts will be substituted into the compact which will be\n     * registered with the returned registeredAmounts instead of the provided idsAndAmounts.\n     * Ensure the claim is processed using either the registeredAmounts or the ERC6909 transfer events.\n     * This is especially important for fee-on-transfer tokens.\n     * @param recipient         The recipient of the ERC6909 token.\n     * @param idsAndAmounts     The address of the ERC20 token to deposit.\n     * @param arbiter           The account tasked with verifying and submitting the claim.\n     * @param nonce             A parameter to enforce replay protection, scoped to allocator.\n     * @param expires           The time at which the claim expires.\n     * @param typehash          The EIP-712 typehash associated with the registered compact.\n     * @param witness           Hash of the witness data.\n     * @return claimhash        Hash of the claim. Can be used to verify the expected claim was registered.\n     * @return registeredAmounts Array containing the final minted amount of each id.\n     */\n    function batchDepositAndRegisterFor(\n        address recipient,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) external payable returns (bytes32 claimhash, uint256[] memory registeredAmounts);\n\n    /**\n     * @notice External function for depositing ERC20 tokens using Permit2 authorization and\n     * registering a compact. The depositor must approve Permit2 to transfer the tokens on its\n     * behalf unless the token in question automatically grants approval to Permit2. The ERC6909\n     * token amount received by the depositor is derived from the difference between the starting\n     * and ending balance held in the resource lock, which may differ from the amount transferred\n     * depending on the implementation details of the respective token. The Permit2 authorization\n     * signed by the depositor must contain an Activation witness containing the id of the resource\n     * lock and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param permit          The permit data signed by the depositor.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param lockTag         The lock tag containing allocator ID, reset period, and scope.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposit.\n     * @return id             The ERC6909 token identifier of the associated resource lock.\n     */\n    function depositERC20AndRegisterViaPermit2(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address depositor,\n        bytes12 lockTag,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) external returns (uint256 id);\n\n    /**\n     * @notice External payable function for depositing multiple tokens using Permit2\n     * authorization and registering a compact in a single transaction. The first token id can\n     * optionally represent native tokens by providing the null address and an amount matching\n     * msg.value. The depositor must approve Permit2 to transfer the tokens on its behalf unless\n     * the tokens automatically grant approval to Permit2. The ERC6909 token amounts received by\n     * the depositor are derived from the differences between starting and ending balances held\n     * in the resource locks, which may differ from the amounts transferred depending on the\n     * implementation details of the respective tokens. The Permit2 authorization signed by the\n     * depositor must contain a BatchActivation witness containing the ids of the resource locks\n     * and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted       Array of token permissions specifying the deposited tokens and amounts.\n     * @param details         The details of the deposit.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param compactCategory The category of the compact being registered (Compact, BatchCompact, or MultichainCompact).\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function batchDepositAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        DepositDetails calldata details,\n        bytes32 claimHash,\n        CompactCategory compactCategory,\n        string calldata witness,\n        bytes calldata signature\n    ) external payable returns (uint256[] memory ids);\n\n    /**\n     * @notice External function to initiate a forced withdrawal for a resource lock. Once\n     * enabled, forced withdrawals can be executed after the reset period has elapsed. The\n     * withdrawableAt timestamp returned will be the current timestamp plus the reset period\n     * associated with the resource lock.\n     * @param id              The ERC6909 token identifier for the resource lock.\n     * @return withdrawableAt The timestamp at which tokens become withdrawable.\n     */\n    function enableForcedWithdrawal(uint256 id) external returns (uint256 withdrawableAt);\n\n    /**\n     * @notice External function to disable a previously enabled forced withdrawal for a\n     * resource lock.\n     * @param id The ERC6909 token identifier for the resource lock.\n     * @return   Whether the forced withdrawal was successfully disabled.\n     */\n    function disableForcedWithdrawal(uint256 id) external returns (bool);\n\n    /**\n     * @notice External function to execute a forced withdrawal from a resource lock after the\n     * reset period has elapsed. The tokens will be withdrawn to the specified recipient in the\n     * amount requested. The ERC6909 token balance of the caller will be reduced by the\n     * difference in the balance held by the resource lock before and after the withdrawal,\n     * which may differ from the provided amount depending on the underlying token in question.\n     * @param id        The ERC6909 token identifier for the resource lock.\n     * @param recipient The account that will receive the withdrawn tokens.\n     * @param amount    The amount of tokens to withdraw.\n     * @return          Whether the forced withdrawal was successfully executed.\n     */\n    function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Assigns an emissary for the caller that has authority to authorize claims where that\n     * caller is the sponsor. The emissary will utilize a reset period dictated by the reset period\n     * on the provided lock tag that blocks reassignment of the emissary for the duration of that\n     * reset period. The reset period ensures that once an emissary is assigned, another assignment\n     * cannot be made until the reset period has elapsed.\n     * @param lockTag The lockTag the emissary will be assigned for.\n     * @return Whether the assignment was successful.\n     */\n    function assignEmissary(bytes12 lockTag, address emissary) external returns (bool);\n\n    /**\n     * @notice Schedules a future emissary assignment for a specific lock tag. The reset period on\n     * the lock tag determines how long reassignment will be blocked after this assignment. This\n     * allows for a delay before the next assignment can be made. Note that the reset period of the\n     * current emissary (if set) will dictate when the next assignment will be allowed.\n     * @param lockTag The lockTag the emissary assignment is scheduled for.\n     * @return emissaryAssignmentAvailableAt The timestamp when the next assignment will be allowed.\n     */\n    function scheduleEmissaryAssignment(bytes12 lockTag) external returns (uint256 emissaryAssignmentAvailableAt);\n\n    /**\n     * @notice External function for consuming allocator nonces. Only callable by a registered\n     * allocator. Once consumed, any compact payloads that utilize those nonces cannot be claimed.\n     * @param nonces Array of nonces to be consumed.\n     * @return       Whether all nonces were successfully consumed.\n     */\n    function consume(uint256[] calldata nonces) external returns (bool);\n\n    /**\n     * @notice External function for registering an allocator. Can be called by anyone if one\n     * of three conditions is met: the caller is the allocator address being registered, the\n     * allocator address contains code, or a proof is supplied representing valid create2\n     * deployment parameters that resolve to the supplied allocator address.\n     * @param allocator    The address to register as an allocator.\n     * @param proof        An 85-byte value containing create2 address derivation parameters (0xff ++ factory ++ salt ++ initcode hash).\n     * @return allocatorId A unique identifier assigned to the registered allocator.\n     */\n    function __registerAllocator(address allocator, bytes calldata proof) external returns (uint96 allocatorId);\n\n    /**\n     * @notice External function to benchmark withdrawal costs to determine the required stipend\n     * on the fallback for failing withdrawals when processing claims. The salt is used to derive\n     * a cold account to benchmark the native token withdrawal.\n     * @param salt A bytes32 value used to derive a cold account for benchmarking.\n     * @dev Must provide exactly 2 wei when calling this function.\n     */\n    function __benchmark(bytes32 salt) external payable;\n\n    /**\n     * @notice External view function for retrieving the details of a resource lock. Returns the\n     * underlying token, the mediating allocator, the reset period, and the scope.\n     * @param id           The ERC6909 token identifier of the resource lock.\n     * @return token       The address of the underlying token (or address(0) for native tokens).\n     * @return allocator   The account of the allocator mediating the resource lock.\n     * @return resetPeriod The duration after which the resource lock can be reset once a forced withdrawal is initiated.\n     * @return scope       The scope of the resource lock (multichain or single chain).\n     * @return lockTag     The lock tag containing the allocator ID, the reset period, and the scope.\n     */\n    function getLockDetails(uint256 id)\n        external\n        view\n        returns (address token, address allocator, ResetPeriod resetPeriod, Scope scope, bytes12 lockTag);\n\n    /**\n     * @notice External view function for checking the registration status of a compact. Returns\n     * both whether the claim hash is currently active and when it was registered (if relevant).\n     * Note that an \"active\" compact may in fact not be claimable, (e.g. it has expired, the\n     * nonce has been consumed, etc).\n     * @param sponsor   The account that registered the compact.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the registered claim hash.\n     * @return isActive Whether the compact registration is currently active.\n     */\n    function isRegistered(address sponsor, bytes32 claimHash, bytes32 typehash) external view returns (bool isActive);\n\n    /**\n     * @notice External view function for checking the forced withdrawal status of a resource\n     * lock for a given account. Returns both the current status (disabled, pending, or enabled)\n     * and the timestamp at which forced withdrawals will be enabled (if status is pending) or\n     * became enabled (if status is enabled).\n     * @param account                      The account to get the forced withdrawal status for.\n     * @param id                           The ERC6909 token identifier of the resource lock.\n     * @return status                      The current ForcedWithdrawalStatus (disabled, pending, or enabled).\n     * @return forcedWithdrawalAvailableAt The timestamp at which tokens become withdrawable if status is pending.\n     */\n    function getForcedWithdrawalStatus(address account, uint256 id)\n        external\n        view\n        returns (ForcedWithdrawalStatus status, uint256 forcedWithdrawalAvailableAt);\n\n    /**\n     * @notice Gets the current emissary status for an allocator. Returns the current status,\n     * the timestamp when reassignment will be allowed again (based on reset period), and\n     * the currently assigned emissary (if any).\n     * @param sponsor The address of the sponsor to check.\n     * @param lockTag The lockTag to check.\n     * @return status The current emissary assignment status.\n     * @return emissaryAssignmentAvailableAt The timestamp when reassignment will be allowed.\n     * @return currentEmissary The currently assigned emissary address (or zero address if none).\n     */\n    function getEmissaryStatus(address sponsor, bytes12 lockTag)\n        external\n        view\n        returns (EmissaryStatus status, uint256 emissaryAssignmentAvailableAt, address currentEmissary);\n\n    /**\n     * @notice External view function for checking whether a specific nonce has been consumed by\n     * an allocator. Once consumed, a nonce cannot be reused for claims mediated by that allocator.\n     * @param nonce     The nonce to check.\n     * @param allocator The account of the allocator.\n     * @return consumed Whether the nonce has been consumed.\n     */\n    function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool consumed);\n\n    /**\n     * @notice External view function for getting required stipends for releasing tokens as a\n     * fallback on claims where withdrawals do not succeed. Any requested withdrawal is first\n     * attempted using half of available gas. If it fails, then a direct 6909 transfer will be\n     * performed as long as the remaining gas left exceeds the benchmarked stipend.\n     * @return nativeTokenStipend The gas stipend required for native token withdrawals.\n     * @return erc20TokenStipend  The gas stipend required for ERC20 token withdrawals.\n     */\n    function getRequiredWithdrawalFallbackStipends()\n        external\n        view\n        returns (uint256 nativeTokenStipend, uint256 erc20TokenStipend);\n\n    /**\n     * @notice External pure function for returning the domain separator of the contract.\n     * @return domainSeparator A bytes32 representing the domain separator for the contract.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice External pure function for returning the name of the contract.\n     * @return A string representing the name of the contract.\n     */\n    function name() external pure returns (string memory);\n\n    error InvalidToken(address token);\n    error Expired(uint256 expiration);\n    error InvalidSignature();\n    error PrematureWithdrawal(uint256 id);\n    error ForcedWithdrawalFailed();\n    error ForcedWithdrawalAlreadyDisabled(address account, uint256 id);\n    error UnallocatedTransfer(address operator, address from, address to, uint256 id, uint256 amount);\n    error InvalidBatchAllocation();\n    error InvalidRegistrationProof(address allocator);\n    error InvalidBatchDepositStructure();\n    error AllocatedAmountExceeded(uint256 allocatedAmount, uint256 providedAmount);\n    error InvalidScope(uint256 id);\n    error InvalidDepositTokenOrdering();\n    error InvalidDepositBalanceChange();\n    error Permit2CallFailed();\n    error ReentrantCall(address existingCaller);\n    error InconsistentAllocators();\n    error InvalidAllocation(address allocator);\n    error ChainIndexOutOfRange();\n    error InvalidEmissaryAssignment();\n    error EmissaryAssignmentUnavailable(uint256 assignableAt);\n    error InvalidLockTag();\n}\n"},"lib/the-compact/src/types/Claims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Component } from \"./Components.sol\";\n\nstruct AllocatedTransfer {\n    bytes allocatorData; // Authorization from the allocator.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the transfer or withdrawal expires.\n    uint256 id; // The token ID of the ERC6909 token to transfer or withdraw.\n    Component[] recipients; // The recipients and amounts of each transfer.\n}\n\nstruct Claim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    Component[] claimants; // The claim recipients and amounts; specified by the arbiter.\n}\n"},"lib/the-compact/src/types/ForcedWithdrawalStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nenum ForcedWithdrawalStatus {\n    Disabled, // Not pending or enabled for forced withdrawal\n    Pending, // Not yet available, but initiated\n    Enabled // Available for forced withdrawal on demand\n\n}\n"},"lib/the-compact/src/types/EmissaryStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"./ResetPeriod.sol\";\n\nenum EmissaryStatus {\n    Disabled, // Not pending or enabled for forced withdrawal\n    Scheduled, // Available but scheduled\n    Enabled // Available for forced withdrawal on demand\n\n}\n\nstruct EmissaryConfig {\n    // 20 bytes\n    address emissary; // address of the sponsor's emissary\n    // 12 bytes\n    uint96 assignableAt; // timestamp after which an emissary can be re-assigned\n}\n"},"lib/the-compact/src/types/DepositDetails.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nstruct DepositDetails {\n    uint256 nonce;\n    uint256 deadline;\n    bytes12 lockTag;\n}\n"},"lib/solady/src/tokens/ERC6909.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple EIP-6909 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC6909.sol)\n///\n/// @dev Note:\n/// The ERC6909 standard allows minting and transferring to and from the zero address,\n/// minting and transferring zero tokens, as well as self-approvals.\n/// For performance, this implementation WILL NOT revert for such actions.\n/// Please add any checks with overrides if desired.\n///\n/// If you are overriding:\n/// - Make sure all variables written to storage are properly cleaned\n//    (e.g. the bool value for `isOperator` MUST be either 1 or 0 under the hood).\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC6909 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient permission to perform the action.\n    error InsufficientPermission();\n\n    /// @dev The balance has overflowed.\n    error BalanceOverflow();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Emitted when `by` transfers `amount` of token `id` from `from` to `to`.\n    event Transfer(\n        address by, address indexed from, address indexed to, uint256 indexed id, uint256 amount\n    );\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    /// @dev Emitted when `owner` approves `spender` to use `amount` of `id` token.\n    event Approval(\n        address indexed owner, address indexed spender, uint256 indexed id, uint256 amount\n    );\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,address,uint256,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859;\n\n    /// @dev `keccak256(bytes(\"OperatorSet(address,address,bool)\"))`.\n    uint256 private constant _OPERATOR_SET_EVENT_SIGNATURE =\n        0xceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0xb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a7;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The `ownerSlotSeed` of a given owner is given by.\n    /// ```\n    ///     let ownerSlotSeed := or(_ERC6909_MASTER_SLOT_SEED, shl(96, owner))\n    /// ```\n    ///\n    /// The balance slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, id)\n    ///     let balanceSlot := keccak256(0x00, 0x40)\n    /// ```\n    ///\n    /// The operator approval slot of `owner` is given by.\n    /// ```\n    ///     mstore(0x20, ownerSlotSeed)\n    ///     mstore(0x00, operator)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)\n    /// ```\n    ///\n    /// The allowance slot of (`owner`, `spender`, `id`) is given by:\n    /// ```\n    ///     mstore(0x34, ownerSlotSeed)\n    ///     mstore(0x14, spender)\n    ///     mstore(0x00, id)\n    ///     let allowanceSlot := keccak256(0x00, 0x54)\n    /// ```\n    uint256 private constant _ERC6909_MASTER_SLOT_SEED = 0xedcaa89a82293940;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ERC6909 METADATA                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the name for token `id`.\n    function name(uint256 id) public view virtual returns (string memory);\n\n    /// @dev Returns the symbol for token `id`.\n    function symbol(uint256 id) public view virtual returns (string memory);\n\n    /// @dev Returns the number of decimals for token `id`.\n    /// Returns 18 by default.\n    /// Please override this function if you need to return a custom value.\n    function decimals(uint256 id) public view virtual returns (uint8) {\n        id = id; // Silence compiler warning.\n        return 18;\n    }\n\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          ERC6909                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the amount of token `id` owned by `owner`.\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x40))\n        }\n    }\n\n    /// @dev Returns the amount of token `id` that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender, uint256 id)\n        public\n        view\n        virtual\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x54))\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }\n\n    /// @dev Checks if a `spender` is approved by `owner` to manage all of their tokens.\n    function isOperator(address owner, address spender) public view virtual returns (bool status) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, spender)\n            status := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Transfers `amount` of token `id` from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - caller must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(msg.sender, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            /// Compute the balance slot and load its value.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(msg.sender, to, id, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` of token `id` from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount` of token `id`.\n    /// -  The caller must have at least `amount` of allowance to transfer the\n    ///    tokens of `from` or approved as an operator.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            mstore(0x14, caller())\n            // Check if the caller is an operator.\n            if iszero(sload(keccak256(0x20, 0x34))) {\n                // Compute the allowance slot and load its value.\n                mstore(0x00, id)\n                let allowanceSlot := keccak256(0x00, 0x54)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if add(allowance_, 1) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n        return true;\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` for the caller for token `id`.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, caller())\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        return true;\n    }\n\n    ///  @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits {OperatorSet} event.\n    function setOperator(address operator, bool approved) public payable virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        return true;\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6909: 0x0f632fb3.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x0f632fb3))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Mints `amount` of token `id` to `to`.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            // Add and store the updated balance\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(address(0), to, id, amount);\n    }\n\n    /// @dev Burns `amount` token `id` from `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0, id)\n        }\n        _afterTokenTransfer(from, address(0), id, amount);\n    }\n\n    /// @dev Transfers `amount` of token `id` from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount` of token `id`.\n    /// - If `by` is not the zero address,\n    ///   it must have at least `amount` of allowance to transfer the\n    ///   tokens of `from` or approved as an operator.\n    ///\n    /// Emits a {Transfer} event.\n    function _transfer(address by, address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let bitmaskAddress := 0xffffffffffffffffffffffffffffffffffffffff\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            // If `by` is not the zero address.\n            if and(bitmaskAddress, by) {\n                mstore(0x14, by)\n                // Check if the `by` is an operator.\n                if iszero(sload(keccak256(0x20, 0x34))) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x00, id)\n                    let allowanceSlot := keccak256(0x00, 0x54)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if add(allowance_, 1) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, and(bitmaskAddress, by))\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, and(bitmaskAddress, from), and(bitmaskAddress, to), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` for `owner` for token `id`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x34)), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }\n\n    ///  @dev Sets whether `operator` is approved to manage the tokens of `owner`.\n    ///\n    /// Emits {OperatorSet} event.\n    function _setOperator(address owner, address operator, bool approved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            // forgefmt: disable-next-line\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, shr(96, shl(96, owner)), shr(96, mload(0x0c)))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {}\n}\n"},"lib/permit2/src/interfaces/ISignatureTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"},"lib/the-compact/src/lib/TheCompactLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatorLogic } from \"./AllocatorLogic.sol\";\nimport { ClaimProcessor } from \"./ClaimProcessor.sol\";\nimport { DepositViaPermit2Logic } from \"./DepositViaPermit2Logic.sol\";\nimport { DirectDepositLogic } from \"./DirectDepositLogic.sol\";\nimport { Extsload } from \"./Extsload.sol\";\nimport { RegistrationLogic } from \"./RegistrationLogic.sol\";\nimport { TransferLogic } from \"./TransferLogic.sol\";\nimport { WithdrawalLogic } from \"./WithdrawalLogic.sol\";\nimport { EmissaryLogic } from \"./EmissaryLogic.sol\";\n\n/**\n * @title TheCompactLogic\n * @notice Inherited contract that aggregates a number of other inherited contracts.\n */\ncontract TheCompactLogic is\n    AllocatorLogic,\n    ClaimProcessor,\n    DepositViaPermit2Logic,\n    DirectDepositLogic,\n    Extsload,\n    RegistrationLogic,\n    TransferLogic,\n    WithdrawalLogic,\n    EmissaryLogic\n{ }\n"},"lib/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"lib/solady/src/utils/SignatureCheckerLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch mload(signature)\n                    case 64 {\n                        let vs := mload(add(signature, 0x40))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                        mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n                isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n                isValid := and(eq(mload(d), f), and(isValid, copied))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch signature.length\n                    case 64 {\n                        let vs := calldataload(add(signature.offset, 0x20))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x40, calldataload(signature.offset)) // `r`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                        calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n                mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, and(v, 0xff)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, s) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Note: These ERC1271 operations do NOT have an ECDSA fallback.\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n            isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n            isValid := and(eq(mload(d), f), and(isValid, copied))\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     ERC6492 OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Note: These ERC6492 operations now include an ECDSA fallback at the very end.\n    // The calldata variants are excluded for brevity.\n\n    /// @dev Returns whether `signature` is valid for `hash`.\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt to\n    /// deploy / prepare the `signer` smart account before doing a regular ERC1271 check.\n    /// Note: This function is NOT reentrancy safe.\n    /// The verifier must be deployed.\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\n    /// See: https://gist.github.com/Vectorized/011d6becff6e0a73e42fe100f8d7ef04\n    /// With a dedicated verifier, this function is safe to use in contracts\n    /// that have been granted special permissions.\n    function isValidERC6492SignatureNowAllowSideEffects(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                pop(\n                    call(\n                        gas(), // Remaining gas.\n                        0x0000bc370E4DC924F427d84e2f4B9Ec81626ba7E, // Non-reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                )\n                isValid := returndatasize()\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash`.\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt\n    /// to use a reverting verifier to deploy / prepare the `signer` smart account\n    /// and do a `isValidSignature` check via the reverting verifier.\n    /// Note: This function is reentrancy safe.\n    /// The reverting verifier must be deployed.\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\n    /// See: https://gist.github.com/Vectorized/846a474c855eee9e441506676800a9ad\n    function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                let willBeZeroIfRevertingVerifierExists :=\n                    call(\n                        gas(), // Remaining gas.\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"lib/OIF/src/input/types/AllowOpenType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n/// @notice Signed struct\nstruct AllowOpen {\n    bytes32 orderId;\n    bytes32 destination;\n    bytes call;\n}\n\n/**\n * @notice Helper library for the Allow Open type.\n * TYPE_PARTIAL: An incomplete type. Is missing a field.\n * TYPE_STUB: Type has no subtypes.\n * TYPE: Is complete including sub-types.\n */\nlibrary AllowOpenType {\n    bytes constant ALLOW_OPEN_TYPE_STUB = bytes(\"AllowOpen(bytes32 orderId,bytes32 destination,bytes call)\");\n\n    bytes32 constant ALLOW_OPEN_TYPE_HASH = keccak256(ALLOW_OPEN_TYPE_STUB);\n\n    /**\n     * @notice Hashes an AllowOpen struct.\n     * @param orderId The unique identifier for the order.\n     * @param destination New destination for the order.\n     * @param call If set (!= \"0x\"), will execute an external orderFinalised call.\n     * @return digest of hashAllowOpen.\n     */\n    function hashAllowOpen(bytes32 orderId, bytes32 destination, bytes calldata call) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ALLOW_OPEN_TYPE_HASH, orderId, destination, keccak256(call)));\n    }\n}\n"},"lib/permit2/src/interfaces/IEIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"lib/the-compact/src/lib/AllocatorLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\nimport { ConsumerLib } from \"./ConsumerLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\n\nimport { ITheCompact } from \"../interfaces/ITheCompact.sol\";\n\n/**\n * @title AllocatorLogic\n * @notice Inherited contract implementing internal functions with logic for registering\n * new allocators, allowing registered allocators to directly consume nonces within their\n * scope, and querying for information on nonce consumption and lock details.\n */\ncontract AllocatorLogic {\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using ConsumerLib for uint256;\n    using EfficiencyLib for uint256;\n    using ValidityLib for address;\n\n    /**\n     * @notice Internal function for marking allocator nonces as consumed. Once consumed, a nonce\n     * cannot be reused to claim resource locks referencing that allocator. Called by the external\n     * consume function and during claim processing to prevent replay attacks.\n     * @param nonces Array of nonces to mark as consumed for the calling allocator.\n     * @return       Whether all nonces were successfully marked as consumed.\n     */\n    function _consume(uint256[] calldata nonces) internal returns (bool) {\n        // Ensure that the caller is a registered allocator.\n        msg.sender.toAllocatorId().mustHaveARegisteredAllocator();\n\n        unchecked {\n            // Declare an pointer starting at the data offset of the nonces array.\n            uint256 i;\n            assembly (\"memory-safe\") {\n                i := nonces.offset\n            }\n\n            // Determine the terminal pointer.\n            uint256 end = i + (nonces.length << 5);\n            uint256 nonce;\n\n            // Iterate over each pointer in the array.\n            for (; i < end; i += 0x20) {\n                assembly (\"memory-safe\") {\n                    // Retrieve the respective nonce from calldata.\n                    nonce := calldataload(i)\n                }\n\n                // Consume the nonce in the scope of the caller.\n                nonce.consumeNonceAsAllocator(msg.sender);\n\n                // Emit a NonceConsumedDirectly event.\n                emit ITheCompact.NonceConsumedDirectly(msg.sender, nonce);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function for registering an allocator. Validates that one of three\n     * conditions is met: caller is the allocator address, allocator address contains code, or\n     * proof represents valid create2 deployment parameters that derive the allocator address.\n     * @param allocator    The address to register as an allocator.\n     * @param proof        An 85-byte value containing create2 address derivation parameters.\n     * @return allocatorId A unique identifier assigned to the registered allocator.\n     */\n    function _registerAllocator(address allocator, bytes calldata proof) internal returns (uint96 allocatorId) {\n        // Santitize the allocator address out of an abundance of caution.\n        allocator = uint256(uint160(allocator)).asSanitizedAddress();\n\n        // Ensure that the allocator in question can be registered.\n        if (!allocator.canBeRegistered(proof)) {\n            assembly (\"memory-safe\") {\n                // revert InvalidRegistrationProof(allocator)\n                mstore(0, 0x4e7f492b)\n                mstore(0x20, allocator)\n                revert(0x1c, 0x24)\n            }\n        }\n\n        // Register the allocator.\n        allocatorId = allocator.register();\n    }\n\n    /**\n     * @notice Internal view function for checking whether a specific nonce has been consumed by\n     * an allocator.\n     * @param nonce     The nonce to check.\n     * @param allocator The address of the allocator.\n     * @return          Whether the nonce has been consumed.\n     */\n    function _hasConsumedAllocatorNonce(uint256 nonce, address allocator) internal view returns (bool) {\n        return allocator.hasConsumedAllocatorNonce(nonce);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the details of a resource lock.\n     * @param id           The ERC6909 token identifier for the resource lock.\n     * @return token       The address of the underlying token (or address(0) for native tokens).\n     * @return allocator   The address of the allocator mediating the resource lock.\n     * @return resetPeriod The duration after which the underlying tokens can be withdrawn once a forced withdrawal is initiated.\n     * @return scope       The scope of the resource lock (multichain or single chain).\n     * @return lockTag     The lock tag containing the allocator ID, the reset period, and the scope.\n     */\n    function _getLockDetails(uint256 id)\n        internal\n        view\n        returns (address token, address allocator, ResetPeriod resetPeriod, Scope scope, bytes12 lockTag)\n    {\n        token = id.toAddress();\n        allocator = id.toAllocatorId().toRegisteredAllocator();\n        resetPeriod = id.toResetPeriod();\n        scope = id.toScope();\n        lockTag = id.toLockTag();\n    }\n}\n"},"lib/the-compact/src/lib/ClaimProcessor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ITheCompactClaims } from \"../interfaces/ITheCompactClaims.sol\";\nimport { ClaimProcessorLogic } from \"./ClaimProcessorLogic.sol\";\n\nimport { Claim } from \"../types/Claims.sol\";\n\nimport { BatchClaim } from \"../types/BatchClaims.sol\";\n\nimport { MultichainClaim, ExogenousMultichainClaim } from \"../types/MultichainClaims.sol\";\n\nimport { BatchMultichainClaim, ExogenousBatchMultichainClaim } from \"../types/BatchMultichainClaims.sol\";\n\n/**\n * @title ClaimProcessor\n * @notice Inherited contract implementing external functions for processing claims against\n * a signed or registered compact. Each of these functions is only callable by the arbiter\n * indicated by the respective compact.\n */\ncontract ClaimProcessor is ITheCompactClaims, ClaimProcessorLogic {\n    /**\n     * @notice Process a basic claim with a single resource lock on a single chain.\n     * @param claimPayload The claim data containing signature, allocator data, and compact details.\n     * @return claimHash   The hash of the processed claim.\n     */\n    function claim(Claim calldata claimPayload) external returns (bytes32 claimHash) {\n        return _processClaim(claimPayload);\n    }\n\n    /**\n     * @notice Process a batch claim for multiple resource locks on a single chain.\n     * @param claimPayload The batch claim data containing signature, allocator data, and compact details.\n     * @return claimHash   The hash of the processed batch claim.\n     */\n    function batchClaim(BatchClaim calldata claimPayload) external returns (bytes32 claimHash) {\n        return _processBatchClaim(claimPayload);\n    }\n\n    /**\n     * @notice Process a multichain claim for an element with a single resource lock on the notarized chain (where domain matches the one signed for).\n     * @param claimPayload The multichain claim data containing signature, allocator data, compact details, and relevant chain elements.\n     * @return claimHash   The hash of the processed multichain claim.\n     */\n    function multichainClaim(MultichainClaim calldata claimPayload) external returns (bytes32 claimHash) {\n        return _processMultichainClaim(claimPayload);\n    }\n\n    /**\n     * @notice Process a multichain claim for an element with a single resource lock on an exogenous chain (not the notarized chain).\n     * @param claimPayload The exogenous multichain claim data containing signature, allocator data, compact details, chain index, and notarized chain ID, and relevant chain elements.\n     * @return claimHash   The hash of the processed exogenous multichain claim.\n     */\n    function exogenousClaim(ExogenousMultichainClaim calldata claimPayload) external returns (bytes32 claimHash) {\n        return _processExogenousMultichainClaim(claimPayload);\n    }\n\n    /**\n     * @notice Process a multichain claim for an element with multiple resource locks on the notarized chain (where domain matches the one signed for).\n     * @param claimPayload The multichain claim data containing signature, allocator data, compact details, and relevant chain elements.\n     * @return claimHash   The hash of the processed multichain claim.\n     */\n    function batchMultichainClaim(BatchMultichainClaim calldata claimPayload) external returns (bytes32 claimHash) {\n        return _processBatchMultichainClaim(claimPayload);\n    }\n\n    /**\n     * @notice Process a multichain claim for an element with multiple resource locks on an exogenous chain (not the notarized chain).\n     * @param claimPayload The exogenous multichain claim data containing signature, allocator data, compact details, chain index, and notarized chain ID, and relevant chain elements.\n     * @return claimHash   The hash of the processed exogenous multichain claim.\n     */\n    function exogenousBatchClaim(ExogenousBatchMultichainClaim calldata claimPayload)\n        external\n        returns (bytes32 claimHash)\n    {\n        return _processExogenousBatchMultichainClaim(claimPayload);\n    }\n}\n"},"lib/the-compact/src/lib/DepositViaPermit2Logic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\nimport { DepositLogic } from \"./DepositLogic.sol\";\nimport { DepositViaPermit2Lib } from \"./DepositViaPermit2Lib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { TransferLib } from \"./TransferLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\n/**\n * @title DepositViaPermit2Logic\n * @notice Inherited contract implementing internal functions with logic for processing\n * token deposits via permit2. These deposits leverage Permit2 witness data to either\n * indicate the parameters of the lock to deposit into and the recipient of the deposit,\n * or the parameters of the compact to register alongside the deposit. Deposits can also\n * involve a single ERC20 token or a batch of tokens in a single Permit2 authorization.\n * @dev IMPORTANT NOTE: this logic operates directly on unallocated memory, and reads\n * directly from fixed calldata offsets; proceed with EXTREME caution when making any\n * modifications to either this logic contract (including the insertion of new logic) or\n * to the associated permit2 deposit function interfaces!\n */\ncontract DepositViaPermit2Logic is DepositLogic {\n    using TransferLib for address;\n    using DepositViaPermit2Lib for bytes32;\n    using DepositViaPermit2Lib for uint256;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using IdLib for ResetPeriod;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using RegistrationLib for address;\n    using ValidityLib for address;\n    using SafeTransferLib for address;\n\n    // Selector for the single token `permit2.permitWitnessTransferFrom` function.\n    uint32 private constant _PERMIT_WITNESS_TRANSFER_FROM_SELECTOR = 0x137c29fe;\n\n    // Address of the Permit2 contract (with 5 leading zeroes stripped).\n    uint120 private constant _PERMIT2 = 0x22D473030F116dDEE9F6B43aC78BA3;\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens using Permit2 authorization. The\n     * depositor must approve Permit2 to transfer the tokens on its behalf unless the token in\n     * question automatically grants approval to Permit2. The ERC6909 token amount received by the\n     * by the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token. The Permit2 authorization signed by the\n     * depositor must contain a CompactDeposit witness containing the allocator, the reset period,\n     * the scope, and the intended recipient of the deposit.\n     * @param token       The address of the ERC20 token to deposit.\n     * @param recipient   The address that will receive the corresponding the ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposit.\n     * @return            The ERC6909 token identifier of the associated resource lock.\n     */\n    function _depositViaPermit2(address token, address recipient, bytes calldata signature)\n        internal\n        returns (uint256)\n    {\n        // Derive the CompactDeposit witness hash.\n        bytes32 witness = uint256(0xa4).asStubborn().deriveCompactDepositWitnessHash();\n\n        // Set reentrancy lock, get initial balance, and begin preparing Permit2 call data.\n        (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation) =\n            _setReentrancyLockAndStartPreparingPermit2Call(token);\n\n        // Insert the CompactDeposit typestring fragment.\n        typestringMemoryLocation.insertCompactDepositTypestring();\n\n        // Store the CompactDeposit witness hash.\n        assembly (\"memory-safe\") {\n            mstore(add(m, 0x100), witness)\n        }\n\n        // Write the signature and perform the Permit2 call.\n        //\n        _writeSignatureAndPerformPermit2Call(m, uint256(0x140).asStubborn(), uint256(0x1e0).asStubborn(), signature);\n\n        // Deposit tokens based on the balance change from the Permit2 call.\n        _checkBalanceAndDeposit(token, recipient, id, initialBalance);\n\n        // Clear reentrancy lock.\n        _clearReentrancyGuard();\n\n        // Return the ERC6909 token identifier of the associated resource lock.\n        return id;\n    }\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens using Permit2 authorization and\n     * registering a compact. The depositor must approve Permit2 to transfer the tokens on its\n     * behalf unless the token in question automatically grants approval to Permit2. The ERC6909\n     * token amount received by the depositor is derived from the difference between the starting\n     * and ending balance held in the resource lock, which may differ from the amount transferred\n     * depending on the implementation details of the respective token. The Permit2 authorization\n     * signed by the depositor must contain an Activation witness containing the id of the resource\n     * lock and an associated Compact, BatchCompact, or MultichainCompact payload matching the\n     * specified compact category.\n     * @param token           The address of the ERC20 token to deposit.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param claimHash       A bytes32 hash derived from the details of the compact.\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposit.\n     * @return                The ERC6909 token identifier of the associated resource lock.\n     */\n    function _depositAndRegisterViaPermit2(\n        address token,\n        address depositor, // also recipient\n        bytes32 claimHash,\n        string calldata witness,\n        bytes calldata signature\n    ) internal returns (uint256) {\n        uint256 id;\n        uint256 initialBalance;\n        bytes32 compactTypehash;\n        {\n            uint256 m;\n            {\n                uint256 typestringMemoryLocation;\n\n                // Set reentrancy lock, get initial balance, and begin preparing Permit2 call data.\n                (id, initialBalance, m, typestringMemoryLocation) =\n                    _setReentrancyLockAndStartPreparingPermit2Call(token);\n\n                CompactCategory compactCategory;\n                bytes32 activationTypehash;\n                assembly (\"memory-safe\") {\n                    compactCategory := calldataload(0xe4)\n                }\n\n                // Continue preparing Permit2 call data and get activation and compact typehashes.\n                (activationTypehash, compactTypehash) = typestringMemoryLocation.writeWitnessAndGetTypehashes(\n                    compactCategory, witness, bool(false).asStubborn()\n                );\n\n                // Derive the activation witness hash and store it.\n                activationTypehash.deriveAndWriteWitnessHash(id, claimHash, m, 0x100);\n            }\n\n            // Derive signature offset value.\n            uint256 signatureOffsetValue;\n            assembly (\"memory-safe\") {\n                signatureOffsetValue := and(add(mload(add(m, 0x160)), 0x17f), not(0x1f))\n            }\n\n            // Write the signature and perform the Permit2 call.\n            _writeSignatureAndPerformPermit2Call(m, uint256(0x140).asStubborn(), signatureOffsetValue, signature);\n        }\n\n        // Deposit tokens based on the balance change from the Permit2 call.\n        _checkBalanceAndDeposit(token, depositor, id, initialBalance);\n\n        // Register the compact.\n        depositor.registerCompact(claimHash, compactTypehash);\n\n        // Clear reentrancy lock.\n        _clearReentrancyGuard();\n\n        // Return the ERC6909 token identifier of the associated resource lock.\n        return id;\n    }\n\n    /**\n     * @notice Internal function for depositing multiple tokens using Permit2 authorization in a\n     * single transaction. The first token id can optionally represent native tokens by providing\n     * the null address and an amount matching msg.value. The depositor must approve Permit2 to\n     * transfer the tokens on its behalf unless the tokens automatically grant approval to\n     * Permit2. The ERC6909 token amounts received by the recipient are derived from the\n     * differences between starting and ending balances held in the resource locks, which may\n     * differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * CompactDeposit witness containing the allocator, the reset period, the scope, and the\n     * intended recipient of the deposits.\n     * @param permitted   Array of token permissions specifying the deposited tokens and amounts.\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @param signature   The Permit2 signature from the depositor authorizing the deposits.\n     * @return            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function _depositBatchViaPermit2(\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        address recipient,\n        bytes calldata signature\n    ) internal returns (uint256[] memory) {\n        // Set reentrancy guard, perform initial native deposit if present, and get initial token balances.\n        (\n            uint256 totalTokensLessInitialNative,\n            bool firstUnderlyingTokenIsNative,\n            uint256[] memory ids,\n            uint256[] memory initialTokenBalances\n        ) = _preprocessAndPerformInitialNativeDeposit(permitted, recipient);\n\n        {\n            // Derive the CompactDeposit witness hash.\n            bytes32 witness = uint256(0x84).asStubborn().deriveCompactDepositWitnessHash();\n\n            // Begin preparing Permit2 call data.\n            (uint256 m, uint256 typestringMemoryLocation) =\n                totalTokensLessInitialNative.beginPreparingBatchDepositPermit2Calldata(firstUnderlyingTokenIsNative);\n\n            // Insert the CompactDeposit typestring fragment.\n            typestringMemoryLocation.insertCompactDepositTypestring();\n\n            // Declare variable for signature offset value.\n            uint256 signatureOffsetValue;\n            assembly (\"memory-safe\") {\n                // Store the CompactDeposit witness hash.\n                mstore(add(m, 0x80), witness)\n\n                // Derive signature offset value.\n                signatureOffsetValue := add(0x200, shl(7, totalTokensLessInitialNative))\n            }\n\n            // Write the signature and perform the Permit2 call.\n            _writeSignatureAndPerformPermit2Call(m, uint256(0xc0).asStubborn(), signatureOffsetValue, signature);\n        }\n\n        // Deposit tokens based on balance changes from Permit2 call and clear reentrancy lock.\n        _verifyBalancesAndPerformDeposits(ids, permitted, initialTokenBalances, recipient, firstUnderlyingTokenIsNative);\n\n        // Return the ERC6909 token identifiers of the associated resource locks.\n        return ids;\n    }\n\n    /**\n     * @notice Internal function for depositing multiple tokens using Permit2 authorization and\n     * registering a compact in a single transaction. The first token id can optionally represent\n     * native tokens by providing the null address and an amount matching msg.value. The depositor\n     * must approve Permit2 to transfer the tokens on its behalf unless the tokens automatically\n     * grant approval to Permit2. The ERC6909 token amounts received by the depositor are derived\n     * from the differences between starting and ending balances held in the resource locks, which\n     * may differ from the amounts transferred depending on the implementation details of the\n     * respective tokens. The Permit2 authorization signed by the depositor must contain a\n     * BatchActivation witness containing the ids of the resource locks and an associated\n     * Compact, BatchCompact, or MultichainCompact payload matching the specified compact category.\n     * @param depositor       The account signing the permit2 authorization and depositing the tokens.\n     * @param permitted       Array of token permissions specifying the deposited tokens and amounts.\n     * @param witness         Additional data used in generating the claim hash.\n     * @param signature       The Permit2 signature from the depositor authorizing the deposits.\n     * @return ids            Array of ERC6909 token identifiers for the associated resource locks.\n     */\n    function _depositBatchAndRegisterViaPermit2(\n        address depositor,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        string calldata witness,\n        bytes calldata signature\n    ) internal returns (uint256[] memory ids) {\n        bool firstUnderlyingTokenIsNative;\n        uint256[] memory initialTokenBalances;\n        bytes32 compactTypehash;\n\n        {\n            uint256 totalTokensLessInitialNative;\n\n            // Set reentrancy guard, perform initial native deposit if present, and get initial token balances.\n            (totalTokensLessInitialNative, firstUnderlyingTokenIsNative, ids, initialTokenBalances) =\n                _preprocessAndPerformInitialNativeDeposit(permitted, depositor);\n\n            {\n                uint256 m;\n                CompactCategory compactCategory;\n                {\n                    // Derive the hash of the resource lock ids.\n                    uint256 idsHash;\n                    bytes32 activationTypehash;\n                    uint256 typestringMemoryLocation;\n\n                    assembly (\"memory-safe\") {\n                        idsHash :=\n                            keccak256(\n                                add(ids, 0x20), shl(5, add(totalTokensLessInitialNative, firstUnderlyingTokenIsNative))\n                            )\n\n                        compactCategory := calldataload(0xc4)\n                    }\n\n                    // Begin preparing Permit2 call data.\n                    (m, typestringMemoryLocation) = totalTokensLessInitialNative\n                        .beginPreparingBatchDepositPermit2Calldata(firstUnderlyingTokenIsNative);\n\n                    // Prepare the typestring fragment and get batch activation and compact typehashes.\n                    (activationTypehash, compactTypehash) = typestringMemoryLocation.writeWitnessAndGetTypehashes(\n                        compactCategory, witness, bool(true).asStubborn()\n                    );\n\n                    bytes32 claimHash;\n                    assembly (\"memory-safe\") {\n                        claimHash := calldataload(0xa4)\n                    }\n\n                    // Derive the batch activation witness hash and store it.\n                    activationTypehash.deriveAndWriteWitnessHash(idsHash, claimHash, m, 0x80);\n                }\n\n                // Declare variable for signature offset value.\n                uint256 signatureOffsetValue;\n                assembly (\"memory-safe\") {\n                    // Derive the total memory offset for the witness.\n                    let totalWitnessMemoryOffset :=\n                        and(\n                            add(add(0x147, add(witness.length, iszero(iszero(witness.length)))), mul(compactCategory, 0x0b)),\n                            not(0x1f)\n                        )\n\n                    // Derive the signature offset value.\n                    signatureOffsetValue :=\n                        add(add(0x180, shl(7, totalTokensLessInitialNative)), totalWitnessMemoryOffset)\n                }\n\n                // Write the signature and perform the Permit2 call.\n                _writeSignatureAndPerformPermit2Call(m, uint256(0xc0).asStubborn(), signatureOffsetValue, signature);\n            }\n        }\n\n        // Deposit tokens based on balance changes from Permit2 call and clear reentrancy lock.\n        _verifyBalancesAndPerformDeposits(ids, permitted, initialTokenBalances, depositor, firstUnderlyingTokenIsNative);\n\n        bytes32 registeredClaimHash;\n        assembly (\"memory-safe\") {\n            registeredClaimHash := calldataload(0xa4)\n        }\n\n        // Register the compact.\n        depositor.registerCompact(registeredClaimHash, compactTypehash);\n\n        // Return the ERC6909 token identifiers of the associated resource locks.\n        return ids;\n    }\n\n    /**\n     * @notice Private function for pre-processing and performing an initial native deposit.\n     * @param permitted                     Array of token permissions specifying the deposited tokens and amounts.\n     * @param recipient                     The address that will receive the corresponding ERC6909 tokens.\n     * @return totalTokensLessInitialNative The total number of tokens less the initial native deposit.\n     * @return firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     * @return ids                          Array of ERC6909 token identifiers.\n     * @return initialTokenBalances         Array of initial token balances.\n     */\n    function _preprocessAndPerformInitialNativeDeposit(\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        address recipient\n    )\n        private\n        returns (\n            uint256 totalTokensLessInitialNative,\n            bool firstUnderlyingTokenIsNative,\n            uint256[] memory ids,\n            uint256[] memory initialTokenBalances\n        )\n    {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Get total number of tokens and declare lockTag.\n        uint256 totalTokens = permitted.length;\n        bytes12 lockTag;\n\n        assembly (\"memory-safe\") {\n            // Get the offset of the permitted calldata struct.\n            let permittedOffset := permitted.offset\n\n            // Determine if the first underlying token is native.\n            firstUnderlyingTokenIsNative := iszero(shr(96, shl(96, calldataload(permittedOffset))))\n\n            // Revert if:\n            //  * the array is empty\n            //  * the callvalue is zero but the first token is native\n            //  * the callvalue is nonzero but the first token is non-native\n            //  * the first token is native and the callvalue doesn't equal the first amount\n            if or(\n                iszero(totalTokens),\n                or(\n                    eq(firstUnderlyingTokenIsNative, iszero(callvalue())),\n                    and(firstUnderlyingTokenIsNative, iszero(eq(callvalue(), calldataload(add(permittedOffset, 0x20)))))\n                )\n            ) {\n                // revert InvalidBatchDepositStructure()\n                mstore(0, 0xca0fc08e)\n                revert(0x1c, 0x04)\n            }\n\n            // Retrieve lockTag\n            // toIdIfRegistered does not sanitize the lockTag. Clear the rightmost 20 bytes.\n            lockTag := shl(160, shr(160, calldataload(0x84)))\n        }\n\n        // Get the initial resource lock id.\n        uint256 initialId = address(0).toIdIfRegistered(lockTag);\n\n        // Allocate ids array.\n        ids = new uint256[](totalTokens);\n\n        // Perform initial native deposit if present.\n        if (firstUnderlyingTokenIsNative) {\n            recipient.deposit(initialId, msg.value);\n\n            // Set the initial id using the native resource lock.\n            ids[0] = initialId;\n        }\n\n        // Calculate total number of tokens less the initial native deposit.\n        unchecked {\n            totalTokensLessInitialNative = totalTokens - firstUnderlyingTokenIsNative.asUint256();\n        }\n\n        // Prepare ids and get initial token balances.\n        initialTokenBalances = _prepareIdsAndGetBalances(\n            ids, totalTokensLessInitialNative, firstUnderlyingTokenIsNative, permitted, initialId\n        );\n    }\n\n    /**\n     * @notice Private function for setting the reentrancy guard and starting the process\n     *  of preparing a Permit2 call.\n     * @param token                      The address of the token to be deposited.\n     * @return id                        The ERC6909 token identifier of the associated resource lock.\n     * @return initialBalance            The initial balance of the token in the contract.\n     * @return m                         The memory pointer for the Permit2 call data.\n     * @return typestringMemoryLocation  The memory location for the typestring.\n     */\n    function _setReentrancyLockAndStartPreparingPermit2Call(address token)\n        private\n        returns (uint256 id, uint256 initialBalance, uint256 m, uint256 typestringMemoryLocation)\n    {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Declare lockTag\n        bytes12 lockTag;\n\n        // Retrieve lockTag from calldata.\n        assembly (\"memory-safe\") {\n            // toIdIfRegistered does not sanitize the lockTag. Clear the rightmost 20 bytes.\n            lockTag := shl(160, shr(160, calldataload(0xa4)))\n        }\n\n        // Get the ERC6909 token identifier of the associated resource lock.\n        id = token.excludingNative().toIdIfRegistered(lockTag);\n\n        // Get the initial balance of the token in the contract.\n        initialBalance = token.balanceOf(address(this));\n\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            m := mload(0x40)\n\n            // Poison the free memory pointer to guard against accidental reuse.\n            mstore(0x40, 0xffffffffffff)\n\n            // Begin preparing Permit2 call data.\n            mstore(m, _PERMIT_WITNESS_TRANSFER_FROM_SELECTOR)\n            calldatacopy(add(m, 0x20), 0x04, 0x80) // token, amount, nonce, deadline\n            mstore(add(m, 0xa0), address())\n            mstore(add(m, 0xc0), calldataload(0x24)) // amount\n            mstore(add(m, 0xe0), calldataload(0x84)) // depositor\n            mstore(add(m, 0x120), 0x140)\n\n            // Derive the memory location for the typestring.\n            typestringMemoryLocation := add(m, 0x160)\n        }\n    }\n\n    /**\n     * @notice Private function for writing the signature and performing the Permit2 call.\n     * @param m                       The memory pointer for the Permit2 call data.\n     * @param signatureOffsetLocation The memory location for the signature offset.\n     * @param signatureOffsetValue    The signature offset value.\n     * @param signature               The Permit2 signature.\n     */\n    function _writeSignatureAndPerformPermit2Call(\n        uint256 m,\n        uint256 signatureOffsetLocation,\n        uint256 signatureOffsetValue,\n        bytes calldata signature\n    ) private {\n        // Determine if Permit2 is deployed.\n        bool isPermit2Deployed = _isPermit2Deployed();\n\n        assembly (\"memory-safe\") {\n            // Write the signature offset.\n            mstore(add(m, signatureOffsetLocation), signatureOffsetValue) // signature offset\n\n            // Retrieve signature length and derive signature memory offset.\n            let signatureLength := signature.length\n            let signatureMemoryOffset := add(m, add(0x20, signatureOffsetValue))\n\n            // Write the signature length.\n            mstore(signatureMemoryOffset, signatureLength)\n\n            // Copy the signature from calldata to memory.\n            calldatacopy(add(signatureMemoryOffset, 0x20), signature.offset, signatureLength)\n\n            // Perform the Permit2 call.\n            if iszero(\n                and(\n                    isPermit2Deployed,\n                    call(gas(), _PERMIT2, 0, add(m, 0x1c), add(0x24, add(signatureOffsetValue, signatureLength)), 0, 0)\n                )\n            ) {\n                // Bubble up if the call failed and there's data. Note that remaining gas is not evaluated before\n                // copying the returndata buffer into memory. Out-of-gas errors can be triggered via revert bombing.\n                if returndatasize() {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert Permit2CallFailed();\n                mstore(0, 0x7f28c61e)\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /**\n     * @notice Private function for verifying balance changes and performing deposits.\n     * @param ids                          The ERC6909 token identifiers of the associated resource locks.\n     * @param permittedTokens              The token permissions specifying the deposited tokens and amounts.\n     * @param initialTokenBalances         The initial token balances in the contract.\n     * @param recipient                    The address that will receive the corresponding ERC6909 tokens.\n     * @param firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     */\n    function _verifyBalancesAndPerformDeposits(\n        uint256[] memory ids,\n        ISignatureTransfer.TokenPermissions[] calldata permittedTokens,\n        uint256[] memory initialTokenBalances,\n        address recipient,\n        bool firstUnderlyingTokenIsNative\n    ) private {\n        // Declare token balance, initial balance, and error buffer variables.\n        uint256 tokenBalance;\n        uint256 initialBalance;\n        uint256 errorBuffer;\n\n        // Retrieve total initial token balances (equal to total tokens less initial native deposit).\n        uint256 totalTokensLessInitialNative = initialTokenBalances.length;\n\n        unchecked {\n            // Iterate through each token.\n            for (uint256 i = 0; i < totalTokensLessInitialNative; ++i) {\n                // Get the token balance and initial balance.\n                tokenBalance =\n                    permittedTokens[i + firstUnderlyingTokenIsNative.asUint256()].token.balanceOf(address(this));\n                initialBalance = initialTokenBalances[i];\n\n                // Set the error buffer if the initial balance is greater than or equal to the token balance.\n                errorBuffer |= (initialBalance >= tokenBalance).asUint256();\n\n                // Perform the deposit.\n                recipient.deposit(ids[i + firstUnderlyingTokenIsNative.asUint256()], tokenBalance - initialBalance);\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Revert if the error buffer is set.\n            if errorBuffer {\n                // revert InvalidDepositBalanceChange()\n                mstore(0, 0x426d8dcf)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Clear reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Private function for preparing ids and getting token balances.\n     * Note that all tokens must be supplied in ascending order and cannot be duplicated.\n     * @param ids                          The ERC6909 token identifiers of the associated resource locks.\n     * @param totalTokensLessInitialNative The total number of tokens less the initial native deposit.\n     * @param firstUnderlyingTokenIsNative A boolean indicating whether the first underlying token is native.\n     * @param permitted                    The token permissions specifying the deposited tokens and amounts.\n     * @param id                           The ERC6909 token identifier of the associated resource lock.\n     * @return tokenBalances               The token balances in the contract.\n     */\n    function _prepareIdsAndGetBalances(\n        uint256[] memory ids,\n        uint256 totalTokensLessInitialNative,\n        bool firstUnderlyingTokenIsNative,\n        ISignatureTransfer.TokenPermissions[] calldata permitted,\n        uint256 id\n    ) private view returns (uint256[] memory tokenBalances) {\n        unchecked {\n            // Allocate token balances array.\n            tokenBalances = new uint256[](totalTokensLessInitialNative);\n\n            // Declare token, candidate id, and error buffer variables.\n            address token;\n            uint256 candidateId;\n            uint256 errorBuffer;\n\n            // Iterate over each token.\n            for (uint256 i = 0; i < totalTokensLessInitialNative; ++i) {\n                // Retrieve the token and derive the candidate id.\n                token = permitted[i + firstUnderlyingTokenIsNative.asUint256()].token;\n                candidateId = id.withReplacedToken(token);\n\n                // Set the error buffer if the candidate id is less than or equal to the current id.\n                errorBuffer |= (candidateId <= id).asUint256();\n\n                // Update the id.\n                id = candidateId;\n\n                // Set the id in the ids array.\n                ids[i + firstUnderlyingTokenIsNative.asUint256()] = id;\n\n                // Get the token balance and set it in the token balances array.\n                tokenBalances[i] = token.balanceOf(address(this));\n            }\n\n            assembly (\"memory-safe\") {\n                // Revert if the error buffer is set.\n                if errorBuffer {\n                    // revert InvalidDepositTokenOrdering()\n                    mstore(0, 0x0f2f1e51)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/lib/DirectDepositLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { DepositLogic } from \"./DepositLogic.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { TransferLib } from \"./TransferLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { ISignatureTransfer } from \"permit2/src/interfaces/ISignatureTransfer.sol\";\n\n/**\n * @title DirectDepositLogic\n * @notice Inherited contract implementing internal functions with logic for processing\n * direct token deposits (or deposits that do not involve Permit2). This includes both\n * single-token deposits and batch token deposits.\n */\ncontract DirectDepositLogic is DepositLogic {\n    using TransferLib for address;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for address;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for address;\n    using ValidityLib for address;\n    using SafeTransferLib for address;\n\n    /**\n     * @notice Internal function for depositing multiple tokens in a single transaction. The\n     * first entry in idsAndAmounts can optionally represent native tokens by providing the null\n     * address and an amount matching msg.value. For ERC20 tokens, the caller must directly\n     * approve The Compact to transfer sufficient amounts on its behalf. The ERC6909 token amounts\n     * received by the recipient are derived from the differences between starting and ending\n     * balances held in the resource locks, which may differ from the amounts transferred depending\n     * on the implementation details of the respective tokens.\n     * @param idsAndAmounts Array of [id, amount] pairs with each pair indicating the resource lock and amount to deposit.\n     * @param recipient     The address that will receive the corresponding ERC6909 tokens.\n     * @param enforceConsistentAllocator Boolean to indicate whether the allocatorId should be consistent across deposits.\n     * @return mintedAmounts Array containing the final minted amount of each id.\n     */\n    function _processBatchDeposit(\n        uint256[2][] calldata idsAndAmounts,\n        address recipient,\n        bool enforceConsistentAllocator\n    ) internal returns (uint256[] memory mintedAmounts) {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Reassign recipient to the caller if the null address was provided.\n        recipient = recipient.usingCallerIfNull();\n\n        // Retrieve the total number of IDs and amounts in the batch.\n        uint256 totalIds = idsAndAmounts.length;\n\n        mintedAmounts = new uint256[](totalIds);\n\n        // Declare variables for ID, amount, and whether first token is native.\n        uint256 id;\n        uint256 amount;\n        bool firstUnderlyingTokenIsNative;\n\n        assembly (\"memory-safe\") {\n            // Determine the offset of idsAndAmounts in calldata.\n            let idsAndAmountsOffset := idsAndAmounts.offset\n\n            // Load the first ID from idsAndAmounts.\n            id := calldataload(idsAndAmountsOffset)\n\n            // Determine if token encoded in first ID is the null address.\n            firstUnderlyingTokenIsNative := iszero(shl(96, id))\n\n            // Revert if:\n            //  * the array is empty\n            //  * the callvalue is zero but the first token is native\n            //  * the callvalue is nonzero but the first token is non-native\n            //  * the first token is native and the callvalue doesn't equal the first amount\n            if or(\n                iszero(totalIds),\n                or(\n                    eq(firstUnderlyingTokenIsNative, iszero(callvalue())),\n                    and(\n                        firstUnderlyingTokenIsNative,\n                        iszero(eq(callvalue(), calldataload(add(idsAndAmountsOffset, 0x20))))\n                    )\n                )\n            ) {\n                // revert InvalidBatchDepositStructure()\n                mstore(0, 0xca0fc08e)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Derive current allocator ID from first resource lock ID.\n        uint96 currentAllocatorId = id.toAllocatorIdIfRegistered();\n\n        // Declare variable for subsequent allocator IDs.\n        uint96 newAllocatorId;\n\n        // Deposit native tokens directly if first underlying token is native.\n        if (firstUnderlyingTokenIsNative) {\n            recipient.deposit(id, msg.value);\n            mintedAmounts[0] = msg.value;\n        }\n\n        // Iterate over remaining IDs and amounts.\n        unchecked {\n            for (uint256 i = firstUnderlyingTokenIsNative.asUint256(); i < totalIds; ++i) {\n                // Navigate to the current ID and amount pair in calldata.\n                uint256[2] calldata idAndAmount = idsAndAmounts[i];\n\n                // Retrieve the current ID and amount.\n                id = idAndAmount[0];\n                amount = idAndAmount[1];\n\n                // Derive new allocator ID from current resource lock ID.\n                newAllocatorId = id.toAllocatorId();\n\n                // Determine if new allocator ID differs from current allocator ID.\n                if (newAllocatorId != currentAllocatorId) {\n                    assembly (\"memory-safe\") {\n                        if enforceConsistentAllocator {\n                            // revert InconsistentAllocators();\n                            mstore(0, 0xaf346306)\n                            revert(0x1c, 4)\n                        }\n                    }\n\n                    // Ensure new allocator ID is registered.\n                    newAllocatorId.mustHaveARegisteredAllocator();\n\n                    // Update current allocator ID.\n                    currentAllocatorId = newAllocatorId;\n                }\n\n                // Transfer underlying tokens in and mint ERC6909 tokens to recipient.\n                mintedAmounts[i] = _transferAndDeposit(id.toAddress(), recipient, id, amount);\n            }\n        }\n\n        // Clear reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Internal function for depositing native tokens into a resource lock with custom\n     * reset period and scope parameters. The ERC6909 token amount received by the recipient\n     * will match the amount of native tokens sent with the transaction.\n     * @param lockTag     The lock tag containing allocator ID, reset period, and scope.\n     * @param recipient   The address that will receive the corresponding ERC6909 tokens.\n     * @return id         The ERC6909 token identifier of the associated resource lock.\n     */\n    function _performCustomNativeTokenDeposit(bytes12 lockTag, address recipient) internal returns (uint256 id) {\n        // Reassign recipient to the caller if the null address was provided.\n        recipient = recipient.usingCallerIfNull();\n\n        // Derive resource lock ID using null address, provided parameters, and allocator.\n        id = address(0).toIdIfRegistered(lockTag);\n\n        // Revert if the value is zero.\n        assembly (\"memory-safe\") {\n            if iszero(callvalue()) {\n                // revert InvalidDepositBalanceChange()\n                mstore(0, 0x426d8dcf)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Deposit native tokens and mint ERC6909 tokens to recipient.\n        recipient.deposit(id, msg.value);\n    }\n\n    /**\n     * @notice Internal function for depositing ERC20 tokens into a resource lock with custom reset\n     * period and scope parameters. The caller must directly approve The Compact to transfer a\n     * sufficient amount of the ERC20 token on its behalf. The ERC6909 token amount received by\n     * the recipient is derived from the difference between the starting and ending balance held\n     * in the resource lock, which may differ from the amount transferred depending on the\n     * implementation details of the respective token.\n     * @param token         The address of the ERC20 token to deposit.\n     * @param lockTag       The lock tag containing allocator ID, reset period, and scope.\n     * @param amount        The amount of tokens to deposit.\n     * @param recipient     The address that will receive the corresponding ERC6909 tokens.\n     * @return id           The ERC6909 token identifier of the associated resource lock.\n     * @return mintedAmount The minted ERC6909 token amount based on the balance change.\n     */\n    function _performCustomERC20Deposit(address token, bytes12 lockTag, uint256 amount, address recipient)\n        internal\n        returns (uint256 id, uint256 mintedAmount)\n    {\n        // Reassign recipient to the caller if the null address was provided.\n        recipient = recipient.usingCallerIfNull();\n\n        // Derive resource lock ID using provided token, parameters, and allocator.\n        id = token.excludingNative().toIdIfRegistered(lockTag);\n\n        // Transfer ERC20 tokens in and mint ERC6909 tokens to recipient.\n        mintedAmount = _transferAndDepositWithReentrancyGuard(token, recipient, id, amount);\n    }\n\n    /**\n     * @notice Private function for transferring ERC20 tokens in and minting the resulting balance\n     * change of `id` to `to`. Emits a Transfer event.\n     * @param token The address of the ERC20 token to transfer.\n     * @param to    The address that will receive the corresponding ERC6909 tokens.\n     * @param id    The ERC6909 token identifier of the associated resource lock.\n     * @param amount The amount of tokens to transfer.\n     * @return mintedAmount The minted ERC6909 token amount based on the balance change.\n     */\n    function _transferAndDeposit(address token, address to, uint256 id, uint256 amount)\n        private\n        returns (uint256 mintedAmount)\n    {\n        // Retrieve initial token balance of this contract.\n        uint256 initialBalance = token.balanceOf(address(this));\n\n        // Transfer tokens from caller to this contract.\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Compare new balance to initial balance and deposit ERC6909 tokens to recipient.\n        return _checkBalanceAndDeposit(token, to, id, initialBalance);\n    }\n\n    /**\n     * @notice Private function for transferring ERC20 tokens in and minting the resulting balance\n     * change of `id` to `to`. Emits a Transfer event.\n     * @param token         The address of the ERC20 token to transfer.\n     * @param to            The address that will receive the corresponding ERC6909 tokens.\n     * @param id            The ERC6909 token identifier of the associated resource lock.\n     * @param amount        The amount of tokens to transfer.\n     * @return mintedAmount The minted ERC6909 token amount based on the balance change.\n     */\n    function _transferAndDepositWithReentrancyGuard(address token, address to, uint256 id, uint256 amount)\n        private\n        returns (uint256 mintedAmount)\n    {\n        // Set reentrancy guard.\n        _setReentrancyGuard();\n\n        // Transfer tokens in and mint ERC6909 tokens to recipient.\n        mintedAmount = _transferAndDeposit(token, to, id, amount);\n\n        // Clear reentrancy guard.\n        _clearReentrancyGuard();\n    }\n}\n"},"lib/the-compact/src/lib/Extsload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/**\n * @title Extsload\n * @notice Contract implementing external functions for reading values from\n * storage or transient storage directly.\n */\ncontract Extsload {\n    /**\n     * @notice External view function for reading a value from transient storage.\n     * @param slot The storage slot to read from.\n     * @return The value stored in the specified transient storage slot.\n     */\n    function exttload(bytes32 slot) external view returns (bytes32) {\n        assembly (\"memory-safe\") {\n            mstore(0, tload(slot))\n            return(0, 0x20)\n        }\n    }\n\n    /**\n     * @notice External view function for reading a value from persistent storage.\n     * @param slot The storage slot to read from.\n     * @return The value stored in the specified persistent storage slot.\n     */\n    function extsload(bytes32 slot) external view returns (bytes32) {\n        assembly (\"memory-safe\") {\n            mstore(0, sload(slot))\n            return(0, 0x20)\n        }\n    }\n\n    /**\n     * @notice External view function for reading multiple values from persistent storage.\n     * @param slots An array of storage slots to read from.\n     * @return An array of values stored in the specified persistent storage slots.\n     */\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory) {\n        assembly (\"memory-safe\") {\n            let memptr := mload(0x40)\n            let start := memptr\n            // For abi encoding the response - the array will be found at 0x20.\n            mstore(memptr, 0x20)\n            // Next, store the length of the return array.\n            mstore(add(memptr, 0x20), slots.length)\n            // Update memptr to the first location to hold an array entry.\n            memptr := add(memptr, 0x40)\n            // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.\n            let end := add(memptr, shl(5, slots.length))\n            let calldataptr := slots.offset\n            for { } 1 { } {\n                mstore(memptr, sload(calldataload(calldataptr)))\n                memptr := add(memptr, 0x20)\n                if iszero(lt(memptr, end)) { break }\n                calldataptr := add(calldataptr, 0x20)\n            }\n            return(start, sub(end, start))\n        }\n    }\n}\n"},"lib/the-compact/src/lib/RegistrationLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatorLib } from \"./AllocatorLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { DomainLib } from \"./DomainLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\n\n/**\n * @title RegistrationLogic\n * @notice Inherited contract implementing logic for registering compact claim hashes\n * and typehashes and querying for whether given claim hashes and typehashes have\n * been registered.\n */\ncontract RegistrationLogic is ConstructorLogic {\n    using AllocatorLib for uint256[2][];\n    using RegistrationLib for address;\n    using RegistrationLib for bytes32;\n    using RegistrationLib for bytes32[2][];\n    using ValidityLib for address;\n    using ValidityLib for bytes32;\n    using IdLib for address;\n    using EfficiencyLib for uint256;\n    using DomainLib for uint256;\n    using EfficiencyLib for address;\n\n    /**\n     * @notice Internal function for registering a claim hash. The claim hash and its\n     * associated typehash will remain valid until the allocator consumes the nonce.\n     * @param sponsor   The account registering the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     */\n    function _register(address sponsor, bytes32 claimHash, bytes32 typehash) internal {\n        sponsor.registerCompact(claimHash, typehash);\n    }\n\n    /**\n     * @notice Internal function for registering multiple claim hashes in a single call. Each\n     * claim hash and its associated typehash will remain valid until the allocator consumes the nonce.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                         Whether all claim hashes were successfully registered.\n     */\n    function _registerBatch(bytes32[2][] calldata claimHashesAndTypehashes) internal returns (bool) {\n        return claimHashesAndTypehashes.registerBatchAsCaller();\n    }\n\n    /**\n     * @notice Internal function for registering a compact on behalf of a sponsor with their signature.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered compact.\n     */\n    function _registerFor(address sponsor, bytes32 typehash, bytes calldata sponsorSignature)\n        internal\n        returns (bytes32 claimHash)\n    {\n        return _deriveClaimHashAndRegisterCompact(sponsor, typehash, 0x120, _domainSeparator(), sponsorSignature);\n    }\n\n    /**\n     * @notice Internal function for registering a batch compact on behalf of a sponsor with their signature.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered batch compact.\n     */\n    function _registerBatchFor(address sponsor, bytes32 typehash, bytes calldata sponsorSignature)\n        internal\n        returns (bytes32 claimHash)\n    {\n        return _deriveClaimHashAndRegisterCompact(sponsor, typehash, 0xe0, _domainSeparator(), sponsorSignature);\n    }\n\n    /**\n     * @notice Internal function for registering a multichain compact on behalf of a sponsor with their signature.\n     * Note that the multichain compact in question will need to be independently registered on each chain where\n     * onchain registration is desired.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param notarizedChainId Chain ID of the domain used to sign the multichain compact.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The hash of the registered multichain compact.\n     */\n    function _registerMultichainFor(\n        address sponsor,\n        bytes32 typehash,\n        uint256 notarizedChainId,\n        bytes calldata sponsorSignature\n    ) internal returns (bytes32 claimHash) {\n        return _deriveClaimHashAndRegisterCompact(\n            sponsor, typehash, 0xa0, notarizedChainId.toNotarizedDomainSeparator(), sponsorSignature\n        );\n    }\n\n    /**\n     * @notice Internal function for deriving a claim hash and registering it as a compact.\n     * @param sponsor          The address of the sponsor for whom the compact is being registered.\n     * @param typehash         The EIP-712 typehash associated with the registered compact.\n     * @param preimageLength   The length of the preimage data used to derive the claim hash.\n     * @param domainSeparator  The domain separator to use for signature verification.\n     * @param sponsorSignature The signature from the sponsor authorizing the registration.\n     * @return claimHash       The derived and registered claim hash.\n     */\n    function _deriveClaimHashAndRegisterCompact(\n        address sponsor,\n        bytes32 typehash,\n        uint256 preimageLength,\n        bytes32 domainSeparator,\n        bytes calldata sponsorSignature\n    ) internal returns (bytes32 claimHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Copy relevant arguments from calldata to prepare hash preimage.\n            // Note that provided arguments may have dirty upper bits, which will\n            // give a claim hash that cannot be derived during claim processing.\n            calldatacopy(m, 0x04, preimageLength)\n\n            // Derive the claim hash from the prepared preimage data.\n            claimHash := keccak256(m, preimageLength)\n        }\n\n        // Ensure that the sponsor has verified the supplied claim hash.\n        claimHash.hasValidSponsor(sponsor, sponsorSignature, domainSeparator);\n\n        // Register the compact for the indicated sponsor.\n        sponsor.registerCompact(claimHash, typehash);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the expiration timestamp of a\n     * registration.\n     * @param sponsor   The account that registered the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     * @return registered Whether the compact has been registered.\n     */\n    function _isRegistered(address sponsor, bytes32 claimHash, bytes32 typehash)\n        internal\n        view\n        returns (bool registered)\n    {\n        registered = sponsor.isRegistered(claimHash, typehash);\n    }\n\n    //// Registration of specific compacts ////\n\n    /**\n     * @notice Internal function to register a compact by its components.\n     * @dev Constructs and registers the compact that consists exactly of the provided\n     * arguments.\n     * @param sponsor    Account that the compact should be registered for.\n     * @param tokenId    Identifier for the associated token & lock.\n     * @param amount     Compact's associated number of tokens.\n     * @param arbiter    Account able to initiate a claim against the registered compact.\n     * @param nonce      Allocator-scoped replay protection nonce.\n     * @param expires    Timestamp when the compact expires.\n     * @param typehash   Typehash of the entire compact including subtypes of the witness.\n     * @param witness    EIP712 structured hash of witness.\n     * @return claimHash EIP712 structured hash of the compact to register.\n     */\n    function _registerUsingCompact(\n        address sponsor,\n        uint256 tokenId,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) internal returns (bytes32 claimHash) {\n        // Reassign sponsor to the caller if the null address was provided.\n        sponsor = sponsor.usingCallerIfNull();\n\n        claimHash = HashLib.toClaimHashFromDeposit(sponsor, tokenId, amount, arbiter, nonce, expires, typehash, witness);\n        sponsor.registerCompact(claimHash, typehash);\n    }\n\n    /**\n     * @notice Internal function to register a batch compact by its components.\n     * @dev Constructs and registers the compact that consists exactly of the provided\n     * arguments.\n     * @param sponsor            Account that the compact should be registered for.\n     * @param idsAndAmounts      Ids and amounts associated with the registered compact.\n     * @param arbiter            Account able to initiate a claim against the registered compact.\n     * @param nonce              Allocator-scoped replay protection nonce.\n     * @param expires            Timestamp when the compact expires.\n     * @param typehash           Typehash of the entire compact including subtypes of the witness.\n     * @param witness            EIP712 structured hash of witness.\n     * @param replacementAmounts An array of replacement amounts.\n     * @return claimHash         EIP712 structured hash of the registered compact.\n     */\n    function _registerUsingBatchCompact(\n        address sponsor,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness,\n        uint256[] memory replacementAmounts\n    ) internal returns (bytes32 claimHash) {\n        // Reassign sponsor to the caller if the null address was provided.\n        sponsor = sponsor.usingCallerIfNull();\n\n        claimHash = HashLib.toClaimHashFromBatchDeposit(\n            sponsor, idsAndAmounts, arbiter, nonce, expires, typehash, witness, replacementAmounts\n        );\n        sponsor.registerCompact(claimHash, typehash);\n    }\n}\n"},"lib/the-compact/src/lib/TransferLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { TransferComponent, Component, ComponentsById } from \"../types/Components.sol\";\n\nimport { ClaimHashLib } from \"./ClaimHashLib.sol\";\nimport { ComponentLib } from \"./ComponentLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { EventLib } from \"./EventLib.sol\";\nimport { TransferFunctionCastLib } from \"./TransferFunctionCastLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { AllocatorLib } from \"./AllocatorLib.sol\";\n\n/**\n * @title TransferLogic\n * @notice Inherited contract implementing internal functions with logic for processing\n * allocated token transfers and withdrawals. These calls are submitted directly by the\n * sponsor and therefore only need to be independently authorized by the allocator. To\n * construct the authorizing Compact or BatchCompact payload, the arbiter is set as the\n * sponsor.\n */\ncontract TransferLogic is ConstructorLogic {\n    using ClaimHashLib for AllocatedTransfer;\n    using ClaimHashLib for AllocatedBatchTransfer;\n    using ComponentLib for AllocatedTransfer;\n    using ComponentLib for AllocatedBatchTransfer;\n    using ComponentLib for Component[];\n    using IdLib for uint256;\n    using IdLib for uint96;\n    using EfficiencyLib for bool;\n    using EventLib for address;\n    using ValidityLib for uint96;\n    using ValidityLib for uint256;\n    using ValidityLib for bytes32;\n    using\n    TransferFunctionCastLib\n    for function(bytes32, address, AllocatedTransfer calldata, uint256[2][] memory) internal;\n    using AllocatorLib for address;\n\n    // bytes4(keccak256(\"attest(address,address,address,uint256,uint256)\")).\n    uint32 private constant _ATTEST_SELECTOR = 0x1a808f91;\n\n    /**\n     * @notice Internal function for processing a transfer or withdrawal. Validates the\n     * allocator signature, checks expiration, consumes the nonce, and executes the transfer\n     * or withdrawal operation targeting multiple recipients from a single resource lock.\n     * @param transfer  An AllocatedTransfer struct containing signature, nonce, expiry, and transfer details.\n     * @return          Whether the transfer was successfully processed.\n     */\n    function _processTransfer(AllocatedTransfer calldata transfer) internal returns (bool) {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        uint256[2][] memory idsAndAmounts = new uint256[2][](1);\n        idsAndAmounts[0] = [transfer.id, transfer.recipients.aggregate()];\n\n        // Derive hash, validate expiry, consume nonce, and check allocator signature.\n        _notExpiredAndAuthorizedByAllocator(\n            transfer.toClaimHash(),\n            transfer.id.toRegisteredAllocatorWithConsumed(transfer.nonce),\n            transfer,\n            idsAndAmounts\n        );\n\n        // Perform the transfers or withdrawals.\n        transfer.processTransfer();\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function for processing a batch transfer or withdrawal. Validates\n     * the allocator signature, checks expiration, consumes the nonce, ensures consistent\n     * allocator across all resource locks, and executes the transfer or withdrawal operation\n     * for multiple recipients from multiple resource locks.\n     * @param transfer  An AllocatedBatchTransfer struct containing signature, nonce, expiry, and batch transfer details.\n     * @return          Whether the transfer was successfully processed.\n     */\n    function _processBatchTransfer(AllocatedBatchTransfer calldata transfer) internal returns (bool) {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        // Navigate to the batch components array in calldata.\n        ComponentsById[] calldata transfers = transfer.transfers;\n\n        // Retrieve the total number of components.\n        uint256 totalIds = transfers.length;\n        uint256[2][] memory idsAndAmounts = new uint256[2][](totalIds);\n\n        unchecked {\n            // Iterate over each component in calldata.\n            for (uint256 i = 0; i < totalIds; ++i) {\n                // Navigate to location of the component in calldata.\n                ComponentsById calldata component = transfers[i];\n\n                // Process transfer for each component in the set.\n                idsAndAmounts[i] = [component.id, component.portions.aggregate()];\n            }\n        }\n\n        // Derive hash, validate expiry, consume nonce, and check allocator signature.\n        _notExpiredAndAuthorizedByAllocator.usingBatchTransfer()(\n            transfer.toClaimHash(),\n            _deriveConsistentAllocatorAndConsumeNonce(transfer.transfers, transfer.nonce),\n            transfer,\n            idsAndAmounts\n        );\n\n        // Perform the batch transfers or withdrawals.\n        transfer.performBatchTransfer();\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function for ensuring a transfer has been attested by its allocator.\n     * Makes a call to the allocator's attest function and reverts if the attestation fails\n     * due to a reverted call or due to the call not returning the required magic value. Note\n     * that this call is stateful.\n     * @param from    The account transferring tokens.\n     * @param to      The account receiving tokens.\n     * @param id      The ERC6909 token identifier of the resource lock.\n     * @param amount  The amount of tokens being transferred.\n     */\n    function _ensureAttested(address from, address to, uint256 id, uint256 amount) internal {\n        // Derive the allocator address from the supplied id.\n        address allocator = id.toAllocatorId().toRegisteredAllocator();\n\n        assembly (\"memory-safe\") {\n            // Sanitize from and to addresses.\n            from := shr(0x60, shl(0x60, from))\n            to := shr(0x60, shl(0x60, to))\n\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Ensure sure initial scratch space is cleared as an added precaution.\n            mstore(0, 0)\n\n            // Derive offset to start of data for the call from memory pointer.\n            let dataStart := add(m, 0x1c)\n\n            // Prepare calldata: attest(caller(), from, to, id, amount).\n            mstore(m, _ATTEST_SELECTOR)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), from)\n            mstore(add(m, 0x60), to)\n            mstore(add(m, 0x80), id)\n            mstore(add(m, 0xa0), amount)\n\n            // Perform call to allocator and write response to scratch space.\n            let success := call(gas(), allocator, 0, dataStart, 0xa4, 0, 0x20)\n\n            // Revert if the required magic value was not received back.\n            if iszero(eq(mload(0), shl(224, _ATTEST_SELECTOR))) {\n                // Bubble up if the call failed and there's data. Note that remaining gas is not evaluated before\n                // copying the returndata buffer into memory. Out-of-gas errors can be triggered via revert bombing.\n                if iszero(or(success, iszero(returndatasize()))) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert UnallocatedTransfer(msg.sender, from, to, id, amount)\n                mstore(m, 0x014c9310)\n                revert(dataStart, 0xa4)\n            }\n        }\n    }\n\n    /**\n     * @notice Private function that checks expiration, verifies the allocator's signature,\n     * and emits a claim event.\n     * @param messageHash     The EIP-712 hash of the transfer message.\n     * @param allocator       The address of the allocator.\n     * @param transferPayload The AllocatedTransfer struct containing signature and expiry.\n     * @param idsAndAmounts   An array with IDs and aggregate transfer amounts.\n     */\n    function _notExpiredAndAuthorizedByAllocator(\n        bytes32 messageHash,\n        address allocator,\n        AllocatedTransfer calldata transferPayload,\n        uint256[2][] memory idsAndAmounts\n    ) private {\n        uint256 expires = transferPayload.expires;\n        uint256 nonce = transferPayload.nonce;\n\n        // Ensure that the expiration timestamp is still in the future.\n        expires.later();\n\n        allocator.callAuthorizeClaim(\n            messageHash,\n            msg.sender, // sponsor\n            nonce,\n            expires,\n            idsAndAmounts,\n            transferPayload.allocatorData\n        );\n\n        // Emit Claim event.\n        msg.sender.emitClaim(messageHash, allocator, nonce);\n    }\n\n    /**\n     * @notice Private function that ensures all components in a batch transfer share the\n     * same allocator and consumes the nonce. Reverts if any component has a different\n     * allocator or if the batch is empty.\n     * @param components           Array of transfer components to check.\n     * @param nonce                The nonce to consume.\n     * @return allocator           The validated allocator address.\n     */\n    function _deriveConsistentAllocatorAndConsumeNonce(ComponentsById[] calldata components, uint256 nonce)\n        private\n        returns (address allocator)\n    {\n        // Retrieve the total number of components.\n        uint256 totalComponents = components.length;\n\n        // Track errors, starting with whether total number of components is zero.\n        uint256 errorBuffer = (totalComponents == 0).asUint256();\n\n        // Revert if an error was encountered.\n        assembly (\"memory-safe\") {\n            if errorBuffer {\n                // revert InvalidBatchAllocation()\n                mstore(0, 0x3a03d3bb)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Retrieve the ID of the initial component and derive the allocator ID.\n        uint96 allocatorId = components[0].id.toAllocatorId();\n\n        // Retrieve the allocator address and consume the nonce.\n        allocator = allocatorId.fromRegisteredAllocatorIdWithConsumed(nonce);\n\n        unchecked {\n            // Iterate over each additional component in calldata.\n            for (uint256 i = 1; i < totalComponents; ++i) {\n                // Retrieve ID and mark error if derived allocatorId differs from initial one.\n                errorBuffer |= (components[i].id.toAllocatorId() != allocatorId).asUint256();\n            }\n        }\n\n        // Revert if an error was encountered.\n        assembly (\"memory-safe\") {\n            if errorBuffer {\n                // revert InvalidBatchAllocation()\n                mstore(0, 0x3a03d3bb)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/lib/WithdrawalLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ForcedWithdrawalStatus } from \"../types/ForcedWithdrawalStatus.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { EventLib } from \"./EventLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { TransferLib } from \"./TransferLib.sol\";\n\n/**\n * @title WithdrawalLogic\n * @notice Inherited contract implementing internal functions with logic for processing\n * forced withdrawals, including initiation and the actual withdrawal, and for querying\n * for the forced withdrawal status for given resource locks.\n */\ncontract WithdrawalLogic is ConstructorLogic {\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for address;\n    using EventLib for uint256;\n    using TransferLib for address;\n\n    // Storage scope for forced withdrawal activation times:\n    // slot: keccak256(_FORCED_WITHDRAWAL_ACTIVATIONS_SCOPE ++ account ++ id) => activates.\n    uint256 private constant _FORCED_WITHDRAWAL_ACTIVATIONS_SCOPE = 0x41d0e04b;\n\n    /**\n     * @notice Internal function for initiating a forced withdrawal. Computes the withdrawable\n     * timestamp by adding the current block timestamp to the reset period associated with the\n     * resource lock, stores the sum, and emits a ForcedWithdrawalStatusUpdated event.\n     * @param id                The ERC6909 token identifier of the resource lock.\n     * @return withdrawableAt   The timestamp at which tokens become withdrawable.\n     */\n    function _enableForcedWithdrawal(uint256 id) internal returns (uint256 withdrawableAt) {\n        // Skip overflow check as reset period is bounded.\n        unchecked {\n            // Derive the time at which the forced withdrawal is enabled.\n            withdrawableAt = block.timestamp + id.toResetPeriod().toSeconds();\n        }\n\n        // Derive storage slot containing time withdrawal is enabled.\n        uint256 cutoffTimeSlotLocation = _getCutoffTimeSlot(msg.sender, id);\n        assembly (\"memory-safe\") {\n            // Store the time at which the forced withdrawal is enabled.\n            sstore(cutoffTimeSlotLocation, withdrawableAt)\n        }\n\n        // emit the ForcedWithdrawalStatusUpdated event.\n        id.emitForcedWithdrawalStatusUpdatedEvent(withdrawableAt);\n    }\n\n    /**\n     * @notice Internal function for disabling a forced withdrawal. Reverts if the withdrawal\n     * is already disabled, clears the withdrawable timestamp, and emits a\n     * ForcedWithdrawalStatusUpdated event.\n     * @param id The ERC6909 token identifier of the resource lock.\n     */\n    function _disableForcedWithdrawal(uint256 id) internal {\n        // Derive storage slot containing time withdrawal is enabled.\n        uint256 cutoffTimeSlotLocation = _getCutoffTimeSlot(msg.sender, id);\n\n        assembly (\"memory-safe\") {\n            // Revert if withdrawal is already disabled.\n            if iszero(sload(cutoffTimeSlotLocation)) {\n                // revert ForcedWithdrawalAlreadyDisabled(msg.sender, id)\n                mstore(0, 0xe632dbad)\n                mstore(0x20, caller())\n                mstore(0x40, id)\n                revert(0x1c, 0x44)\n            }\n\n            // Clear the value for the stored time the withdrawal is enabled.\n            sstore(cutoffTimeSlotLocation, 0)\n        }\n\n        // emit the ForcedWithdrawalStatusUpdated event.\n        id.emitForcedWithdrawalStatusUpdatedEvent(uint256(0).asStubborn());\n    }\n\n    /**\n     * @notice Internal function for executing a forced withdrawal. Checks that the withdrawal\n     * is enabled and the reset period has elapsed, then processes the withdrawal by burning\n     * ERC6909 tokens and transferring the underlying tokens to the specified recipient.\n     * @param id        The ERC6909 token identifier of the resource lock.\n     * @param recipient The account that will receive the withdrawn tokens.\n     * @param amount    The amount of tokens to withdraw.\n     */\n    function _processForcedWithdrawal(uint256 id, address recipient, uint256 amount) internal {\n        // Derive the storage slot containing the time the withdrawal is enabled.\n        uint256 cutoffTimeSlotLocation = _getCutoffTimeSlot(msg.sender, id);\n\n        assembly (\"memory-safe\") {\n            // Retrieve the value for the time the withdrawal is enabled.\n            let withdrawableAt := sload(cutoffTimeSlotLocation)\n\n            // Check that withdrawal is not disabled and that reset period has elapsed.\n            if or(iszero(withdrawableAt), gt(withdrawableAt, timestamp())) {\n                // revert PrematureWithdrawal(id)\n                mstore(0, 0x9287bcb0)\n                mstore(0x20, id)\n                revert(0x1c, 0x24)\n            }\n        }\n\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        // Process the withdrawal.\n        msg.sender.withdraw(recipient.usingCallerIfNull(), id, amount, true);\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Internal view function for checking the forced withdrawal status. Returns the\n     * status (disabled, pending, or enabled) based on whether a withdrawable timestamp exists\n     * and whether it has elapsed.\n     * @param account    The account to check the status for.\n     * @param id         The ERC6909 token identifier of the resource lock.\n     * @return status    The current ForcedWithdrawalStatus (disabled, pending, or enabled).\n     * @return enabledAt The timestamp when forced withdrawal becomes possible.\n     */\n    function _getForcedWithdrawalStatus(address account, uint256 id)\n        internal\n        view\n        returns (ForcedWithdrawalStatus status, uint256 enabledAt)\n    {\n        // Derive the storage slot containing the time the withdrawal is enabled.\n        uint256 cutoffTimeSlotLocation = _getCutoffTimeSlot(account, id);\n\n        assembly (\"memory-safe\") {\n            // Retrieve the value for the time the withdrawal is enabled.\n            enabledAt := sload(cutoffTimeSlotLocation)\n\n            // Compute status: 0 if disabled, 1 if pending, 2 if enabled.\n            status := mul(iszero(iszero(enabledAt)), sub(2, gt(enabledAt, timestamp())))\n        }\n    }\n\n    /**\n     * @notice Private pure function for computing the storage slot for a forced\n     * withdrawal activation timestamp.\n     * @param account                 The account that initiated the forced withdrawal.\n     * @param id                      The ERC6909 token identifier of the resource lock.\n     * @return cutoffTimeSlotLocation The storage slot for the activation timestamp.\n     */\n    function _getCutoffTimeSlot(address account, uint256 id) private pure returns (uint256 cutoffTimeSlotLocation) {\n        assembly (\"memory-safe\") {\n            // Pack data for computing storage slot. Note that the upper\n            // 24 bytes of the free memory pointer are dirtied and will\n            // be restored once the storage slot has been derived.\n            mstore(0x14, account)\n            mstore(0, _FORCED_WITHDRAWAL_ACTIVATIONS_SCOPE)\n            mstore(0x34, id)\n\n            // Compute storage slot from packed data.\n            cutoffTimeSlotLocation := keccak256(0x1c, 0x38)\n\n            // Restore the dirtied portion of the free memory pointer.\n            mstore(0x34, 0)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/EmissaryLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { EmissaryLib } from \"./EmissaryLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { IAllocator } from \"../interfaces/IAllocator.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { EmissaryStatus } from \"../types/EmissaryStatus.sol\";\n\n/**\n * @title EmissaryLogic\n * @notice Logic that provides functionality for delegating signature verification\n * @dev This contract enables accounts to delegate signature verification to another address,\n *      which is particularly important for maintaining credible commitments in TheCompact ecosystem.\n *\n * When EOAs upgrade to smart accounts (as enabled by EIP-7702), their signature\n * verification method potentially changes from ECDSA to ERC1271. This creates a potential issue\n * where an EOA could use EIP-7702 to redelegate to a new account implementation and break previously\n * established credible commitments.\n *\n * EmissaryLogic introduces a delegation mechanism where signature verification can be\n * delegated to an external contract that verifies claim hashes on behalf of the sponsor.\n * This creates more reliable credible commitments by ensuring signature verification\n * remains consistent even if the account implementation changes.\n *\n * A timelock mechanism is implemented to prevent immediate changes to emissaries,\n * providing additional security against malicious redelegation attempts.\n * The contract provides functions to schedule and assign emissaries, as well as\n * get the current status of an emissary assignment.\n */\ncontract EmissaryLogic {\n    using IdLib for address;\n    using IdLib for uint96;\n    using IdLib for bytes12;\n    using EmissaryLib for bytes12;\n    using EmissaryLib for address;\n\n    /**\n     * @notice Initiates the timelock process for changing an emissary\n     * @param lockTag The lock tag to schedule emissary assignment for.\n     * @return emissaryAssignmentAvailableAt The time at which assigment can be performed.\n     * @dev This function starts the timelock period that must pass before\n     *      a new emissary can be set. The timelock is specific to the caller (msg.sender).\n     *      After calling this function, the caller must wait for the timelock period to expire\n     *      before calling `assignEmissary`.\n     *\n     *      The timelock mechanism ensures that changes to emissaries are not immediate,\n     *      providing a security buffer to prevent malicious or accidental redelegation attempts.\n     *      This period allows time for any necessary reviews or interventions.\n     *\n     *      The function utilizes `hasRegisteredAllocatorId` to validate the allocator ID\n     *      ensuring that only registered allocators can proceed.\n     *\n     * @custom:emits EmissaryTimelockSet event through the library call, signaling the start of the timelock period.\n     */\n    function _scheduleEmissaryAssignment(bytes12 lockTag) internal returns (uint256 emissaryAssignmentAvailableAt) {\n        lockTag.hasRegisteredAllocatorId();\n        emissaryAssignmentAvailableAt = lockTag.scheduleEmissaryAssignment();\n    }\n\n    /**\n     * @notice Sets a new emissary for the sponsor\n     * @dev This function can only be called after the timelock period has passed.\n     *      The timelock must be initiated by calling `scheduleEmissaryAssignment` first.\n     *      The emissary address can be set to the zero address to remove delegation,\n     *      effectively disabling the current emissary.\n     *\n     *      The emissary address must not be the address of the allocator to prevent\n     *      conflicts of interest and maintain the integrity of the delegation mechanism.\n     *\n     *      The function utilizes `toAllocatorIdIfRegistered` to validate and convert the allocator\n     *      address to its corresponding ID, ensuring that only registered allocators can proceed.\n     *\n     *      The `ResetPeriod` parameter specifies the reset behavior for the emissary assignment,\n     *      adding flexibility to the delegation process.\n     *\n     * @param emissary The address that will be authorized to sign on behalf of the sponsor.\n     *                  Set to address(0) to remove the current emissary.\n     * @custom:emits EmissarySet event through the library call, signaling the successful assignment of a new emissary\n     * @custom:throws If the timelock period has not passed or was not initiated, ensuring secure delegation practices\n     */\n    function _assignEmissary(bytes12 lockTag, address emissary) internal returns (bool) {\n        // Extract allocatorId from locktag and ensure that the allocator is registered.\n        address allocator = lockTag.toAllocatorId().toRegisteredAllocator();\n\n        // Ensure allocator is not the emissary as it would grant the entity unilateral control.\n        if (allocator == emissary) {\n            assembly (\"memory-safe\") {\n                // Revert InvalidEmissaryAssignment();\n                mstore(0, 0x2411f310)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Assign the emissary of the lock tag for the caller.\n        lockTag.assignEmissary(emissary);\n\n        return true;\n    }\n\n    /**\n     * @notice Retrieves the current status of an emissary assignment for a given sponsor and allocator\n     * @dev This function queries the emissary status, which can be one of the following:\n     *      - `Disabled`: No emissary is currently assigned.\n     *      - `Enabled`: An emissary is currently active and can sign on behalf of the sponsor.\n     *      - `Scheduled`: An emissary assignment is pending and will become active after the timelock period.\n     *\n     *      The function also returns the timestamp when the emissary assignment will be available,\n     *      and the address of the current emissary if one is assigned.\n     *\n     *      The `toAllocatorId` function is used to retrieve the allocator's ID, ensuring consistent\n     *      and accurate status retrieval.\n     *\n     * @param sponsor The address of the sponsor who has delegated signature verification.\n     * @param lockTag The lock tag associated with the emissary assignment.\n     * @return status The current status of the emissary assignment (Disabled, Enabled, or Scheduled).\n     * @return assignableAt The timestamp when the emissary assignment will be available (if scheduled).\n     * @return currentEmissary The address of the currently assigned emissary, if any.\n     */\n    function _getEmissaryStatus(address sponsor, bytes12 lockTag)\n        internal\n        view\n        returns (EmissaryStatus status, uint256 assignableAt, address currentEmissary)\n    {\n        lockTag.hasRegisteredAllocatorId();\n\n        return sponsor.getEmissaryStatus(lockTag);\n    }\n}\n"},"lib/the-compact/src/lib/ConsumerLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/**\n * @title ConsumerLib\n * @notice Library contract implementing logic for consuming bitpacked nonces scoped to\n * specific accounts and for querying for the state of those nonces. Note that only the\n * allocator nonce scope is currently in use in The Compact.\n */\nlibrary ConsumerLib {\n    // Storage scope identifiers for nonce buckets.\n    uint256 private constant _ALLOCATOR_NONCE_SCOPE = 0x03f37b1a;\n\n    // Error thrown when attempting to consume an already-consumed nonce.\n    error InvalidNonce(address account, uint256 nonce);\n\n    /**\n     * @notice Internal function for consuming a nonce in the allocator's scope.\n     * @param nonce     The nonce to consume.\n     * @param allocator The address of the allocator whose scope to consume the nonce in.\n     */\n    function consumeNonceAsAllocator(uint256 nonce, address allocator) internal {\n        _consumeNonce(nonce, allocator, _ALLOCATOR_NONCE_SCOPE);\n    }\n\n    /**\n     * @notice Internal view function for checking if a nonce has been consumed in the\n     * allocator's scope.\n     * @param nonceToCheck The nonce to check.\n     * @param allocator    The address of the allocator whose scope to check.\n     * @return consumed    Whether the nonce has been consumed.\n     */\n    function isConsumedByAllocator(uint256 nonceToCheck, address allocator) internal view returns (bool consumed) {\n        return _isConsumedBy(nonceToCheck, allocator, _ALLOCATOR_NONCE_SCOPE);\n    }\n\n    /**\n     * @notice Private function implementing nonce consumption logic. Uses the last byte\n     * of the nonce to determine which bit to set in a 256-bit storage bucket unique to\n     * the account and scope. Reverts if the nonce has already been consumed.\n     * @param nonce   The nonce to consume.\n     * @param account The address of the account whose scope to consume the nonce in.\n     * @param scope   The scope identifier to consume the nonce in.\n     */\n    function _consumeNonce(uint256 nonce, address account, uint256 scope) private {\n        // The last byte of the nonce is used to assign a bit in a 256-bit bucket;\n        // specific nonces are consumed for each account and can only be used once.\n        // NOTE: this function temporarily overwrites the free memory pointer, but\n        // restores it before returning.\n        assembly (\"memory-safe\") {\n            // Store free memory pointer; its memory location will be overwritten.\n            let freeMemoryPointer := mload(0x40)\n\n            // derive the nonce bucket slot:\n            // keccak256(_ALLOCATOR_NONCE_SCOPE ++ account ++ nonce[0:31])\n            mstore(0x20, account)\n            mstore(0x0c, scope)\n            mstore(0x40, nonce)\n            let bucketSlot := keccak256(0x28, 0x37)\n\n            // Retrieve nonce bucket and check if nonce has been consumed.\n            let bucketValue := sload(bucketSlot)\n            let bit := shl(and(0xff, nonce), 1)\n            if and(bit, bucketValue) {\n                // `InvalidNonce(address,uint256)` with padding for `account`.\n                mstore(0x0c, 0xdbc205b1000000000000000000000000)\n                revert(0x1c, 0x44)\n            }\n\n            // Invalidate the nonce by setting its bit.\n            sstore(bucketSlot, or(bucketValue, bit))\n\n            // Restore the free memory pointer.\n            mstore(0x40, freeMemoryPointer)\n        }\n    }\n\n    /**\n     * @notice Private view function implementing nonce consumption checking logic.\n     * Uses the last byte of the nonce to determine which bit to check in a 256-bit\n     * storage bucket unique to the account and scope.\n     * @param nonceToCheck The nonce to check.\n     * @param account      The address of the account whose scope to check.\n     * @param scope        The scope identifier to check.\n     * @return consumed    Whether the nonce has been consumed.\n     */\n    function _isConsumedBy(uint256 nonceToCheck, address account, uint256 scope) private view returns (bool consumed) {\n        assembly (\"memory-safe\") {\n            // Store free memory pointer; its memory location will be overwritten.\n            let freeMemoryPointer := mload(0x40)\n\n            // derive the nonce bucket slot:\n            // keccak256(_ALLOCATOR_NONCE_SCOPE ++ account ++ nonce[0:31])\n            mstore(0x20, account)\n            mstore(0x0c, scope)\n            mstore(0x40, nonceToCheck)\n\n            // Retrieve nonce bucket value and determine whether the nonce is set.\n            consumed := and(shl(and(0xff, nonceToCheck), 1), sload(keccak256(0x28, 0x37)))\n\n            // Restore the free memory pointer.\n            mstore(0x40, freeMemoryPointer)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/ValidityLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Scope } from \"../types/Scope.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\nimport { IdLib } from \"./IdLib.sol\";\nimport { ConsumerLib } from \"./ConsumerLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { DomainLib } from \"./DomainLib.sol\";\nimport { EmissaryLib } from \"./EmissaryLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\n\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\n\n/**\n * @title ValidityLib\n * @notice Library contract implementing logic for validating expirations,\n * signatures, nonces (including consuming unused nonces), and token addresses.\n */\nlibrary ValidityLib {\n    using RegistrationLib for address;\n    using ValidityLib for address;\n    using IdLib for uint96;\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using ConsumerLib for uint256;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for ResetPeriod;\n    using DomainLib for bytes32;\n    using ValidityLib for uint256;\n    using EmissaryLib for bytes32;\n    using EmissaryLib for uint256[2][];\n    using FixedPointMathLib for uint256;\n    using SignatureCheckerLib for address;\n\n    error NoIdsAndAmountsProvided();\n\n    /**\n     * @notice Internal function that retrieves an allocator's address from their ID and\n     * consumes a nonce in their scope. Reverts if the allocator is not registered.\n     * @param allocatorId The unique identifier for a registered allocator.\n     * @param nonce       The nonce to consume in the allocator's scope.\n     * @return allocator  The address of the registered allocator.\n     */\n    function fromRegisteredAllocatorIdWithConsumed(uint96 allocatorId, uint256 nonce)\n        internal\n        returns (address allocator)\n    {\n        allocator = allocatorId.toRegisteredAllocator();\n        nonce.consumeNonceAsAllocator(allocator);\n    }\n\n    /**\n     * @notice Internal function that retrieves an allocator's address from a resource lock ID\n     * and consumes a nonce in their scope. Reverts if the allocator is not registered.\n     * @param id         The ERC6909 token identifier containing the allocator ID.\n     * @param nonce      The nonce to consume in the allocator's scope.\n     * @return allocator The address of the registered allocator.\n     */\n    function toRegisteredAllocatorWithConsumed(uint256 id, uint256 nonce) internal returns (address allocator) {\n        allocator = id.toAllocatorId().toRegisteredAllocator();\n        nonce.consumeNonceAsAllocator(allocator);\n    }\n\n    /**\n     * @notice Internal view function that ensures that a timestamp has not yet passed.\n     * Reverts if the provided timestamp is not in the future.\n     * @param expires The timestamp to check.\n     */\n    function later(uint256 expires) internal view {\n        assembly (\"memory-safe\") {\n            if iszero(gt(expires, timestamp())) {\n                // revert Expired(expiration);\n                mstore(0, 0xf80dbaea)\n                mstore(0x20, expires)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function that validates a signature against an expected signer.\n     * Returns if the signature is valid or if the caller is the expected signer, otherwise\n     * reverts. The message hash is combined with the domain separator before verification.\n     * If ECDSA recovery fails, an EIP-1271 isValidSignature check is performed. Note that\n     * an emissary check will not be performed.\n     * @param messageHash     The EIP-712 hash of the message to verify.\n     * @param expectedSigner  The address that should have signed the message.\n     * @param signature       The signature to verify.\n     * @param domainSeparator The domain separator to combine with the message hash.\n     */\n    function hasValidSponsor(\n        bytes32 messageHash,\n        address expectedSigner,\n        bytes calldata signature,\n        bytes32 domainSeparator\n    ) internal view {\n        // Apply domain separator to message hash to derive the digest.\n        bytes32 digest = messageHash.withDomain(domainSeparator);\n\n        // First, check signature against digest with ECDSA (or ensure sponsor is caller).\n        if (expectedSigner.isValidECDSASignatureCalldata(digest, signature)) {\n            return;\n        }\n\n        // Finally, check EIP1271 using the digest and signature.\n        if (!expectedSigner.isValidERC1271SignatureNowCalldata(digest, signature)) {\n            assembly (\"memory-safe\") {\n                // revert InvalidSignature();\n                mstore(0, 0x8baa579f)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function that validates a signature or registration against an expected\n     * signer. If the initial verification fails, the emissary is used to validate the claim.\n     * Returns if the signature is valid or if the caller is the expected signer, otherwise\n     * reverts. The claim hash is combined with the domain separator before verification.\n     * If ECDSA recovery fails, an EIP-1271 isValidSignature check is performed with half of\n     * available gas. If EIP-1271 fails, and an IEmissary is set for the sponsor, an\n     * IEmissary.verifyClaim check is performed.\n     * @param claimHash           The EIP-712 hash of the claim to verify.\n     * @param expectedSigner      The address that should have signed the message.\n     * @param signature           The signature to verify.\n     * @param domainSeparator     The domain separator to combine with the message hash.\n     * @param typehash            The EIP-712 typehash used for the claim message.\n     */\n    function validateSponsorAndConsumeRegistration(\n        bytes32 claimHash,\n        address expectedSigner,\n        bytes calldata signature,\n        bytes32 domainSeparator,\n        uint256[2][] memory idsAndAmounts,\n        bytes32 typehash\n    ) internal {\n        if (expectedSigner.consumeRegistrationIfRegistered(claimHash, typehash)) {\n            return;\n        }\n\n        // Apply domain separator to message hash to derive the digest.\n        bytes32 digest = claimHash.withDomain(domainSeparator);\n\n        // First, check signature against digest with ECDSA (or ensure sponsor is caller).\n        if (expectedSigner.isValidECDSASignatureCalldata(digest, signature)) {\n            return;\n        }\n\n        // Then, check EIP1271 using the digest, supplying half of available gas.\n        if (expectedSigner.isValidERC1271SignatureNowCalldataHalfGas(digest, signature)) {\n            return;\n        }\n\n        // Finally, fallback to emissary using the claim hash.\n        digest.verifyWithEmissary(claimHash, expectedSigner, idsAndAmounts.extractSameLockTag(), signature);\n    }\n\n    /**\n     * @notice Internal view function to check if a nonce has been consumed in an\n     * allocator's scope.\n     * @param allocator The allocator whose scope to check.\n     * @param nonce     The nonce to check.\n     * @return          Whether the nonce has been consumed.\n     */\n    function hasConsumedAllocatorNonce(address allocator, uint256 nonce) internal view returns (bool) {\n        return nonce.isConsumedByAllocator(allocator);\n    }\n\n    /**\n     * @notice Internal pure function that validates a token address is not the zero\n     * address (which represents native tokens). Reverts if the address is zero.\n     * @param token The token address to validate.\n     * @return      The validated token address.\n     */\n    function excludingNative(address token) internal pure returns (address) {\n        assembly (\"memory-safe\") {\n            if iszero(shl(96, token)) {\n                // revert InvalidToken(0);\n                mstore(0x40, 0x961c9a4f)\n                revert(0x5c, 0x24)\n            }\n        }\n\n        return token;\n    }\n\n    /**\n     * @notice Internal pure function for validating that a resource lock's scope is compatible\n     * with the provided sponsor domain separator. Reverts if an exogenous claim (indicated by\n     * a non-zero sponsor domain separator) attempts to claim against a chain-specific resource\n     * lock (indicated by the most significant bit of the id).\n     * @param sponsorDomainSeparator The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param id                     The ERC6909 token identifier of the resource lock.\n     */\n    function ensureValidScope(bytes32 sponsorDomainSeparator, uint256 id) internal pure {\n        assembly (\"memory-safe\") {\n            if iszero(or(iszero(sponsorDomainSeparator), iszero(shr(255, id)))) {\n                // revert InvalidScope(id)\n                mstore(0, 0xa06356f5)\n                mstore(0x20, id)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function for determining if a resource lock has chain-specific\n     * scope in the context of an exogenous claim. Returns true if the claim is exogenous\n     * (indicated by a non-zero sponsor domain separator) and the resource lock is\n     * chain-specific.\n     * @param id                     The ERC6909 token identifier of the resource lock.\n     * @param sponsorDomainSeparator The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @return                       Whether the resource lock's scope is incompatible with the claim context.\n     */\n    function scopeNotMultichain(uint256 id, bytes32 sponsorDomainSeparator) internal pure returns (bool) {\n        return (sponsorDomainSeparator != bytes32(0)).and(id.toScope() == Scope.ChainSpecific);\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// using `ecrecover`.\n    function isValidECDSASignatureCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        // Determine whether the signer is the caller.\n        bool signerIsCaller = signer == msg.sender;\n\n        // Exit early if signer is either the caller or the null address.\n        if ((signer == address(0)).or(signerIsCaller)) {\n            // Valid if signer is caller, otherwise invalid (null address).\n            return signerIsCaller;\n        }\n\n        assembly (\"memory-safe\") {\n            // Cache free memory pointer.\n            let m := mload(0x40)\n\n            // Use a faux loop to support breaking early.\n            for { } 1 { } {\n                // examine the length of the supplied signature.\n                switch signature.length\n                case 64 {\n                    // Parse length 64 as EIP2098 compact signatures.\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    // Parse length 65 as standard rsv signatures.\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                }\n                default { break }\n\n                // Prepare hash in scratch space.\n                mstore(0x00, hash)\n\n                // Call the ecrecover precompile and examine returndata for validity.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n\n                // Restore the zero slot and free memory pointer.\n                mstore(0x60, 0)\n                mstore(0x40, m)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    /// Sourced from Solady with a modification to only supply half of available gas.\n    function isValidERC1271SignatureNowCalldataHalfGas(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        assembly (\"memory-safe\") {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(div(gas(), 2), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n}\n"},"lib/the-compact/src/interfaces/ITheCompactClaims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Claim } from \"../types/Claims.sol\";\n\nimport { BatchClaim } from \"../types/BatchClaims.sol\";\n\nimport { MultichainClaim, ExogenousMultichainClaim } from \"../types/MultichainClaims.sol\";\n\nimport { BatchMultichainClaim, ExogenousBatchMultichainClaim } from \"../types/BatchMultichainClaims.sol\";\n\n/**\n * @title The Compact  Claims Interface\n * @custom:version 1\n * @author 0age (0age.eth)\n * @notice Claim endpoints can only be called by the arbiter indicated on the associated\n * compact, and are used to settle the compact in question. There are 6 endpoints in total,\n * based on the following factors:\n *  - whether or not to utilize a \"batch\" of resource locks on a specific chain: When the\n *    sponsor is utilizing multiple resource locks on a specific chain, they will sign or\n *    register a `BatchCompact` EIP-712 payload. (Single-chain claims sign or register a\n *    `Compact` EIP-712 payload).\n *  - whether or not to include resource locks on a single chain or multiple chains; in\n *    the event of a multichain compact, there are _two_ additional endpoints per option,\n *    one for claims against the first referenced chain where the domain matches the one\n *    signed for or registered against (the \"notarized\" chain) and one for claims against\n *    other chains where the resource locks indicate a multichain scope (the \"exogenous\"\n *    chains). When the sponsor is utilizing multiple resource locks across multiple chains,\n *    they will sign a `MultichainCompact` EIP-712 payload. When claiming these for the\n *    notarized chain, an array of bytes32 values representing additional chain \"elements\"\n *    is provided. When claiming against an exogenous chain, the additional chains array\n *    begins with the notarized chain and then includes values for all exogenous chains\n *    excluding the one being claimed against, and a chain index is supplied indicating the\n *    location in the list of elements of the current chain (a value of 0 means that it is)\n *    the first exogenous chain) as well as a `notarizedChainId` representing the chainId\n *    for the domain that the multichain claim was signed against.\n */\ninterface ITheCompactClaims {\n    /**\n     * @notice Process a standard single-chain claim.\n     * @param claimPayload The claim data containing signature, allocator data, and compact details.\n     * @return claimHash   The hash of the processed claim.\n     */\n    function claim(Claim calldata claimPayload) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Process a batch claim for multiple resource locks on a single chain.\n     * @param claimPayload The batch claim data containing signature, allocator data, and compact details.\n     * @return claimHash   The hash of the processed batch claim.\n     */\n    function batchClaim(BatchClaim calldata claimPayload) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Process a multichain claim for the notarized chain (where domain matches the one signed for).\n     * @param claimPayload The multichain claim data containing signature, allocator data, compact details, and chain elements.\n     * @return claimHash   The hash of the processed multichain claim.\n     */\n    function multichainClaim(MultichainClaim calldata claimPayload) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Process a multichain claim for an exogenous chain (not the notarized chain).\n     * @param claimPayload The exogenous multichain claim data containing signature, allocator data, compact details, chain index, and notarized chain ID.\n     * @return claimHash   The hash of the processed exogenous multichain claim.\n     */\n    function exogenousClaim(ExogenousMultichainClaim calldata claimPayload) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Process a batch multichain claim for multiple resource locks on the notarized chain.\n     * @param claimPayload The batch multichain claim data containing signature, allocator data, compact details, and chain elements.\n     * @return claimHash   The hash of the processed batch multichain claim.\n     */\n    function batchMultichainClaim(BatchMultichainClaim calldata claimPayload) external returns (bytes32 claimHash);\n\n    /**\n     * @notice Process a batch multichain claim for multiple resource locks on an exogenous chain.\n     * @param claimPayload The exogenous batch multichain claim data containing signature, allocator data, compact details, chain index, and notarized chain ID.\n     * @return claimHash   The hash of the processed exogenous batch multichain claim.\n     */\n    function exogenousBatchClaim(ExogenousBatchMultichainClaim calldata claimPayload)\n        external\n        returns (bytes32 claimHash);\n}\n"},"lib/the-compact/src/lib/ClaimProcessorLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Claim } from \"../types/Claims.sol\";\nimport { BatchClaim } from \"../types/BatchClaims.sol\";\nimport { MultichainClaim, ExogenousMultichainClaim } from \"../types/MultichainClaims.sol\";\nimport { BatchMultichainClaim, ExogenousBatchMultichainClaim } from \"../types/BatchMultichainClaims.sol\";\n\nimport { ClaimHashLib } from \"./ClaimHashLib.sol\";\nimport { ClaimProcessorLib } from \"./ClaimProcessorLib.sol\";\nimport { ClaimProcessorFunctionCastLib } from \"./ClaimProcessorFunctionCastLib.sol\";\nimport { DomainLib } from \"./DomainLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\n\n/**\n * @title ClaimProcessorLogic\n * @notice Inherited contract implementing internal functions with logic for processing\n * claims against a signed or registered compact. Each function derives the respective\n * claim hash as well as a typehash if applicable, then processes the claim.\n * @dev IMPORTANT NOTE: this logic assumes that the utilized structs are formatted in a\n * very specific manner if parameters are rearranged or new parameters are inserted,\n * much of this functionality will break. Proceed with caution when making any changes.\n */\ncontract ClaimProcessorLogic is ConstructorLogic {\n    using ClaimHashLib for Claim;\n    using ClaimHashLib for BatchClaim;\n    using ClaimHashLib for MultichainClaim;\n    using ClaimHashLib for ExogenousMultichainClaim;\n    using ClaimHashLib for BatchMultichainClaim;\n    using ClaimHashLib for ExogenousBatchMultichainClaim;\n    using ClaimProcessorLib for uint256;\n    using ClaimProcessorFunctionCastLib for function(bytes32, uint256, bytes32, bytes32, bytes32) internal;\n    using ClaimProcessorFunctionCastLib for function(bytes32, uint256, bytes32, bytes32) internal;\n    using ClaimProcessorFunctionCastLib for function(bytes32, uint256, uint256, bytes32, bytes32, bytes32) internal;\n    using ClaimProcessorFunctionCastLib for function(bytes32, bytes32, uint256, uint256, bytes32, bytes32) internal;\n    using\n    ClaimProcessorFunctionCastLib\n    for function(bytes32, bytes32, uint256, uint256, bytes32, bytes32, bytes32) internal;\n    using DomainLib for uint256;\n    using HashLib for uint256;\n    using EfficiencyLib for uint256;\n\n    ///// 1. Claims /////\n    function _processClaim(Claim calldata claimPayload) internal returns (bytes32 claimHash) {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        bytes32 typehash;\n        (claimHash, typehash) = claimPayload.toMessageHashes();\n        ClaimProcessorLib.processSimpleClaim.usingClaim()(claimHash, claimPayload, typehash, _domainSeparator());\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    ///// 2. Batch Claims /////\n    function _processBatchClaim(BatchClaim calldata claimPayload) internal returns (bytes32 claimHash) {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        bytes32 typehash;\n        (claimHash, typehash) = claimPayload.toMessageHashes();\n        ClaimProcessorLib.processSimpleBatchClaim.usingBatchClaim()(\n            claimHash, claimPayload, typehash, _domainSeparator()\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    ///// 3. Multichain Claims /////\n    function _processMultichainClaim(MultichainClaim calldata claimPayload) internal returns (bytes32 claimHash) {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        bytes32 typehash;\n        (claimHash, typehash) = claimPayload.toMessageHashes();\n        ClaimProcessorLib.processSimpleClaim.usingMultichainClaim()(\n            claimHash, claimPayload, typehash, _domainSeparator()\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    ///// 4. Batch Multichain Claims /////\n    function _processBatchMultichainClaim(BatchMultichainClaim calldata claimPayload)\n        internal\n        returns (bytes32 claimHash)\n    {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        bytes32 typehash;\n        (claimHash, typehash) = claimPayload.toMessageHashes();\n        ClaimProcessorLib.processSimpleBatchClaim.usingBatchMultichainClaim()(\n            claimHash, claimPayload, typehash, _domainSeparator()\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    ///// 5. Exogenous Multichain Claims /////\n    function _processExogenousMultichainClaim(ExogenousMultichainClaim calldata claimPayload)\n        internal\n        returns (bytes32 claimHash)\n    {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        bytes32 typehash;\n        (claimHash, typehash) = claimPayload.toMessageHashes();\n        ClaimProcessorLib.processClaimWithSponsorDomain.usingExogenousMultichainClaim()(\n            claimHash,\n            claimPayload,\n            claimPayload.notarizedChainId.toNotarizedDomainSeparator(),\n            typehash,\n            _domainSeparator()\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    ///// 6. Exogenous Batch Multichain Claims /////\n    function _processExogenousBatchMultichainClaim(ExogenousBatchMultichainClaim calldata claimPayload)\n        internal\n        returns (bytes32 claimHash)\n    {\n        // Set the reentrancy guard.\n        _setReentrancyGuard();\n\n        bytes32 typehash;\n        (claimHash, typehash) = claimPayload.toMessageHashes();\n        ClaimProcessorLib.processBatchClaimWithSponsorDomain.usingExogenousBatchMultichainClaim()(\n            claimHash,\n            claimPayload,\n            claimPayload.notarizedChainId.toNotarizedDomainSeparator(),\n            typehash,\n            _domainSeparator()\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n}\n"},"lib/the-compact/src/types/MultichainClaims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Component } from \"./Components.sol\";\n\nstruct MultichainClaim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    Component[] claimants; // The claim recipients and amounts; specified by the arbiter.\n    bytes32[] additionalChains; // The element hashes from additional chains.\n}\n\nstruct ExogenousMultichainClaim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    uint256 id; // The token ID of the ERC6909 token to allocate.\n    uint256 allocatedAmount; // The original allocated amount of ERC6909 tokens.\n    Component[] claimants; // The claim recipients and amounts; specified by the arbiter.\n    bytes32[] additionalChains; // The element hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current element hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n}\n"},"lib/the-compact/src/types/BatchMultichainClaims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { BatchClaimComponent } from \"./Components.sol\";\n\nstruct BatchMultichainClaim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    BatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n    bytes32[] additionalChains; // The element hashes from additional chains.\n}\n\nstruct ExogenousBatchMultichainClaim {\n    bytes allocatorData; // Authorization from the allocator.\n    bytes sponsorSignature; // Authorization from the sponsor.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes32 witness; // Hash of the witness data.\n    string witnessTypestring; // Witness typestring appended to existing typestring.\n    BatchClaimComponent[] claims; // The claim token IDs, recipients and amounts.\n    bytes32[] additionalChains; // The element hashes from additional chains.\n    uint256 chainIndex; // The index after which to insert the current element hash.\n    uint256 notarizedChainId; // The chain id used to sign the multichain claim.\n}\n"},"lib/the-compact/src/lib/DepositLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\n\nimport { TransferLib } from \"./TransferLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/**\n * @title DepositLogic\n * @notice Inherited contract implementing internal functions with low-level shared logic for\n * processing token deposits.\n */\ncontract DepositLogic is ConstructorLogic {\n    using TransferLib for address;\n    using SafeTransferLib for address;\n\n    /**\n     * @notice Internal function that verifies a token balance increase and mints the\n     * corresponding amount of ERC6909 tokens. Checks that the token balance has increased\n     * from the provided initial balance, and mints the difference to the specified recipient.\n     * Reverts if the balance has not increased. Finally, emits a Transfer event.\n     * @param token          The address of the token to check the balance of.\n     * @param to             The account to mint ERC6909 tokens to.\n     * @param id             The ERC6909 token identifier to mint.\n     * @param initialBalance The token balance before the deposit operation.\n     * @return mintedAmount The minted ERC6909 token amount based on the balance change.\n     */\n    function _checkBalanceAndDeposit(address token, address to, uint256 id, uint256 initialBalance)\n        internal\n        returns (uint256 mintedAmount)\n    {\n        // Get the current token balance to compare against initial balance.\n        uint256 tokenBalance = token.balanceOf(address(this));\n\n        // Revert if the balance hasn't increased.\n        assembly (\"memory-safe\") {\n            if iszero(lt(initialBalance, tokenBalance)) {\n                // revert InvalidDepositBalanceChange()\n                mstore(0, 0x426d8dcf)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Skip underflow check as balance increase has been confirmed.\n        unchecked {\n            mintedAmount = tokenBalance - initialBalance;\n        }\n\n        // Mint the balance difference as ERC6909 tokens.\n        to.deposit(id, mintedAmount);\n    }\n}\n"},"lib/the-compact/src/lib/DepositViaPermit2Lib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { CompactCategory } from \"../types/CompactCategory.sol\";\nimport {\n    COMPACT_TYPEHASH,\n    BATCH_COMPACT_TYPEHASH,\n    PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH,\n    PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_THREE,\n    TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE,\n    TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO,\n    COMPACT_ACTIVATION_TYPEHASH,\n    BATCH_COMPACT_ACTIVATION_TYPEHASH,\n    COMPACT_BATCH_ACTIVATION_TYPEHASH,\n    BATCH_COMPACT_BATCH_ACTIVATION_TYPEHASH,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_SIX,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_MANDATE_FRAGMENT_ONE,\n    PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_MANDATE_FRAGMENT_TWO,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_ONE,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_TWO,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_THREE,\n    COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_FOUR\n} from \"../types/EIP712Types.sol\";\n\n/**\n * @title DepositViaPermit2Lib\n * @notice Library contract implementing internal functions with logic for processing\n * token deposits via permit2. These deposits leverage Permit2 witness data to either\n * indicate the parameters of the lock to deposit into and the recipient of the deposit,\n * or the parameters of the compact to register alongside the deposit. Deposits can also\n * involve a single ERC20 token or a batch of tokens in a single Permit2 authorization.\n * @dev IMPORTANT NOTE: this logic operates directly on unallocated memory, and reads\n * directly from fixed calldata offsets; proceed with EXTREME caution when making any\n * modifications to either this logic contract (including the insertion of new logic) or\n * to the associated permit2 deposit function interfaces!\n */\nlibrary DepositViaPermit2Lib {\n    // Selector for the batch `permit2.permitWitnessTransferFrom` function.\n    uint256 private constant _BATCH_PERMIT_WITNESS_TRANSFER_FROM_SELECTOR = 0xfe8ec1a7;\n\n    error InvalidCompactCategory();\n\n    /**\n     * @notice Internal view function for preparing batch deposit permit2 calldata.\n     * Prepares known arguments and offsets in memory and returns pointers to the start\n     * of the prepared calldata as well as to the start of the witness typestring.\n     * @param totalTokensLessInitialNative The number of non-native tokens to deposit.\n     * @param firstUnderlyingTokenIsNative Whether the first underlying token is native.\n     * @return m The memory pointer to the start of the prepared calldata.\n     * @return typestringMemoryLocation The memory pointer to the start of the typestring.\n     */\n    function beginPreparingBatchDepositPermit2Calldata(\n        uint256 totalTokensLessInitialNative,\n        bool firstUnderlyingTokenIsNative\n    ) internal view returns (uint256 m, uint256 typestringMemoryLocation) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            m := mload(0x40)\n\n            // Poison the free memory pointer to guard against accidental reuse.\n            mstore(0x40, 0xffffffffffff)\n\n            // Derive size of each token chunk (2 words per token).\n            let tokenChunk := shl(6, totalTokensLessInitialNative)\n\n            // Derive size of two token chunks (4 words per token).\n            let twoTokenChunks := shl(1, tokenChunk)\n\n            // Derive memory location of the `permitted` calldata struct.\n            let permittedCalldataLocation := add(add(0x24, calldataload(0x24)), shl(6, firstUnderlyingTokenIsNative))\n\n            // Prepare the initial fragment of the witness typestring.\n            mstore(m, _BATCH_PERMIT_WITNESS_TRANSFER_FROM_SELECTOR)\n            mstore(add(m, 0x20), 0xc0) // permitted offset\n            mstore(add(m, 0x40), add(0x140, tokenChunk)) // details offset\n            mstore(add(m, 0x60), calldataload(0x04)) // depositor\n            // Skip witnessHash at 0x80 as it is not yet known.\n            mstore(add(m, 0xa0), add(0x160, twoTokenChunks)) // witness offset\n            // Skip signatureOffset at 0xc0 as it is not yet known.\n            mstore(add(m, 0xe0), 0x60) // permitted tokens relative offset\n            mstore(add(m, 0x100), calldataload(0x44)) // nonce\n            mstore(add(m, 0x120), calldataload(0x64)) // deadline\n            mstore(add(m, 0x140), totalTokensLessInitialNative) // permitted.length\n\n            // Copy permitted data from calldata to memory.\n            calldatacopy(add(m, 0x160), permittedCalldataLocation, tokenChunk)\n\n            // Derive memory location of the `details` calldata struct.\n            let detailsOffset := add(add(m, 0x160), tokenChunk)\n\n            // Store the length of the `details` array.\n            mstore(detailsOffset, totalTokensLessInitialNative)\n\n            // Derive start, next, & end locations for iterating through `details` array.\n            let starting := add(detailsOffset, 0x20)\n            let next := add(detailsOffset, 0x40)\n            let end := shl(6, totalTokensLessInitialNative)\n\n            // Iterate through `details` array and copy data from calldata to memory.\n            for { let i := 0 } lt(i, end) { i := add(i, 0x40) } {\n                // Copy this contract as the recipient address.\n                mstore(add(starting, i), address())\n\n                // Copy full token amount as the requested amount.\n                mstore(add(next, i), calldataload(add(permittedCalldataLocation, add(0x20, i))))\n            }\n\n            // Derive memory location of the witness typestring.\n            typestringMemoryLocation := add(m, add(0x180, twoTokenChunks))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving typehashes and simultaneously\n     * preparing the witness typestring component of the call to permit2.\n     * @param memoryLocation      The memory pointer to the start of the typestring.\n     * @param category            The CompactCategory of the deposit. Must be Compact or BatchCompact.\n     * @param witness             The witness string to insert.\n     * @param usingBatch          Whether the deposit involves a batch.\n     * @return activationTypehash The derived activation typehash.\n     * @return compactTypehash    The derived compact typehash.\n     */\n    function writeWitnessAndGetTypehashes(\n        uint256 memoryLocation,\n        CompactCategory category,\n        string calldata witness,\n        bool usingBatch\n    ) internal pure returns (bytes32 activationTypehash, bytes32 compactTypehash) {\n        assembly (\"memory-safe\") {\n            // Internal assembly function for writing the witness and typehashes.\n            // Used to enable leaving the inline assembly scope early when the\n            // witness is empty (no-witness case).\n            for { } 1 { } {\n                // Derive memory offset for the witness typestring data.\n                let memoryOffset := add(memoryLocation, 0x20)\n\n                // Declare variables for start of Activation and Category-specific data.\n                let activationStart\n                let categorySpecificStart\n\n                // Handle non-batch cases.\n                if iszero(usingBatch) {\n                    // Prepare initial Activation witness typestring fragment.\n                    mstore(add(memoryOffset, 0x1b), PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO)\n                    mstore(memoryOffset, PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE)\n\n                    // Set memory pointers for Activation and Category-specific data start.\n                    activationStart := add(memoryOffset, 0x13)\n                    categorySpecificStart := add(memoryOffset, 0x3b)\n                }\n\n                // Proceed with batch case if preparation of activation has not begun.\n                if iszero(activationStart) {\n                    // Prepare initial BatchActivation witness typestring fragment.\n                    mstore(memoryOffset, PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE)\n                    mstore(add(memoryOffset, 0x28), PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_THREE)\n                    mstore(add(memoryOffset, 0x20), PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO)\n\n                    // Set memory pointers for Activation and Category-specific data.\n                    activationStart := add(memoryOffset, 0x18)\n                    categorySpecificStart := add(memoryOffset, 0x48)\n                }\n\n                // Declare variable for end of Category-specific data.\n                let categorySpecificEnd\n\n                // Handle Compact (non-batch, single-chain) case.\n                if iszero(category) {\n                    // Prepare next typestring fragment using Compact witness typestring.\n                    mstore(categorySpecificStart, PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_ONE)\n                    mstore(add(categorySpecificStart, 0x20), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_TWO)\n                    mstore(add(categorySpecificStart, 0x40), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_THREE)\n                    mstore(add(categorySpecificStart, 0x7b), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FIVE)\n                    mstore(add(categorySpecificStart, 0x60), PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n\n                    // Set memory pointers for Activation and Category-specific data end.\n                    categorySpecificEnd := add(categorySpecificStart, 0x9b)\n                    categorySpecificStart := add(categorySpecificStart, 0x10)\n                }\n\n                // Handle BatchCompact (single-chain) case.\n                if iszero(sub(category, 1)) {\n                    // Prepare next typestring fragment using BatchCompact witness typestring.\n                    mstore(categorySpecificStart, PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE)\n                    mstore(add(categorySpecificStart, 0x20), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO)\n\n                    mstore(\n                        add(categorySpecificStart, 0x62),\n                        PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_MANDATE_FRAGMENT_ONE\n                    )\n                    mstore(add(categorySpecificStart, 0x52), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n                    mstore(add(categorySpecificStart, 0x40), PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE)\n                    mstore(\n                        add(categorySpecificStart, 0x9d),\n                        PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_MANDATE_FRAGMENT_TWO\n                    )\n\n                    let categorySpecificStartIncorporatingWitness :=\n                        add(categorySpecificStart, shl(4, iszero(iszero(witness.length))))\n                    mstore(\n                        add(categorySpecificStartIncorporatingWitness, 0x85),\n                        PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_SIX\n                    )\n                    mstore(\n                        add(categorySpecificStartIncorporatingWitness, 0x72),\n                        PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE\n                    )\n\n                    // Set memory pointers for Activation and Category-specific data end.\n                    categorySpecificEnd := add(categorySpecificStart, 0xbd)\n                    categorySpecificStart := add(categorySpecificStart, 0x15)\n                }\n\n                // Revert on MultichainCompact case or above (registration only applies to the current chain).\n                if iszero(categorySpecificEnd) {\n                    // revert InvalidCompactCategory();\n                    mstore(0, 0xdae3f108)\n                    revert(0x1c, 4)\n                }\n\n                // Handle no-witness cases.\n                if iszero(witness.length) {\n                    // Derive memory offset for region used to retrieve typestring fragment by index.\n                    let indexWords := shl(5, category)\n\n                    categorySpecificEnd := sub(categorySpecificEnd, 24)\n\n                    // Prepare token permissions typestring fragment.\n                    mstore(add(categorySpecificEnd, 0x0e), TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO)\n                    mstore(sub(categorySpecificEnd, 1), TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE)\n\n                    // Derive total length of typestring and store at start of memory.\n                    mstore(memoryLocation, sub(add(categorySpecificEnd, 0x2e), memoryOffset))\n\n                    // Derive activation typehash based on the compact category for non-batch cases.\n                    if iszero(usingBatch) {\n                        // Prepare typehashes for Activation.\n                        mstore(0, COMPACT_ACTIVATION_TYPEHASH)\n                        mstore(0x20, BATCH_COMPACT_ACTIVATION_TYPEHASH)\n\n                        // Retrieve respective typehash by index.\n                        activationTypehash := mload(indexWords)\n                    }\n\n                    // Derive activation typehash for batch cases if typehash is not yet derived.\n                    if iszero(activationTypehash) {\n                        // Prepare typehashes for BatchActivation.\n                        mstore(0, COMPACT_BATCH_ACTIVATION_TYPEHASH)\n                        mstore(0x20, BATCH_COMPACT_BATCH_ACTIVATION_TYPEHASH)\n\n                        // Retrieve respective typehash by index.\n                        activationTypehash := mload(indexWords)\n                    }\n\n                    // Prepare compact typehashes.\n                    mstore(0, COMPACT_TYPEHASH)\n                    mstore(0x20, BATCH_COMPACT_TYPEHASH)\n\n                    // Retrieve respective typehash by index.\n                    compactTypehash := mload(indexWords)\n\n                    // Leave the inline assembly scope early.\n                    break\n                }\n\n                // Copy the supplied compact witness from calldata.\n                calldatacopy(categorySpecificEnd, witness.offset, witness.length)\n\n                // Insert tokenPermissions typestring fragment.\n                let tokenPermissionsFragmentStart := add(categorySpecificEnd, witness.length)\n                mstore(add(tokenPermissionsFragmentStart, 0x0f), TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO)\n                mstore(tokenPermissionsFragmentStart, TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE)\n\n                // Derive total length of typestring and store at start of memory.\n                mstore(memoryLocation, sub(add(tokenPermissionsFragmentStart, 0x2f), memoryOffset))\n\n                // Derive activation typehash.\n                activationTypehash :=\n                    keccak256(activationStart, sub(add(tokenPermissionsFragmentStart, 1), activationStart))\n\n                // Derive compact typehash.\n                compactTypehash :=\n                    keccak256(categorySpecificStart, sub(add(tokenPermissionsFragmentStart, 1), categorySpecificStart))\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the activation witness hash and\n     * writing it to a specified memory location. Depends on the \"activator\" or caller.\n     * @param activationTypehash The derived activation typehash.\n     * @param idOrIdsHash        Resource lock ID or uint256 representation of the hash of each ID.\n     * @param claimHash          The claim hash.\n     * @param memoryPointer      The memory pointer to the start of the memory region.\n     * @param offset             The offset within the memory region to write the witness hash.\n     */\n    function deriveAndWriteWitnessHash(\n        bytes32 activationTypehash,\n        uint256 idOrIdsHash,\n        bytes32 claimHash,\n        uint256 memoryPointer,\n        uint256 offset\n    ) internal view {\n        assembly (\"memory-safe\") {\n            // Retrieve and cache free memory pointer.\n            let m := mload(0x40)\n\n            // Prepare witness hash data: activationTypehash, activator, idOrIdsHash, & claimHash.\n            mstore(0, activationTypehash)\n            mstore(0x20, caller())\n            mstore(0x40, idOrIdsHash)\n            mstore(0x60, claimHash)\n\n            // Derive activation witness hash and write it to specified memory location.\n            mstore(add(memoryPointer, offset), keccak256(0, 0x80))\n\n            // Restore the free memory pointer and the zero slot.\n            mstore(0x40, m)\n            mstore(0x60, 0)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the CompactDeposit witness hash.\n     * @param calldataOffset The offset of the CompactDeposit calldata.\n     * @return witnessHash   The derived CompactDeposit witness hash.\n     */\n    function deriveCompactDepositWitnessHash(uint256 calldataOffset) internal pure returns (bytes32 witnessHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare the initial fragment of the witness typestring.\n            mstore(m, PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH)\n\n            // Copy lockTag & recipient directly from calldata.\n            // Note that none of these arguments are sanitized; the assumption is that they must\n            // match the signed values anyway, so *should* be fine not to sanitize them but could\n            // optionally check that there are no dirty upper bits on any of them.\n            calldatacopy(add(m, 0x20), calldataOffset, 0x40)\n\n            // Derive the CompactDeposit witness hash from the prepared data.\n            witnessHash := keccak256(m, 0x60)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for inserting the CompactDeposit typestring\n     * (used for deposits that do not involve a compact registration) into memory.\n     * @param memoryLocation The memory pointer to the start of the typestring.\n     */\n    function insertCompactDepositTypestring(uint256 memoryLocation) internal pure {\n        assembly (\"memory-safe\") {\n            // Write the length of the typestring.\n            mstore(memoryLocation, 0x76)\n\n            // Write the data for the typestring.\n            mstore(add(memoryLocation, 0x20), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_ONE)\n            mstore(add(memoryLocation, 0x40), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_TWO)\n            mstore(add(memoryLocation, 0x76), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_FOUR)\n            mstore(add(memoryLocation, 0x60), COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_THREE)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/RegistrationLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\n\n/**\n * @title RegistrationLib\n * @notice Library contract implementing logic for registering compact claim hashes\n * and typehashes and querying for whether given claim hashes and typehashes have\n * been registered.\n */\nlibrary RegistrationLib {\n    using RegistrationLib for address;\n    using EfficiencyLib for uint256;\n    using IdLib for ResetPeriod;\n\n    // keccak256(bytes(\"CompactRegistered(address,bytes32,bytes32)\")).\n    uint256 private constant _COMPACT_REGISTERED_SIGNATURE =\n        0x52dd3aeaf9d70bfcfdd63526e155ba1eea436e7851acf5c950299321c671b927;\n\n    // Storage scope for active registrations:\n    // slot: keccak256(_ACTIVE_REGISTRATIONS_SCOPE ++ sponsor ++ claimHash ++ typehash) => expires.\n    uint256 private constant _ACTIVE_REGISTRATIONS_SCOPE = 0x68a30dd0;\n\n    /**\n     * @notice Internal function for registering a claim hash.\n     * @param sponsor   The account registering the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     */\n    function registerCompact(address sponsor, bytes32 claimHash, bytes32 typehash) internal {\n        uint256 registrationSlot = sponsor.deriveRegistrationSlot(claimHash, typehash);\n        assembly (\"memory-safe\") {\n            // Store 1 (true) in active registration storage slot.\n            sstore(registrationSlot, 1)\n\n            // Emit the CompactRegistered event:\n            //  - topic1: CompactRegistered event signature\n            //  - topic2: sponsor address (sanitized)\n            //  - data: [claimHash, typehash]\n            mstore(0, claimHash)\n            mstore(0x20, typehash)\n            log2(0, 0x40, _COMPACT_REGISTERED_SIGNATURE, shr(0x60, shl(0x60, sponsor)))\n        }\n    }\n\n    /**\n     * @notice Internal function for registering multiple claim hashes in a single call.\n     * @param claimHashesAndTypehashes Array of [claimHash, typehash] pairs for registration.\n     * @return                         Whether all claim hashes were successfully registered.\n     */\n    function registerBatchAsCaller(bytes32[2][] calldata claimHashesAndTypehashes) internal returns (bool) {\n        unchecked {\n            // Retrieve the total number of claim hashes and typehashes to register.\n            uint256 totalClaimHashes = claimHashesAndTypehashes.length;\n\n            // Iterate over each pair of claim hashes and typehashes.\n            for (uint256 i = 0; i < totalClaimHashes; ++i) {\n                // Retrieve the claim hash and typehash from calldata.\n                bytes32[2] calldata claimHashAndTypehash = claimHashesAndTypehashes[i];\n\n                // Register the compact as the caller.\n                msg.sender.registerCompact(claimHashAndTypehash[0], claimHashAndTypehash[1]);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Internal view function for retrieving the timestamp of a registration.\n     * @param sponsor   The account that registered the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     * @return registered Whether the compact has been registered.\n     */\n    function isRegistered(address sponsor, bytes32 claimHash, bytes32 typehash)\n        internal\n        view\n        returns (bool registered)\n    {\n        uint256 registrationSlot = sponsor.deriveRegistrationSlot(claimHash, typehash);\n        assembly (\"memory-safe\") {\n            // Load registration storage slot to get registration status.\n            registered := sload(registrationSlot)\n        }\n    }\n\n    /**\n     * @notice Internal function for consuming (clearing) a registration.\n     * @param sponsor   The account that registered the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     */\n    function consumeRegistrationIfRegistered(address sponsor, bytes32 claimHash, bytes32 typehash)\n        internal\n        returns (bool consumed)\n    {\n        uint256 registrationSlot = sponsor.deriveRegistrationSlot(claimHash, typehash);\n        assembly (\"memory-safe\") {\n            consumed := sload(registrationSlot)\n            if consumed { sstore(registrationSlot, 0) }\n        }\n    }\n\n    /**\n     * @notice Internal function for deriving the registration storage slot for a given claim hash and typehash.\n     * @param sponsor   The account that registered the claim hash.\n     * @param claimHash A bytes32 hash derived from the details of the compact.\n     * @param typehash  The EIP-712 typehash associated with the claim hash.\n     * @return registrationSlot The storage slot for the registration.\n     */\n    function deriveRegistrationSlot(address sponsor, bytes32 claimHash, bytes32 typehash)\n        internal\n        pure\n        returns (uint256 registrationSlot)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the current free memory pointer.\n            let m := mload(0x40)\n\n            // Pack data for deriving active registration storage slot.\n            mstore(add(m, 0x14), sponsor)\n            mstore(m, _ACTIVE_REGISTRATIONS_SCOPE)\n            mstore(add(m, 0x34), claimHash)\n            mstore(add(m, 0x54), typehash)\n\n            // Derive active registration storage slot.\n            registrationSlot := keccak256(add(m, 0x1c), 0x58)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/TransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ConstructorLogic } from \"./ConstructorLogic.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { TransferBenchmarkLib } from \"./TransferBenchmarkLib.sol\";\n\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\n\n/**\n * @title TransferLib\n * @notice Library contract implementing logic for internal functions with\n * low-level shared logic for processing transfers, withdrawals and deposits.\n */\nlibrary TransferLib {\n    using EfficiencyLib for bool;\n    using EfficiencyLib for bytes12;\n    using TransferLib for address;\n    using IdLib for uint256;\n    using SafeTransferLib for address;\n    using TransferBenchmarkLib for address;\n\n    // Storage slot seed for ERC6909 state, used in computing balance slots.\n    uint256 private constant _ERC6909_MASTER_SLOT_SEED = 0xedcaa89a82293940;\n\n    // keccak256(bytes(\"Transfer(address,address,address,uint256,uint256)\")).\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859;\n\n    /**\n     * @notice Internal function for transferring ERC6909 tokens between accounts. Updates\n     * both balances, checking for overflow and insufficient balance. This function bypasses\n     * transfer hooks and allowance checks as it is only called in trusted contexts. Emits\n     * a Transfer event.\n     * @param from   The account to transfer tokens from.\n     * @param to     The account to transfer tokens to.\n     * @param id     The ERC6909 token identifier to transfer.\n     * @param amount The amount of tokens to transfer.\n     */\n    function release(address from, address to, uint256 id, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Compute the sender's balance slot using the master slot seed.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n\n            // Load from sender's current balance.\n            let fromBalance := sload(fromBalanceSlot)\n\n            // Revert if amount is zero or exceeds balance.\n            if or(iszero(amount), gt(amount, fromBalance)) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Subtract from current balance and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n\n            // Compute the recipient's balance slot and update balance.\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Store the recipient's updated balance.\n            sstore(toBalanceSlot, toBalanceAfter)\n\n            // Emit the Transfer event:\n            //  - topic1: Transfer event signature\n            //  - topic2: sender address (sanitized)\n            //  - topic3: recipient address (sanitized)\n            //  - topic4: token id\n            //  - data: [caller, amount]\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(0x60, shl(0x60, from)), shr(0x60, shl(0x60, to)), id)\n        }\n    }\n\n    /**\n     * @notice Internal function for burning ERC6909 tokens and withdrawing the underlying\n     * tokens. Updates the sender's balance and transfers either native tokens or ERC20\n     * tokens to the recipient. For ERC20 withdrawals, the actual amount burned is derived\n     * from the balance change. Ensure that a reentrancy guard has been set before calling.\n     * Emits a Transfer event. Note that if the withdrawal fails, a direct release of the\n     * 6909 tokens in question will be performed instead.\n     * @param from   The account to burn tokens from.\n     * @param to     The account to send underlying tokens to.\n     * @param id     The ERC6909 token identifier to burn.\n     * @param amount The amount of tokens to burn and withdraw.\n     * @param strict A boolean indicating whether or not to insist that the withdrawal\n     * succeeds or to fall back to a 6909 transfer.\n     */\n    function withdraw(address from, address to, uint256 id, uint256 amount, bool strict) internal {\n        // Derive the underlying token from the id of the resource lock.\n        address token = id.toAddress();\n\n        // Handle native token withdrawals directly.\n        bool withdrawalSucceeded;\n        uint256 postWithdrawalAmount = amount;\n        if (token == address(0)) {\n            // Attempt to transfer the ETH using half of available gas.\n            assembly (\"memory-safe\") {\n                withdrawalSucceeded := call(div(gas(), sub(2, strict)), to, amount, codesize(), 0, codesize(), 0)\n            }\n        } else {\n            // For ERC20s, track balance change to determine actual withdrawal amount.\n            uint256 initialBalance = token.balanceOf(address(this));\n\n            // Attempt to transfer the tokens using half of available gas.\n            assembly (\"memory-safe\") {\n                mstore(0x14, to) // Store the `to` argument.\n                mstore(0x34, amount) // Store the `amount` argument.\n                mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n\n                // Perform the transfer using half of available gas & examine the call for failure.\n                withdrawalSucceeded :=\n                    and( // The arguments of `and` are evaluated from right to left.\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(div(gas(), sub(2, strict)), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n\n                mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n            }\n\n            // Check balance after performing the withdrawal.\n            uint256 terminalBalance = token.balanceOf(address(this));\n\n            assembly (\"memory-safe\") {\n                // Consider the withdrawal as having succeeded if any amount was withdrawn.\n                withdrawalSucceeded := and(withdrawalSucceeded, lt(terminalBalance, initialBalance))\n\n                // Derive the realized withdrawal amount (with a minimum value of zero).\n                postWithdrawalAmount := mul(withdrawalSucceeded, sub(initialBalance, terminalBalance))\n            }\n        }\n\n        // Burn the 6909 tokens if the withdrawal succeeded.\n        if (withdrawalSucceeded) {\n            from.burn(id, postWithdrawalAmount);\n        } else {\n            if (strict) {\n                // revert ForcedWithdrawalFailed();\n                assembly (\"memory-safe\") {\n                    mstore(0, 0x580d4e5e)\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // Ensure that sufficient additional gas stipend has been supplied.\n            token.ensureBenchmarkExceeded();\n\n            // Transfer original amount of associated 6909 tokens directly.\n            from.release(to, id, amount);\n        }\n    }\n\n    /**\n     * @notice Internal function for burning ERC6909 tokens. Emits a Transfer event.\n     * @param from   The account to burn tokens from.\n     * @param id     The ERC6909 token identifier to burn.\n     * @param amount The amount of tokens to burn.\n     */\n    function burn(address from, uint256 id, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Compute the sender's balance slot using the master slot seed.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n\n            // Load from sender's current balance.\n            let fromBalance := sload(fromBalanceSlot)\n\n            // Revert if insufficient balance.\n            if or(iszero(amount), gt(amount, fromBalance)) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Subtract from current balance and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n\n            // Emit the Transfer event:\n            //  - topic1: Transfer event signature\n            //  - topic2: sender address (sanitized)\n            //  - topic3: address(0) signifying a burn\n            //  - topic4: token id\n            //  - data: [caller, amount]\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(0x60, shl(0x60, from)), 0, id)\n        }\n    }\n\n    /**\n     * @notice Internal function for minting ERC6909 tokens. Updates the recipient's balance,\n     * checking for overflow, and emits a Transfer event. This function bypasses transfer\n     * hooks and allowance checks as it is only called in trusted deposit contexts.\n     * @param to     The address to mint tokens to.\n     * @param id     The ERC6909 token identifier to mint.\n     * @param amount The amount of tokens to mint.\n     */\n    function deposit(address to, uint256 id, uint256 amount) internal {\n        assembly (\"memory-safe\") {\n            // Compute the recipient's balance slot using the master slot seed.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n\n            // Load current balance and compute new balance.\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n\n            // Revert on balance overflow.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Store the updated balance.\n            sstore(toBalanceSlot, toBalanceAfter)\n\n            // Emit the Transfer event:\n            // - topic1: Transfer event signature\n            // - topic2: address(0) signifying a mint\n            // - topic3: recipient address (sanitized)\n            // - topic4: token id\n            // - data: [caller, amount]\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0, 0x40, _TRANSFER_EVENT_SIGNATURE, 0, shr(0x60, shl(0x60, to)), id)\n        }\n    }\n\n    /**\n     * @notice Internal function for handling various token operation flows based on the\n     * respective lock tags. Determines whether to withdraw, release, or transfer tokens.\n     * @param from     The address from which the operation originates.\n     * @param id       The ERC6909 token identifier to operate on.\n     * @param claimant The identifier representing the claimant entity.\n     * @param amount   The amount of tokens involved in the operation.\n     */\n    function performOperation(address from, uint256 id, uint256 claimant, uint256 amount) internal {\n        // Extract lock tags from both token ID and claimant.\n        bytes12 lockTag = id.toLockTag();\n        bytes12 claimantLockTag = claimant.toLockTag();\n\n        // Extract the recipient address referenced by the claimant.\n        address recipient = claimant.toAddress();\n\n        if (claimantLockTag.isZero()) {\n            // Case 1: Zero lock tag - perform a standard withdrawal operation\n            // to the recipient address referenced by the claimant.\n            from.withdraw(recipient, id, amount, false);\n        } else if (claimantLockTag == lockTag) {\n            // Case 2: Matching lock tags - transfer tokens to the recipient address\n            // referenced by the claimant.\n            from.release(recipient, id, amount);\n        } else {\n            // Case 3: Different lock tags - convert the resource lock, burning\n            // tokens and minting the same amount with the new token ID to the\n            // recipient address referenced by the claimant.\n\n            // Create a new token ID using the original ID with claimant's lock tag.\n            uint256 claimantId = id.withReplacedLockTag(claimantLockTag);\n\n            // Verify the allocator ID is registered.\n            claimantId.toAllocatorIdIfRegistered();\n\n            // Burn tokens from the original context.\n            from.burn(id, amount);\n\n            // Deposit tokens to the claimant's address with the new token ID.\n            recipient.deposit(claimantId, amount);\n        }\n    }\n}\n"},"lib/the-compact/src/lib/AllocatorLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IAllocator } from \"../interfaces/IAllocator.sol\";\n\nimport { IdLib } from \"./IdLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\n\n/**\n * @title AllocatorLib\n * @notice Library contract implementing logic for interacting with allocators, specifically\n * for checking for authorization during claim processing via a low-level call.\n */\nlibrary AllocatorLib {\n    using IdLib for uint256;\n    using EfficiencyLib for bool;\n\n    // bytes4(keccak256(\"authorizeClaim(bytes32,address,address,uint256,uint256,uint256[2][],bytes)\")).\n    uint32 private constant _AUTHORIZE_CLAIM_SELECTOR = 0x7bb023f7;\n    uint256 private constant _AUTHORIZE_CLAIM_IDS_AND_AMOUNTS_CALLDATA_POINTER = 0xe0;\n\n    /**\n     * @notice Internal function that calls an allocator's authorizeClaim function to validate\n     * that they have authorized the claim and that they are able to perform their own processing\n     * associated with that claim. Performs a low-level call to the allocator contract and verifies\n     * the response.\n     * @param allocator     The address of the allocator to call.\n     * @param claimHash     The message hash representing the claim.\n     * @param sponsor       The account to source the tokens from.\n     * @param nonce         A parameter to enforce replay protection, scoped to allocator.\n     * @param expires       The time at which the claim expires.\n     * @param idsAndAmounts The allocated token IDs and amounts.\n     * @param allocatorData Arbitrary data provided by the arbiter.\n     */\n    function callAuthorizeClaim(\n        address allocator,\n        bytes32 claimHash,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        uint256[2][] memory idsAndAmounts,\n        bytes calldata allocatorData\n    ) internal {\n        assembly (\"memory-safe\") {\n            // Sanitize sponsor.\n            sponsor := shr(0x60, shl(0x60, sponsor))\n\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Get length of idsAndAmounts array, both in elements and as data.\n            let totalIdsAndAmounts := mload(idsAndAmounts)\n            let totalIdsAndAmountsDataLength := shl(6, totalIdsAndAmounts)\n\n            // Prepare fixed-location components of calldata.\n            mstore(m, _AUTHORIZE_CLAIM_SELECTOR)\n            mstore(add(m, 0x20), claimHash)\n            mstore(add(m, 0x40), caller())\n            mstore(add(m, 0x60), sponsor)\n            mstore(add(m, 0x80), nonce)\n            mstore(add(m, 0xa0), expires)\n            mstore(add(m, 0xc0), _AUTHORIZE_CLAIM_IDS_AND_AMOUNTS_CALLDATA_POINTER)\n            mstore(add(m, 0xe0), add(totalIdsAndAmountsDataLength, 0x100))\n            mstore(add(m, 0x100), totalIdsAndAmounts)\n\n            {\n                // Copy each element from idsAndAmounts array in memory.\n                let dstStart := add(m, 0x120)\n                let totalIdsAndAmountsTimesOneWord := shl(5, totalIdsAndAmounts)\n                for { let i := 0 } lt(i, totalIdsAndAmountsTimesOneWord) { i := add(i, 0x20) } {\n                    let dstPos := add(dstStart, shl(1, i))\n                    let srcPos := mload(add(idsAndAmounts, add(i, 0x20)))\n                    mstore(dstPos, mload(srcPos))\n                    mstore(add(dstPos, 0x20), mload(add(srcPos, 0x20)))\n                }\n\n                // Copy allocator data from calldata.\n                let allocatorDataMemoryOffset := add(dstStart, totalIdsAndAmountsDataLength)\n                mstore(allocatorDataMemoryOffset, allocatorData.length)\n                calldatacopy(add(allocatorDataMemoryOffset, 0x20), allocatorData.offset, allocatorData.length)\n            }\n\n            // Ensure sure initial scratch space is cleared as an added precaution.\n            mstore(0, 0)\n\n            // Perform call to allocator and write response to scratch space.\n            let success :=\n                call(\n                    gas(),\n                    allocator,\n                    0,\n                    add(m, 0x1c),\n                    add(0x124, add(totalIdsAndAmountsDataLength, allocatorData.length)),\n                    0,\n                    0x20\n                )\n\n            // Revert if the required magic value was not received back or really huge idsAndAmounts was supplied.\n            if or(gt(totalIdsAndAmounts, 0xffffffff), iszero(eq(mload(0), shl(224, _AUTHORIZE_CLAIM_SELECTOR)))) {\n                // Bubble up if the call failed and there's data. Note that remaining gas is not evaluated before\n                // copying the returndata buffer into memory. Out-of-gas errors can be triggered via revert bombing.\n                if iszero(or(success, iszero(returndatasize()))) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert InvalidAllocation(allocator)\n                mstore(0, 0x2ce89d2a)\n                mstore(0x20, shr(0x60, shl(0x60, allocator)))\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/lib/HashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { TransferComponent, Component, ComponentsById, BatchClaimComponent } from \"../types/Components.sol\";\nimport {\n    COMPACT_TYPEHASH,\n    COMPACT_TYPESTRING_FRAGMENT_ONE,\n    COMPACT_TYPESTRING_FRAGMENT_TWO,\n    COMPACT_TYPESTRING_FRAGMENT_THREE,\n    COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    BATCH_COMPACT_TYPEHASH,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    BATCH_COMPACT_TYPESTRING_FRAGMENT_SIX,\n    LOCK_TYPEHASH,\n    MULTICHAIN_COMPACT_TYPEHASH,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_ONE,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_TWO,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_THREE,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FOUR,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FIVE,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SIX,\n    MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SEVEN,\n    ELEMENT_TYPEHASH,\n    PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH\n} from \"../types/EIP712Types.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { TransferFunctionCastLib } from \"./TransferFunctionCastLib.sol\";\n\n/**\n * @title HashLib\n * @notice Library contract implementing logic for deriving hashes as part of processing\n * claims, allocated transfers, and withdrawals, including deriving typehashes when\n * witness data is utilized and qualification hashes when claims have been qualified by\n * the allocator.\n */\nlibrary HashLib {\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using HashLib for uint256;\n    using HashLib for uint256[2][];\n    using HashLib for AllocatedBatchTransfer;\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a transfer or withdrawal.\n     * @param transfer     An AllocatedTransfer struct containing the transfer details.\n     * @return messageHash The EIP-712 compliant message hash.\n     */\n    function toTransferMessageHash(AllocatedTransfer calldata transfer) internal view returns (bytes32 messageHash) {\n        // Declare variables for tracking, total amount, current amount, and errors.\n        uint256 amount = 0;\n        uint256 currentAmount;\n        uint256 errorBuffer;\n\n        // Navigate to the components array in calldata.\n        Component[] calldata recipients = transfer.recipients;\n\n        // Retrieve the length of the array.\n        uint256 totalRecipients = recipients.length;\n\n        unchecked {\n            // Iterate over each component.\n            for (uint256 i = 0; i < totalRecipients; ++i) {\n                // Retrieve the current amount of the component.\n                currentAmount = recipients[i].amount;\n\n                // Add current amount to total amount and check for overflow.\n                amount += currentAmount;\n                errorBuffer |= (amount < currentAmount).asUint256();\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Revert if an arithmetic overflow was detected.\n            if errorBuffer {\n                // Revert Panic(0x11) (arithmetic overflow)\n                mstore(0, 0x4e487b71)\n                mstore(0x20, 0x11)\n                revert(0x1c, 0x24)\n            }\n\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare initial components of message data: typehash, arbiter, & sponsor.\n            mstore(m, COMPACT_TYPEHASH)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n            mstore(add(m, 0x40), caller()) // sponsor: msg.sender\n\n            // Subsequent data copied from calldata: nonce, expires, lockTag & token.\n            // Deconstruct id into lockTag + token by inserting an empty word.\n            calldatacopy(add(m, 0x60), add(transfer, 0x20), 0x4c)\n            mstore(add(m, 0xc0), calldataload(add(transfer, 0x60))) // token\n            mstore(add(m, 0xac), 0) // empty word between lockTag & token\n\n            // Prepare final component of message data: aggregate amount.\n            mstore(add(m, 0xe0), amount)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0x100)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch transfer or withdrawal.\n     * @param transfer     An AllocatedBatchTransfer struct containing the transfer details.\n     * @return messageHash The EIP-712 compliant message hash.\n     */\n    function toBatchTransferMessageHash(AllocatedBatchTransfer calldata transfer) internal view returns (bytes32) {\n        // Navigate to the transfer components array in calldata.\n        ComponentsById[] calldata transfers = transfer.transfers;\n\n        // Retrieve the length of the commitments array.\n        uint256 totalLocks = transfers.length;\n\n        // Allocate working memory for hashing operations.\n        (uint256 ptr, uint256 hashesPtr) = totalLocks.allocateCommitmentsHashingMemory();\n\n        // Declare a buffer for arithmetic errors.\n        uint256 errorBuffer;\n\n        unchecked {\n            // Cache lock-specific data start memory pointer location.\n            uint256 lockDataStart = ptr + 0x20;\n\n            // Iterate over each transfer component.\n            for (uint256 i = 0; i < totalLocks; ++i) {\n                // Navigate to the current transfer component.\n                ComponentsById calldata transferComponent = transfers[i];\n\n                // Retrieve the id from the current transfer component.\n                uint256 id = transferComponent.id;\n\n                // Declare a variable for the aggregate amount.\n                uint256 amount = 0;\n\n                // Declare a variable for the current amount.\n                uint256 singleAmount;\n\n                // Navigate to the portions array in the current transfer component.\n                Component[] calldata portions = transferComponent.portions;\n\n                // Retrieve the length of the portions array.\n                uint256 portionsLength = portions.length;\n\n                // Iterate over each portion.\n                for (uint256 j = 0; j < portionsLength; ++j) {\n                    // Retrieve the current amount of the portion.\n                    singleAmount = portions[j].amount;\n\n                    // Add current amount to aggregate amount and check for overflow.\n                    amount += singleAmount;\n                    errorBuffer |= (amount < singleAmount).asUint256();\n                }\n\n                assembly (\"memory-safe\") {\n                    // Copy data on aggregate committed locks from derived values.\n                    // Deconstruct id into lockTag + token by inserting an empty word.\n                    mstore(lockDataStart, id) // lockTag\n                    mstore(add(lockDataStart, 0x20), id) // token\n                    mstore(add(lockDataStart, 0x0c), 0) // empty word between lockTag & token\n                    mstore(add(lockDataStart, 0x40), amount)\n\n                    // Hash the prepared elements and store at current position.\n                    mstore(add(hashesPtr, shl(5, i)), keccak256(ptr, 0x80))\n                }\n            }\n        }\n\n        // Declare a variable for the commitments hash.\n        uint256 commitmentsHash;\n        assembly (\"memory-safe\") {\n            // Revert if an arithmetic overflow was detected.\n            if errorBuffer {\n                // Revert Panic(0x11) (arithmetic overflow)\n                mstore(0, 0x4e487b71)\n                mstore(0x20, 0x11)\n                revert(0x1c, 0x24)\n            }\n\n            // Derive the commitments hash using the prepared lock hashes data.\n            commitmentsHash := keccak256(hashesPtr, shl(5, totalLocks))\n        }\n\n        // Derive message hash from transfer data and commitments hash.\n        return toBatchTransferMessageHashUsingCommitmentsHash(transfer, commitmentsHash);\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch transfer or withdrawal once a commitments hash is available.\n     * @param transfer        An AllocatedBatchTransfer struct containing the transfer details.\n     * @param commitmentsHash A hash of the commitments array.\n     * @return messageHash    The EIP-712 compliant message hash.\n     */\n    function toBatchTransferMessageHashUsingCommitmentsHash(\n        AllocatedBatchTransfer calldata transfer,\n        uint256 commitmentsHash\n    ) internal view returns (bytes32 messageHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare initial components of message data: typehash, arbiter, & sponsor.\n            mstore(m, BATCH_COMPACT_TYPEHASH)\n            mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n            mstore(add(m, 0x40), caller()) // sponsor: msg.sender\n\n            // Next data segment copied from calldata: nonce & expires.\n            mstore(add(m, 0x60), calldataload(add(transfer, 0x20))) // nonce\n            mstore(add(m, 0x80), calldataload(add(transfer, 0x40))) // expires\n\n            // Prepare final component of message data: commitmentsHash.\n            mstore(add(m, 0xa0), commitmentsHash)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xc0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a claim with or without a witness.\n     * @param claimPointer               Pointer to the claim location in calldata.\n     * @return messageHash        The EIP-712 compliant message hash.\n     * @return typehash           The EIP-712 typehash.\n     */\n    function toClaimHash(uint256 claimPointer) internal view returns (bytes32 messageHash, bytes32 typehash) {\n        assembly (\"memory-safe\") {\n            for { } 1 { } {\n                // Retrieve the free memory pointer; memory will be left dirtied.\n                let m := mload(0x40)\n\n                // Derive the pointer to the witness typestring.\n                let witnessTypestringPtr := add(claimPointer, calldataload(add(claimPointer, 0xc0)))\n\n                // Retrieve the length of the witness typestring.\n                let witnessTypestringLength := calldataload(witnessTypestringPtr)\n\n                if iszero(witnessTypestringLength) {\n                    // Prepare initial components of message data: typehash & arbiter.\n                    mstore(m, COMPACT_TYPEHASH)\n                    mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n                    // Clear sponsor memory location as an added precaution so that\n                    // upper bits of sponsor do not need to be copied from calldata.\n                    mstore(add(m, 0x40), 0)\n\n                    // Next data segment copied from calldata: sponsor, nonce & expires.\n                    calldatacopy(add(m, 0x4c), add(claimPointer, 0x4c), 0x54)\n\n                    // Prepare final components of message data: lockTag, token and amount.\n                    // Deconstruct id into lockTag + token by inserting an empty word.\n                    mstore(add(m, 0xa0), calldataload(add(claimPointer, 0xe0))) // lockTag\n                    mstore(add(m, 0xac), 0) // last 20 bytes of lockTag and first 12 of token\n                    calldatacopy(add(m, 0xcc), add(claimPointer, 0xec), 0x34) // token + amount\n\n                    // Derive the message hash from the prepared data.\n                    messageHash := keccak256(m, 0x100)\n\n                    // Set Compact typehash\n                    typehash := COMPACT_TYPEHASH\n\n                    break\n                }\n\n                // Prepare first component of typestring from five one-word fragments.\n                mstore(m, COMPACT_TYPESTRING_FRAGMENT_ONE)\n                mstore(add(m, 0x20), COMPACT_TYPESTRING_FRAGMENT_TWO)\n                mstore(add(m, 0x40), COMPACT_TYPESTRING_FRAGMENT_THREE)\n                mstore(add(m, 0x6b), COMPACT_TYPESTRING_FRAGMENT_FIVE)\n                mstore(add(m, 0x60), COMPACT_TYPESTRING_FRAGMENT_FOUR)\n\n                // Copy remaining typestring data from calldata to memory.\n                let witnessStart := add(m, 0x8b)\n                calldatacopy(witnessStart, add(0x20, witnessTypestringPtr), witnessTypestringLength)\n\n                // Prepare closing \")\" parenthesis at the very end of the memory region.\n                mstore8(add(witnessStart, witnessTypestringLength), 0x29)\n\n                // Derive the typehash from the prepared data.\n                typehash := keccak256(m, add(0x8c, witnessTypestringLength))\n\n                // Prepare initial components of message data: typehash & arbiter.\n                mstore(m, typehash)\n                mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n                // Clear sponsor memory location as an added precaution so that\n                // upper bits of sponsor do not need to be copied from calldata.\n                mstore(add(m, 0x40), 0)\n\n                // Next data segment copied from calldata: sponsor, nonce, expires.\n                calldatacopy(add(m, 0x4c), add(claimPointer, 0x4c), 0x54)\n\n                // Prepare final components of message data: lockTag, token, amount & witness.\n                // Deconstruct id into lockTag + token by inserting an empty word.\n                mstore(add(m, 0xa0), calldataload(add(claimPointer, 0xe0))) // lockTag\n                mstore(add(m, 0xac), 0) // last 20 bytes of lockTag and first 12 of token\n                calldatacopy(add(m, 0xcc), add(claimPointer, 0xec), 0x34) // token + amount\n\n                mstore(add(m, 0x100), calldataload(add(claimPointer, 0xa0))) // witness\n\n                // Derive the message hash from the prepared data.\n                messageHash := keccak256(m, 0x120)\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a batch claim with or without a witness.\n     * @param claimPointer    Pointer to the claim location in calldata.\n     * @param commitmentsHash The EIP-712 hash of the Lock[] commitments array.\n     * @return messageHash    The EIP-712 compliant message hash.\n     * @return typehash       The EIP-712 typehash.\n     */\n    function toBatchClaimHash(uint256 claimPointer, uint256 commitmentsHash)\n        internal\n        view\n        returns (bytes32 messageHash, bytes32 typehash)\n    {\n        assembly (\"memory-safe\") {\n            for { } 1 { } {\n                // Retrieve the free memory pointer; memory will be left dirtied.\n                let m := mload(0x40)\n\n                // Derive the pointer to the witness typestring.\n                let witnessTypestringPtr := add(claimPointer, calldataload(add(claimPointer, 0xc0)))\n\n                // Retrieve the length of the witness typestring.\n                let witnessTypestringLength := calldataload(witnessTypestringPtr)\n\n                if iszero(witnessTypestringLength) {\n                    // Prepare initial components of message data: typehash & arbiter.\n                    mstore(m, BATCH_COMPACT_TYPEHASH)\n                    mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n                    // Clear sponsor memory location as an added precaution so that\n                    // upper bits of sponsor do not need to be copied from calldata.\n                    mstore(add(m, 0x40), 0)\n\n                    // Next data segment copied from calldata: sponsor, nonce, expires.\n                    calldatacopy(add(m, 0x4c), add(claimPointer, 0x4c), 0x54)\n\n                    // Prepare final component of message data: commitmentsHash.\n                    mstore(add(m, 0xa0), commitmentsHash)\n\n                    // Derive the message hash from the prepared data.\n                    messageHash := keccak256(m, 0xc0)\n\n                    // Set BatchCompact typehash\n                    typehash := BATCH_COMPACT_TYPEHASH\n\n                    break\n                }\n\n                // Prepare first component of typestring from six one-word fragments.\n                mstore(m, BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE)\n                mstore(add(m, 0x20), BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO)\n                mstore(add(m, 0x40), BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE)\n                mstore(add(m, 0x60), BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n                mstore(add(m, 0x88), BATCH_COMPACT_TYPESTRING_FRAGMENT_SIX)\n                mstore(add(m, 0x80), BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE)\n\n                // Copy remaining typestring data from calldata to memory.\n                let witnessStart := add(m, 0xa8)\n                calldatacopy(witnessStart, add(0x20, witnessTypestringPtr), witnessTypestringLength)\n\n                // Prepare closing \")\" parenthesis at the very end of the memory region.\n                mstore8(add(witnessStart, witnessTypestringLength), 0x29)\n\n                // Derive the typehash from the prepared data.\n                typehash := keccak256(m, add(0xa9, witnessTypestringLength))\n\n                // Prepare initial components of message data: typehash & arbiter.\n                mstore(m, typehash)\n                mstore(add(m, 0x20), caller()) // arbiter: msg.sender\n\n                // Clear sponsor memory location as an added precaution so that\n                // upper bits of sponsor do not need to be copied from calldata.\n                mstore(add(m, 0x40), 0)\n\n                // Next data segment copied from calldata: sponsor, nonce, expires.\n                calldatacopy(add(m, 0x4c), add(claimPointer, 0x4c), 0x54)\n\n                // Prepare final components of message data: commitmentsHash & witness.\n                mstore(add(m, 0xa0), commitmentsHash)\n                mstore(add(m, 0xc0), calldataload(add(claimPointer, 0xa0))) // witness\n\n                // Derive the message hash from the prepared data.\n                messageHash := keccak256(m, 0xe0)\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a multichain claim with or without a witness.\n     * @param claim                     Pointer to the claim location in calldata.\n     * @param additionalOffset          Additional offset from claim pointer to ID from most compact case.\n     * @param elementTypehash           The element typehash.\n     * @param multichainCompactTypehash The multichain compact typehash.\n     * @param commitmentsHash           The EIP-712 hash of the Lock[] commitments array.\n     * @return messageHash              The EIP-712 compliant message hash.\n     */\n    function toMultichainClaimMessageHash(\n        uint256 claim,\n        uint256 additionalOffset,\n        bytes32 elementTypehash,\n        bytes32 multichainCompactTypehash,\n        uint256 commitmentsHash\n    ) internal view returns (bytes32 messageHash) {\n        // Derive the element hash for the current element.\n        bytes32 elementHash = claim.toElementHash(elementTypehash, commitmentsHash);\n\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Write the derived element hash to memory.\n            mstore(m, elementHash)\n\n            // Derive the pointer to the additional chains and retrieve the length.\n            let additionalChainsPtr := add(claim, calldataload(add(add(claim, additionalOffset), 0xa0)))\n            let additionalChainsLength := shl(5, calldataload(additionalChainsPtr))\n\n            // Copy the element hashes in the additional chains array from calldata to memory.\n            calldatacopy(add(m, 0x20), add(0x20, additionalChainsPtr), additionalChainsLength)\n\n            // Derive hash of element hashes from prepared data and write it to memory.\n            mstore(add(m, 0x80), keccak256(m, add(0x20, additionalChainsLength)))\n\n            // Prepare next component of message data: multichain compact typehash.\n            mstore(m, multichainCompactTypehash)\n\n            // Clear sponsor memory location as an added precaution so that\n            // upper bits of sponsor do not need to be copied from calldata.\n            mstore(add(m, 0x20), 0)\n\n            // Next data segment copied from calldata: sponsor, nonce, expires.\n            calldatacopy(add(m, 0x2c), add(claim, 0x4c), 0x54)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xa0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * an exogenous multichain claim with or without a witness.\n     * @param claim                     Pointer to the claim location in calldata.\n     * @param additionalOffset          Additional offset from claim pointer to ID from most compact case.\n     * @param elementTypehash           The element typehash.\n     * @param multichainCompactTypehash The multichain compact typehash.\n     * @param commitmentsHash           The EIP-712 hash of the Lock[] commitments array.\n     * @return messageHash              The EIP-712 compliant message hash.\n     */\n    function toExogenousMultichainClaimMessageHash(\n        uint256 claim,\n        uint256 additionalOffset,\n        bytes32 elementTypehash,\n        bytes32 multichainCompactTypehash,\n        uint256 commitmentsHash\n    ) internal view returns (bytes32 messageHash) {\n        // Derive the element hash for the current element.\n        bytes32 elementHash = claim.toElementHash(elementTypehash, commitmentsHash);\n\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Derive the pointer to the additional chains and retrieve the length.\n            let claimWithAdditionalOffset := add(claim, additionalOffset)\n            let additionalChainsPtr := add(claim, calldataload(add(claimWithAdditionalOffset, 0xa0)))\n\n            // Retrieve the length of the additional chains array.\n            let additionalChainsLength := shl(5, calldataload(additionalChainsPtr))\n\n            // Retrieve the chain index from calldata.\n            let chainIndex := shl(5, calldataload(add(claimWithAdditionalOffset, 0xc0)))\n\n            // Initialize an offset indicating whether a matching chain index has been located.\n            let extraOffset := 0\n\n            // Move the additional chains pointer forward by a word to begin with data segment.\n            additionalChainsPtr := add(0x20, additionalChainsPtr)\n\n            // Iterate over the additional chains array and store each element hash in memory.\n            for { let i := 0 } lt(i, additionalChainsLength) { i := add(i, 0x20) } {\n                mstore(add(add(m, i), extraOffset), calldataload(add(additionalChainsPtr, i)))\n                // If current index matches chain index, store derived hash and increment offset.\n                if eq(i, chainIndex) {\n                    extraOffset := 0x20\n                    mstore(add(m, add(i, extraOffset)), elementHash)\n                }\n            }\n\n            // Ensure provided chain index & additional chains array applied the current element.\n            if iszero(extraOffset) {\n                // Revert ChainIndexOutOfRange()\n                mstore(0, 0x71515b9a)\n                revert(0x1c, 0x04)\n            }\n\n            // Derive the hash of the element hashes from the prepared data and write it to memory.\n            mstore(add(m, 0x80), keccak256(m, add(0x20, additionalChainsLength)))\n\n            // Prepare next component of message data: multichain compact typehash.\n            mstore(m, multichainCompactTypehash)\n\n            // Clear sponsor memory location as an added precaution so that\n            // upper bits of sponsor do not need to be copied from calldata.\n            mstore(add(m, 0x20), 0)\n\n            // Next data segment copied from calldata: sponsor, nonce, expires.\n            calldatacopy(add(m, 0x2c), add(claim, 0x4c), 0x54)\n\n            // Derive the message hash from the prepared data.\n            messageHash := keccak256(m, 0xa0)\n        }\n    }\n\n    /**\n     * @notice Internal view function for deriving the EIP-712 message hash for\n     * a specific element on a multichain claim with or without a witness.\n     * @param claim                     Pointer to the claim location in calldata.\n     * @param elementTypehash           The element typehash.\n     * @param commitmentsHash           The EIP-712 hash of the Lock[] commitments array.\n     * @return elementHash              The EIP-712 compliant element hash.\n     */\n    function toElementHash(uint256 claim, bytes32 elementTypehash, uint256 commitmentsHash)\n        internal\n        view\n        returns (bytes32 elementHash)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare data: element typehash, arbiter, chainid, commitmentsHash, & witness.\n            mstore(m, elementTypehash)\n            mstore(add(m, 0x20), caller()) // arbiter\n            mstore(add(m, 0x40), chainid())\n            mstore(add(m, 0x60), commitmentsHash)\n            mstore(add(m, 0x80), calldataload(add(claim, 0xa0))) // witness\n\n            // Derive the element hash from the prepared data and write it to memory.\n            // Omit the witness if the default \"no-witness\" typehash is provided.\n            elementHash := keccak256(m, add(0x80, shl(5, iszero(eq(elementTypehash, ELEMENT_TYPEHASH)))))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the EIP-712 typehashes for\n     * multichain claims with or without a witness.\n     * @param claimPointer                      Pointer to the claim location in calldata.\n     * @return elementTypehash           The element typehash.\n     * @return multichainCompactTypehash The multichain compact typehash.\n     */\n    function toMultichainTypehashes(uint256 claimPointer)\n        internal\n        pure\n        returns (bytes32 elementTypehash, bytes32 multichainCompactTypehash)\n    {\n        assembly (\"memory-safe\") {\n            for { } 1 { } {\n                // Retrieve the free memory pointer; memory will be left dirtied.\n                let m := mload(0x40)\n\n                // Derive the pointer to the witness typestring and retrieve the length.\n                let witnessTypestringPtr := add(claimPointer, calldataload(add(claimPointer, 0xc0)))\n                let witnessTypestringLength := calldataload(witnessTypestringPtr)\n\n                if iszero(witnessTypestringLength) {\n                    elementTypehash := ELEMENT_TYPEHASH\n                    multichainCompactTypehash := MULTICHAIN_COMPACT_TYPEHASH\n\n                    break\n                }\n                // Prepare the first five fragments of the multichain compact typehash.\n                mstore(m, MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_ONE)\n                mstore(add(m, 0x20), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_TWO)\n                mstore(add(m, 0x40), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_THREE)\n                mstore(add(m, 0x60), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FOUR)\n                mstore(add(m, 0x80), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FIVE)\n                mstore(add(m, 0xb8), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SEVEN)\n                mstore(add(m, 0xa0), MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SIX)\n\n                // Copy remaining witness typestring from calldata to memory.\n                let witnessStart := add(m, 0xd8)\n                calldatacopy(witnessStart, add(0x20, witnessTypestringPtr), witnessTypestringLength)\n\n                // Prepare closing \")\" parenthesis at the very end of the memory region.\n                mstore8(add(witnessStart, witnessTypestringLength), 0x29)\n\n                // Derive the element typehash and multichain compact typehash from the prepared data.\n                elementTypehash := keccak256(add(m, 0x53), add(0x86, witnessTypestringLength))\n                multichainCompactTypehash := keccak256(m, add(0xd9, witnessTypestringLength))\n                break\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the EIP-712 message hash for\n     * a commitments array when the claim in question contains a single lock.\n     * @param claim            Pointer to the claim location in calldata.\n     * @return commitmentsHash The EIP-712 hash of the Lock[] commitments array.\n     */\n    function toCommitmentsHashFromSingleLock(uint256 claim) internal pure returns (uint256 commitmentsHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Place the lock typehash into the start of memory.\n            mstore(m, LOCK_TYPEHASH)\n\n            // Deconstruct id into lockTag + token by inserting an empty word.\n            mstore(add(m, 0x20), calldataload(add(claim, 0xe0))) // lockTag\n            mstore(add(m, 0x2c), 0) // empty word between lockTag & token\n            calldatacopy(add(m, 0x4c), add(claim, 0xec), 0x34) // token & amount\n\n            // Derive first lock commitment hash and place in scratch space.\n            mstore(0, keccak256(m, 0x80))\n\n            // Hash again to derive commitmentsHash.\n            commitmentsHash := keccak256(0, 0x20)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the commitments hash of a provided\n     * idsAndAmounts array.\n     * @param idsAndAmounts      An array of ids and amounts.\n     * @param replacementAmounts An optional array of replacement amounts.\n     * @return commitmentsHash   The EIP-712 hash of the Lock[] commitments array.\n     * @dev This function expects that the calldata of idsAndAmounts will have bounds\n     * checked elsewhere; using it without this check occurring elsewhere can result in\n     * erroneous hash values. This function also expects that replacementAmounts.length\n     * equals idsAndAmounts.length and will break if the invariant is not upheld.\n     */\n    function toCommitmentsHash(uint256[2][] calldata idsAndAmounts, uint256[] memory replacementAmounts)\n        internal\n        pure\n        returns (bytes32 commitmentsHash)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let ptr := mload(0x40)\n\n            // Temporarily allocate four words of memory.\n            let hashesPtr := add(ptr, 0x80)\n\n            // Write lock typehash to first word of memory.\n            mstore(ptr, LOCK_TYPEHASH)\n\n            // Cache various memory pointer data locations.\n            let replacementDataStart := add(replacementAmounts, 0x20)\n            let lockDataStart := add(ptr, 0x20)\n\n            // Iterate over the replacementAmounts array, splicing in the updated amounts.\n            for { let i := 0 } lt(i, idsAndAmounts.length) { i := add(i, 1) } {\n                // Retrieve the id from the relevant segment of calldata.\n                let id := calldataload(add(idsAndAmounts.offset, shl(6, i)))\n\n                // Copy id from calldata to next two words of allocated memory region.\n                // Deconstruct id into lockTag + token by inserting an empty word.\n                mstore(lockDataStart, id) // lockTag\n                mstore(add(lockDataStart, 0x20), id) // token\n                mstore(add(lockDataStart, 0x0c), 0) // empty word between lockTag & token\n\n                // Copy amount from replacement data to last word of allocated memory region.\n                mstore(add(lockDataStart, 0x40), mload(add(replacementDataStart, shl(5, i))))\n\n                // Derive hash of allocated memory & write to next hashes memory region.\n                mstore(add(hashesPtr, shl(5, i)), keccak256(ptr, 0x80))\n            }\n\n            // Compute hash of derived hashes that have been stored in memory.\n            commitmentsHash := keccak256(hashesPtr, shl(5, idsAndAmounts.length))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for deriving the commitments hash based on the\n     * ids and amounts of a given batch claim component.\n     * @param claims           An array of BatchClaimComponent structs.\n     * @return commitmentsHash The EIP-712 hash of the Lock[] commitments array.\n     */\n    function toCommitmentsHash(BatchClaimComponent[] calldata claims) internal pure returns (uint256 commitmentsHash) {\n        // Retrieve the total number of committed locks in the batch claim.\n        uint256 totalLocks = claims.length;\n\n        // Allocate working memory for hashing operations.\n        (uint256 ptr, uint256 hashesPtr) = totalLocks.allocateCommitmentsHashingMemory();\n\n        unchecked {\n            // Cache lock-specific data start memory pointer location.\n            uint256 lockDataStart = ptr + 0x20;\n\n            // Iterate over the claims array.\n            for (uint256 i = 0; i < totalLocks; ++i) {\n                // Navigate to the current claim component in calldata.\n                BatchClaimComponent calldata claimComponent = claims[i];\n\n                assembly (\"memory-safe\") {\n                    // Copy data on committed lock from relevant segment of calldata.\n                    // Deconstruct id into lockTag + token by inserting an empty word.\n                    mstore(lockDataStart, calldataload(claimComponent)) // lockTag\n                    calldatacopy(add(lockDataStart, 0x2c), add(claimComponent, 0x0c), 0x34) // token + amount\n                    mstore(add(lockDataStart, 0x0c), 0) // empty word between lockTag & token\n\n                    // Hash the elements in scratch space and store at current position.\n                    mstore(add(hashesPtr, shl(5, i)), keccak256(ptr, 0x80))\n                }\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            // Derive the commitments hash using the prepared lock hashes data.\n            commitmentsHash := keccak256(hashesPtr, shl(5, totalLocks))\n        }\n    }\n\n    function allocateCommitmentsHashingMemory(uint256 totalLocks)\n        internal\n        pure\n        returns (uint256 ptr, uint256 hashesPtr)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the current free memory pointer.\n            ptr := mload(0x40)\n\n            // Write lock typehash to first word of memory.\n            mstore(ptr, LOCK_TYPEHASH)\n\n            // Allocate four words of memory for deriving hashes.\n            hashesPtr := add(ptr, 0x80)\n\n            // Allocate additional memory based on the total committed locks.\n            mstore(0x40, add(hashesPtr, shl(5, totalLocks)))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for retrieving an EIP-712 claim hash. Used when a\n     * compact is registered with a directly corresponding deposit.\n     * @param sponsor    The account sponsoring the registered compact.\n     * @param tokenId    Identifier for the associated token & lock.\n     * @param amount     The associated number of tokens on the compact.\n     * @param arbiter    Account tasked with initiating claims against the compact.\n     * @param nonce      Allocator replay protection nonce.\n     * @param expires    Timestamp when the claim expires.\n     * @param typehash   Typehash of the entire compact, including witness subtypes.\n     * @param witness    EIP712 structured hash of witness.\n     * @return claimHash The corresponding EIP-712 message hash.\n     */\n    function toClaimHashFromDeposit(\n        address sponsor,\n        uint256 tokenId,\n        uint256 amount,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness\n    ) internal pure returns (bytes32 claimHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare the inputs to the message hash.\n            mstore(m, typehash)\n            mstore(add(m, 0x20), arbiter)\n            mstore(add(m, 0x40), sponsor)\n            mstore(add(m, 0x60), nonce)\n            mstore(add(m, 0x80), expires)\n            mstore(add(m, 0xa0), tokenId) // lockTag\n            mstore(add(m, 0xc0), tokenId) // token\n            mstore(add(m, 0xac), 0) // empty word between lockTag and token\n            mstore(add(m, 0xe0), amount)\n            mstore(add(m, 0x100), witness)\n\n            // Derive the message hash from the prepared data.\n            // Do not include witness hash for no-witness case.\n            claimHash := keccak256(m, add(0x100, shl(5, iszero(eq(typehash, COMPACT_TYPEHASH)))))\n        }\n    }\n\n    /**\n     * @notice Internal pure function for retrieving an EIP-712 claim hash for a batch compact.\n     * Used when a batch compact is registered with a directly corresponding set of deposits.\n     * @param sponsor            The account sponsoring the claimed compact.\n     * @param idsAndAmounts      An array with IDs and aggregate transfer amounts.\n     * @param arbiter            Account tasked with initiating claims against the compact.\n     * @param nonce              Allocator replay protection nonce.\n     * @param expires            Timestamp when the compact expires.\n     * @param typehash           Typehash of the entire compact, including witness subtypes.\n     * @param witness            EIP712 structured hash of witness.\n     * @param replacementAmounts An optional array of replacement amounts.\n     * @return messageHash       The corresponding EIP-712 messagehash.\n     */\n    function toClaimHashFromBatchDeposit(\n        address sponsor,\n        uint256[2][] calldata idsAndAmounts,\n        address arbiter,\n        uint256 nonce,\n        uint256 expires,\n        bytes32 typehash,\n        bytes32 witness,\n        uint256[] memory replacementAmounts\n    ) internal pure returns (bytes32 messageHash) {\n        // Derive the commitments hash using the provided ids and amounts array.\n        bytes32 commitmentsHash = idsAndAmounts.toCommitmentsHash(replacementAmounts);\n\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Prepare the inputs to the message hash.\n            mstore(m, typehash)\n            mstore(add(m, 0x20), arbiter)\n            mstore(add(m, 0x40), sponsor)\n            mstore(add(m, 0x60), nonce)\n            mstore(add(m, 0x80), expires)\n            mstore(add(m, 0xa0), commitmentsHash)\n            mstore(add(m, 0xc0), witness)\n\n            // Derive the message hash from the prepared data.\n            // Do not include witness hash for no-witness case.\n            messageHash := keccak256(m, add(0xc0, shl(5, iszero(eq(typehash, BATCH_COMPACT_TYPEHASH)))))\n        }\n    }\n}\n"},"lib/the-compact/src/lib/DomainLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/**\n * @title DomainLib\n * @notice Library contract implementing logic for deriving domain hashes.\n */\nlibrary DomainLib {\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(bytes(\"The Compact\"))`.\n    bytes32 internal constant _NAME_HASH = 0x5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b292;\n\n    /// @dev `keccak256(\"1\")`.\n    bytes32 internal constant _VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /**\n     * @notice Internal view function that returns the current domain separator, deriving a new one\n     * if the chain ID has changed from the initial chain ID.\n     * @param initialDomainSeparator The domain separator derived at deployment time.\n     * @param initialChainId         The chain ID at the time of deployment.\n     * @return domainSeparator       The current domain separator.\n     */\n    function toLatest(bytes32 initialDomainSeparator, uint256 initialChainId)\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        // Set the initial domain separator as the default domain separator.\n        domainSeparator = initialDomainSeparator;\n\n        assembly (\"memory-safe\") {\n            // Derive domain separator again if initial chain ID differs from current one.\n            if xor(chainid(), initialChainId) {\n                // Retrieve the free memory pointer.\n                let m := mload(0x40)\n\n                // Prepare domain data: EIP-712 typehash, name hash, version hash, chain ID, & verifying contract.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), _NAME_HASH)\n                mstore(add(m, 0x40), _VERSION_HASH)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n\n                // Derive the domain separator.\n                domainSeparator := keccak256(m, 0xa0)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal view function that derives a domain separator for a specific chain ID.\n     * Used for notarizing multichain claims with segments that will be executed on a different chain.\n     * @param notarizedChainId          The chain ID to derive the domain separator for.\n     * @return notarizedDomainSeparator The domain separator for the specified chain ID.\n     */\n    function toNotarizedDomainSeparator(uint256 notarizedChainId)\n        internal\n        view\n        returns (bytes32 notarizedDomainSeparator)\n    {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer.\n            let m := mload(0x40)\n\n            // Prepare domain data: EIP-712 typehash, name hash, version hash, notarizing chain ID, and verifying contract.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), _NAME_HASH)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), notarizedChainId)\n            mstore(add(m, 0x80), address())\n\n            // Derive the domain separator.\n            notarizedDomainSeparator := keccak256(m, 0xa0)\n        }\n    }\n\n    /**\n     * @notice Internal pure function that combines a message hash with a domain separator\n     * to create a domain-specific hash according to EIP-712.\n     * @param messageHash     The EIP-712 hash of the message data.\n     * @param domainSeparator The domain separator to combine with the message hash.\n     * @return domainHash     The domain-specific hash.\n     */\n    function withDomain(bytes32 messageHash, bytes32 domainSeparator) internal pure returns (bytes32 domainHash) {\n        assembly (\"memory-safe\") {\n            // Retrieve and cache the free memory pointer.\n            let m := mload(0x40)\n\n            // Prepare the 712 prefix.\n            mstore(0, 0x1901)\n\n            // Prepare the domain separator.\n            mstore(0x20, domainSeparator)\n\n            // Prepare the message hash and compute the domain hash.\n            mstore(0x40, messageHash)\n            domainHash := keccak256(0x1e, 0x42)\n\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/ConstructorLogic.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\nimport { DomainLib } from \"./DomainLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { MetadataRenderer } from \"./MetadataRenderer.sol\";\nimport {\n    TransferBenchmarkLib,\n    _NATIVE_TOKEN_BENCHMARK_SCOPE,\n    _ERC20_TOKEN_BENCHMARK_SCOPE\n} from \"./TransferBenchmarkLib.sol\";\n\nimport { TransferBenchmarker } from \"./TransferBenchmarker.sol\";\n\nimport { Tstorish } from \"./Tstorish.sol\";\n\n/**\n * @title ConstructorLogic\n * @notice Inherited contract implementing internal functions with logic for initializing\n * immutable variables and deploying the metadata renderer contract, as well as for setting\n * and clearing resource locks, retrieving metadata from the metadata renderer, and safely\n * interacting with Permit2. Note that TSTORE will be used for the reentrancy lock on chains\n * that support it, with a fallback to SSTORE where it is not supported along with a utility\n * for activating TSTORE support if the chain eventually adds support for it.\n */\ncontract ConstructorLogic is Tstorish {\n    using DomainLib for bytes32;\n    using EfficiencyLib for uint256;\n    using DomainLib for uint256;\n    using IdLib for uint256;\n    using TransferBenchmarkLib for uint256;\n\n    // Address of the Permit2 contract, optionally used for depositing ERC20 tokens.\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    // Storage slot used for the reentrancy guard, whether using TSTORE or SSTORE.\n    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\n\n    // Chain ID at deployment, used for triggering EIP-712 domain separator updates.\n    uint256 private immutable _INITIAL_CHAIN_ID;\n\n    // Initial EIP-712 domain separator, computed at deployment time.\n    bytes32 private immutable _INITIAL_DOMAIN_SEPARATOR;\n\n    // Whether Permit2 was deployed on the chain at construction time.\n    bool private immutable _PERMIT2_INITIALLY_DEPLOYED;\n\n    // Declare uint256 representations of various metadata-related function selectors.\n    uint256 private constant _NAME_SELECTOR = 0xad800c;\n    uint256 private constant _SYMBOL_SELECTOR = 0x4e41a1fb;\n    uint256 private constant _DECIMALS_SELECTOR = 0x3f47e662;\n    uint256 private constant _URI_SELECTOR = 0x0e89341c;\n\n    // Declare an immutable argument for the account of the benchmarker contract.\n    address private immutable _BENCHMARKER;\n\n    /**\n     * @notice Constructor that initializes immutable variables and deploys the metadata\n     * renderer. Captures the initial chain ID and domain separator, deploys the metadata\n     * renderer, and checks for Permit2 deployment.\n     */\n    constructor() {\n        _INITIAL_CHAIN_ID = block.chainid;\n        _INITIAL_DOMAIN_SEPARATOR = block.chainid.toNotarizedDomainSeparator();\n        new MetadataRenderer();\n        _PERMIT2_INITIALLY_DEPLOYED = _checkPermit2Deployment();\n\n        // Deploy contract for benchmarking native and generic ERC20 token withdrawals. Note\n        // that benchmark cannot be evaluated as part of contract creation as it requires\n        // that the ERC20 account is not already warm as part of deriving the benchmark.\n        _BENCHMARKER = address(new TransferBenchmarker());\n    }\n\n    /**\n     * @notice Internal function to set the reentrancy guard using either TSTORE or SSTORE.\n     * Called as part of functions that require reentrancy protection. Reverts if called\n     * again before the reentrancy guard has been cleared.\n     * @dev Note that the caller is set to the value; this enables external contracts to\n     * ascertain the account originating the ongoing call while handling the call using\n     * exttload. Also note that the value is actually set to a value of 1 when cleared;\n     * this results in a significant efficiency improvement for environments that do not\n     * yet support tstore, and additionally provides a mechanism to determine whether the\n     * contract has been entered in a previous stage of the current transaction for\n     * environments that do support it.\n     */\n    function _setReentrancyGuard() internal {\n        // Retrieve the current reentrancy sentinel value.\n        uint256 entered = _getTstorish(_REENTRANCY_GUARD_SLOT);\n\n        assembly (\"memory-safe\") {\n            // Consider any value over 1 as indicating that reentrancy is disallowed.\n            if gt(entered, 1) {\n                // revert ReentrantCall(address existingCaller)\n                mstore(0, 0xf57c448b)\n                mstore(0x20, entered)\n                revert(0x1c, 0x24)\n            }\n\n            // Use the address of the caller for the updated sentinel value.\n            entered := caller()\n        }\n\n        // Store the updated sentinel value.\n        _setTstorish(_REENTRANCY_GUARD_SLOT, entered);\n    }\n\n    /**\n     * @notice Internal function to clear the reentrancy guard using either TSTORE or SSTORE.\n     * Called as part of functions that require reentrancy protection.\n     */\n    function _clearReentrancyGuard() internal {\n        // Store a value of 1 for the updated sentinel value. This indicates that the\n        // contract can be entered again while keeping the sentinel storage slot dirty.\n        _setTstorish(_REENTRANCY_GUARD_SLOT, 1);\n    }\n\n    /**\n     * @notice Internal function to benchmark the gas costs of token transfers.\n     * Measures both native token and ERC20 token transfer costs and stores them.\n     */\n    function _benchmark() internal {\n        address benchmarker = _BENCHMARKER;\n\n        assembly (\"memory-safe\") {\n            calldatacopy(0, 0, calldatasize())\n            let success := call(gas(), benchmarker, callvalue(), 0, calldatasize(), 0, 0x40)\n            if iszero(success) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n\n            sstore(_NATIVE_TOKEN_BENCHMARK_SCOPE, mload(0))\n            sstore(_ERC20_TOKEN_BENCHMARK_SCOPE, mload(0x20))\n        }\n    }\n\n    /**\n     * @notice Internal view function for retrieving the benchmarked gas costs for\n     * both native token and ERC20 token withdrawals.\n     * @return nativeTokenStipend The benchmarked gas cost for native token withdrawals.\n     * @return erc20TokenStipend  The benchmarked gas cost for ERC20 token withdrawals.\n     */\n    function _getRequiredWithdrawalFallbackStipends()\n        internal\n        view\n        returns (uint256 nativeTokenStipend, uint256 erc20TokenStipend)\n    {\n        assembly (\"memory-safe\") {\n            nativeTokenStipend := sload(_NATIVE_TOKEN_BENCHMARK_SCOPE)\n            erc20TokenStipend := sload(_ERC20_TOKEN_BENCHMARK_SCOPE)\n        }\n    }\n\n    /**\n     * @notice Internal view function that checks whether Permit2 is deployed. Returns true\n     * if Permit2 was deployed at construction time, otherwise checks current deployment status.\n     * @return Whether Permit2 is currently deployed.\n     */\n    function _isPermit2Deployed() internal view returns (bool) {\n        if (_PERMIT2_INITIALLY_DEPLOYED) {\n            return true;\n        }\n\n        return _checkPermit2Deployment();\n    }\n\n    /**\n     * @notice Internal view function that returns the current EIP-712 domain separator,\n     * updating it if the chain ID has changed since deployment.\n     * @return The current domain separator.\n     */\n    function _domainSeparator() internal view virtual returns (bytes32) {\n        return _INITIAL_DOMAIN_SEPARATOR.toLatest(_INITIAL_CHAIN_ID);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the name for a given token ID.\n     * @param id The ERC6909 token identifier.\n     * @return The token's name.\n     */\n    function _name(uint256 id) internal view returns (string memory) {\n        _viaMetadataRenderer(uint256(_NAME_SELECTOR).asStubborn(), id);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the symbol for a given token ID.\n     * @param id The ERC6909 token identifier.\n     * @return The token's symbol.\n     */\n    function _symbol(uint256 id) internal view returns (string memory) {\n        _viaMetadataRenderer(uint256(_SYMBOL_SELECTOR).asStubborn(), id);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the decimals for a given token ID.\n     * @param id The ERC6909 token identifier.\n     * @return The token's decimals.\n     */\n    function _decimals(uint256 id) internal view returns (uint8) {\n        _viaMetadataRenderer(uint256(_DECIMALS_SELECTOR).asStubborn(), id);\n    }\n\n    /**\n     * @notice Internal view function for retrieving the URI for a given token ID.\n     * @param id The ERC6909 token identifier.\n     * @return The token's URI.\n     */\n    function _tokenURI(uint256 id) internal view returns (string memory) {\n        _viaMetadataRenderer(uint256(_URI_SELECTOR).asStubborn(), id);\n    }\n\n    /**\n     * @notice Private view function that checks whether Permit2 is currently deployed by\n     * checking for code at the Permit2 address.\n     * @return permit2Deployed Whether there is code at the Permit2 address.\n     */\n    function _checkPermit2Deployment() private view returns (bool permit2Deployed) {\n        assembly (\"memory-safe\") {\n            permit2Deployed := iszero(iszero(extcodesize(_PERMIT2)))\n        }\n    }\n\n    /**\n     * @notice Private view function for calling the metadata renderer and passing\n     * through the result. Note that this function will forceably return or revert,\n     * exiting the current call stack.\n     * @param functionSelector A uint256 representation of the function selector to use.\n     * @param id The ERC6909 token identifier.\n     */\n    function _viaMetadataRenderer(uint256 functionSelector, uint256 id) private view {\n        assembly (\"memory-safe\") {\n            // Prepare RLP-encoded inputs for metadata renderer address in scratch space.\n            mstore(0x14, address()) // Deployer address.\n            mstore(0, 0xd694) // RLP prefix for given input sizes.\n            mstore8(0x34, 0x02) // Metadata renderer contract deployment nonce.\n\n            // Derive metadata renderer contract address by hashing the prepared inputs.\n            // Dirty upper bits will be ignored when performing the subsequent staticcall.\n            let metadataRenderer := keccak256(0x1e, 0x17)\n\n            // Prepare calldata for staticcall to metadata renderer via provided arguments.\n            mstore(0, functionSelector)\n            mstore(0x20, id)\n\n            // Perform staticcall to derived account using prepared calldata.\n            let success := staticcall(gas(), metadataRenderer, 0x1c, 0x24, 0, 0)\n\n            // Copy the full returndata buffer to memory.\n            returndatacopy(0, 0, returndatasize())\n\n            // Bubble up the revert if the staticcall reverted; otherwise return.\n            if iszero(success) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }\n}\n"},"lib/the-compact/src/lib/ClaimHashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedTransfer, Claim } from \"../types/Claims.sol\";\n\nimport { AllocatedBatchTransfer, BatchClaim } from \"../types/BatchClaims.sol\";\n\nimport { MultichainClaim, ExogenousMultichainClaim } from \"../types/MultichainClaims.sol\";\n\nimport { BatchMultichainClaim, ExogenousBatchMultichainClaim } from \"../types/BatchMultichainClaims.sol\";\n\nimport { BatchClaimComponent } from \"../types/Components.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { ClaimHashFunctionCastLib } from \"./ClaimHashFunctionCastLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\n\n/**\n * @title ClaimHashLib\n * @notice Library contract implementing logic for deriving hashes as part of processing\n * claims, allocated transfers, and withdrawals.\n */\nlibrary ClaimHashLib {\n    using ClaimHashFunctionCastLib for function(uint256) internal pure returns (uint256);\n    using ClaimHashFunctionCastLib for function(uint256) internal view returns (bytes32, bytes32);\n    using ClaimHashFunctionCastLib for function(uint256, uint256) internal view returns (bytes32, bytes32);\n    using\n    ClaimHashFunctionCastLib\n    for\n        function(uint256, uint256, function(uint256, uint256) internal view returns (bytes32)) internal view returns (bytes32);\n    using\n    ClaimHashFunctionCastLib\n    for\n        function(uint256, uint256, function(uint256, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32);\n    using\n    ClaimHashFunctionCastLib\n    for\n        function(uint256, uint256, function(uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32);\n    using\n    ClaimHashFunctionCastLib\n    for\n        function(uint256, uint256, function(uint256, uint256) internal view returns (bytes32, bytes32)) internal view returns (bytes32, bytes32, bytes32);\n    using\n    ClaimHashFunctionCastLib\n    for\n        function(uint256, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32, bytes32);\n    using EfficiencyLib for uint256;\n    using HashLib for uint256;\n    using HashLib for BatchClaimComponent[];\n    using HashLib for AllocatedTransfer;\n    using HashLib for AllocatedBatchTransfer;\n\n    ///// CATEGORY 1: Transfer claim hashes /////\n    function toClaimHash(AllocatedTransfer calldata transfer) internal view returns (bytes32 claimHash) {\n        return transfer.toTransferMessageHash();\n    }\n\n    function toClaimHash(AllocatedBatchTransfer calldata transfer) internal view returns (bytes32 claimHash) {\n        return transfer.toBatchTransferMessageHash();\n    }\n\n    ///// CATEGORY 2: Claim with witness message & type hashes /////\n    function toMessageHashes(Claim calldata claim) internal view returns (bytes32 claimHash, bytes32 typehash) {\n        return HashLib.toClaimHash.usingClaim()(claim);\n    }\n\n    function toMessageHashes(BatchClaim calldata claim) internal view returns (bytes32 claimHash, bytes32 typehash) {\n        return HashLib.toBatchClaimHash.usingBatchClaim()(claim, claim.claims.toCommitmentsHash());\n    }\n\n    function toMessageHashes(MultichainClaim calldata claim)\n        internal\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toMultichainClaimWithWitnessMessageHash(claim);\n    }\n\n    function toMessageHashes(BatchMultichainClaim calldata claim)\n        internal\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toBatchMultichainClaimWithWitnessMessageHash(claim);\n    }\n\n    function toMessageHashes(ExogenousMultichainClaim calldata claim)\n        internal\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toExogenousMultichainClaimWithWitnessMessageHash(claim);\n    }\n\n    function toMessageHashes(ExogenousBatchMultichainClaim calldata claim)\n        internal\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toExogenousBatchMultichainClaimWithWitnessMessageHash(claim);\n    }\n\n    ///// Private helper functions /////\n    function _toGenericMultichainClaimWithWitnessMessageHash(\n        uint256 claim,\n        uint256 additionalInput,\n        function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32) hashFn\n    ) private view returns (bytes32 claimHash, bytes32 /* typehash */ ) {\n        (bytes32 allocationTypehash, bytes32 typehash) = claim.toMultichainTypehashes();\n        return (hashFn(claim, 0xa0, allocationTypehash, typehash, additionalInput), typehash);\n    }\n\n    function _toGenericBatchMultichainClaimWithWitnessMessageHash(\n        uint256 claim,\n        uint256 additionalInput,\n        function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32) hashFn\n    ) private view returns (bytes32 claimHash, bytes32 /* typehash */ ) {\n        (bytes32 allocationTypehash, bytes32 typehash) = claim.toMultichainTypehashes();\n        return (hashFn(claim, 0x60, allocationTypehash, typehash, additionalInput), typehash);\n    }\n\n    function _toMultichainClaimWithWitnessMessageHash(MultichainClaim calldata claim)\n        private\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toGenericMultichainClaimWithWitnessMessageHash.usingMultichainClaimWithWitness()(\n            claim,\n            HashLib.toCommitmentsHashFromSingleLock.usingMultichainClaimWithWitness()(claim),\n            HashLib.toMultichainClaimMessageHash\n        );\n    }\n\n    function _toExogenousMultichainClaimWithWitnessMessageHash(ExogenousMultichainClaim calldata claim)\n        private\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toGenericMultichainClaimWithWitnessMessageHash.usingExogenousMultichainClaimWithWitness()(\n            claim,\n            HashLib.toCommitmentsHashFromSingleLock.usingExogenousMultichainClaimWithWitness()(claim),\n            HashLib.toExogenousMultichainClaimMessageHash\n        );\n    }\n\n    function _toBatchMultichainClaimWithWitnessMessageHash(BatchMultichainClaim calldata claim)\n        private\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toGenericBatchMultichainClaimWithWitnessMessageHash.usingBatchMultichainClaim()(\n            claim, claim.claims.toCommitmentsHash(), HashLib.toMultichainClaimMessageHash\n        );\n    }\n\n    function _toExogenousBatchMultichainClaimWithWitnessMessageHash(ExogenousBatchMultichainClaim calldata claim)\n        private\n        view\n        returns (bytes32 claimHash, bytes32 typehash)\n    {\n        return _toGenericBatchMultichainClaimWithWitnessMessageHash.usingExogenousBatchMultichainClaim()(\n            claim, claim.claims.toCommitmentsHash(), HashLib.toExogenousMultichainClaimMessageHash\n        );\n    }\n}\n"},"lib/the-compact/src/lib/ComponentLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\n\nimport { TransferComponent, Component, ComponentsById, BatchClaimComponent } from \"../types/Components.sol\";\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { EventLib } from \"./EventLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\nimport { TransferLib } from \"./TransferLib.sol\";\n\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\n\n/**\n * @title ComponentLib\n * @notice Library contract implementing internal functions with helper logic for\n * processing claims including those with batch components.\n * @dev IMPORTANT NOTE: logic for processing claims assumes that the utilized structs are\n * formatted in a very specific manner if parameters are rearranged or new parameters\n * are inserted, much of this functionality will break. Proceed with caution when making\n * any changes.\n */\nlibrary ComponentLib {\n    using TransferLib for address;\n    using ComponentLib for Component[];\n    using EfficiencyLib for bool;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for bytes32;\n    using EventLib for address;\n    using HashLib for uint256;\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using ValidityLib for uint256;\n    using ValidityLib for uint96;\n    using ValidityLib for bytes32;\n    using RegistrationLib for address;\n    using FixedPointMathLib for uint256;\n\n    error Overflow();\n    error NoIdsAndAmountsProvided();\n\n    /**\n     * @notice Internal function for performing a set of transfers or withdrawals.\n     * Executes the transfer or withdrawal operation targeting multiple recipients from\n     * a single resource lock.\n     * @param transfer  An AllocatedTransfer struct containing transfer details.\n     * @return          Whether the transfer was successfully processed.\n     */\n    function processTransfer(AllocatedTransfer calldata transfer) internal returns (bool) {\n        // Process the transfer for each component.\n        _processTransferComponents(transfer.recipients, transfer.id);\n\n        return true;\n    }\n\n    /**\n     * @notice Internal function for performing a set of batch transfers or withdrawals.\n     * Executes the transfer or withdrawal operation for multiple recipients from multiple\n     * resource locks.\n     * @param transfer  An AllocatedBatchTransfer struct containing batch transfer details.\n     */\n    function performBatchTransfer(AllocatedBatchTransfer calldata transfer) internal {\n        // Navigate to the batch components array in calldata.\n        ComponentsById[] calldata transfers = transfer.transfers;\n\n        // Retrieve the total number of components.\n        uint256 totalIds = transfers.length;\n\n        unchecked {\n            // Iterate over each component in calldata.\n            for (uint256 i = 0; i < totalIds; ++i) {\n                // Navigate to location of the component in calldata.\n                ComponentsById calldata component = transfers[i];\n\n                // Process transfer for each component in the set.\n                _processTransferComponents(component.portions, component.id);\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for processing claims with potentially exogenous sponsor\n     * signatures. Extracts claim parameters from calldata, validates the claim, validates\n     * the scope, and executes either releases of ERC6909 tokens or withdrawals of underlying\n     * tokens to multiple recipients.\n     * @param messageHash              The EIP-712 hash of the claim message.\n     * @param calldataPointer          Pointer to the location of the associated struct in calldata.\n     * @param sponsorDomainSeparator   The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param typehash                 The EIP-712 typehash used for the claim message.\n     * @param domainSeparator          The local domain separator.\n     * @param validation               Function pointer to the _validate function.\n     */\n    function processClaimWithComponents(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        bytes32 sponsorDomainSeparator,\n        bytes32 typehash,\n        bytes32 domainSeparator,\n        function(bytes32, uint96, uint256, bytes32, bytes32, bytes32, uint256[2][] memory) internal returns (address)\n            validation\n    ) internal {\n        // Declare variables for parameters that will be extracted from calldata.\n        uint256 id;\n        uint256 allocatedAmount;\n        Component[] calldata components;\n\n        assembly (\"memory-safe\") {\n            // Calculate pointer to claim parameters using expected offset.\n            let calldataPointerWithOffset := add(calldataPointer, 0xe0)\n\n            // Extract resource lock id and allocated amount.\n            id := calldataload(calldataPointerWithOffset)\n            allocatedAmount := calldataload(add(calldataPointerWithOffset, 0x20))\n\n            // Extract array of components containing claimant addresses and amounts.\n            let componentsPtr := add(calldataPointer, calldataload(add(calldataPointerWithOffset, 0x40)))\n            components.offset := add(0x20, componentsPtr)\n            components.length := calldataload(componentsPtr)\n        }\n\n        // Initialize idsAndAmounts array.\n        uint256[2][] memory idsAndAmounts = new uint256[2][](1);\n        idsAndAmounts[0] = [id, allocatedAmount];\n\n        // Validate the claim and extract the sponsor address.\n        address sponsor = validation(\n            messageHash,\n            id.toAllocatorId(),\n            calldataPointer,\n            domainSeparator,\n            sponsorDomainSeparator,\n            typehash,\n            idsAndAmounts\n        );\n\n        // Verify the resource lock scope is compatible with the provided domain separator.\n        sponsorDomainSeparator.ensureValidScope(id);\n\n        // Process each component, verifying total amount and executing operations.\n        components.verifyAndProcessComponents(sponsor, id, allocatedAmount);\n    }\n\n    /**\n     * @notice Internal function for processing qualified batch claims with potentially\n     * exogenous sponsor signatures. Extracts batch claim parameters from calldata,\n     * validates the claim, and executes operations for each resource lock. Uses optimized\n     * validation of allocator consistency and scopes, with explicit validation on failure to\n     * identify specific issues. Each resource lock can be split among multiple recipients.\n     * @param messageHash              The EIP-712 hash of the claim message.\n     * @param calldataPointer          Pointer to the location of the associated struct in calldata.\n     * @param sponsorDomainSeparator   The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param typehash                 The EIP-712 typehash used for the claim message.\n     * @param domainSeparator          The local domain separator.\n     * @param validation               Function pointer to the _validate function.\n     */\n    function processClaimWithBatchComponents(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        bytes32 sponsorDomainSeparator,\n        bytes32 typehash,\n        bytes32 domainSeparator,\n        function(bytes32, uint96, uint256, bytes32, bytes32, bytes32, uint256[2][] memory) internal returns (address)\n            validation\n    ) internal {\n        // Declare variable for BatchClaimComponent array that will be extracted from calldata.\n        BatchClaimComponent[] calldata claims;\n        assembly (\"memory-safe\") {\n            // Extract array of batch claim components.\n            let claimsPtr := add(calldataPointer, calldataload(add(calldataPointer, 0xe0)))\n            claims.offset := add(0x20, claimsPtr)\n            claims.length := calldataload(claimsPtr)\n        }\n\n        // Parse into idsAndAmounts & extract first allocatorId.\n        (uint256[2][] memory idsAndAmounts, uint96 firstAllocatorId) =\n            _buildIdsAndAmounts(claims, sponsorDomainSeparator);\n\n        // Validate the claim and extract the sponsor address.\n        address sponsor = validation(\n            messageHash,\n            firstAllocatorId,\n            calldataPointer,\n            domainSeparator,\n            sponsorDomainSeparator,\n            typehash,\n            idsAndAmounts\n        );\n\n        unchecked {\n            // Process each claim component.\n            for (uint256 i = 0; i < idsAndAmounts.length; ++i) {\n                BatchClaimComponent calldata claimComponent = claims[i];\n\n                // Process each component, verifying total amount and executing operations.\n                claimComponent.portions.verifyAndProcessComponents(\n                    sponsor, claimComponent.id, claimComponent.allocatedAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for building an array of resource lock IDs and their allocated\n     * amounts from batch claim components. Also extracts the allocator ID from the first item\n     * for validation purposes. Verifies that all claims use the same allocator and have valid\n     * scopes.\n     * @param claims                 Array of batch claim components to process.\n     * @param sponsorDomainSeparator The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @return idsAndAmounts         Array of [id, allocatedAmount] pairs for each claim component.\n     * @return firstAllocatorId      The allocator ID extracted from the first claim component.\n     */\n    function _buildIdsAndAmounts(BatchClaimComponent[] calldata claims, bytes32 sponsorDomainSeparator)\n        internal\n        pure\n        returns (uint256[2][] memory idsAndAmounts, uint96 firstAllocatorId)\n    {\n        uint256 totalClaims = claims.length;\n        if (totalClaims == 0) {\n            revert NoIdsAndAmountsProvided();\n        }\n\n        // Extract allocator id and amount from first claim for validation.\n        BatchClaimComponent calldata claimComponent = claims[0];\n        uint256 id = claimComponent.id;\n        firstAllocatorId = id.toAllocatorId();\n\n        // Initialize idsAndAmounts array and register the first element.\n        idsAndAmounts = new uint256[2][](totalClaims);\n        idsAndAmounts[0] = [id, claimComponent.allocatedAmount];\n\n        // Initialize error tracking variable.\n        uint256 errorBuffer = id.scopeNotMultichain(sponsorDomainSeparator).asUint256();\n\n        unchecked {\n            // Register each additional element & accumulate potential errors.\n            for (uint256 i = 1; i < totalClaims; ++i) {\n                claimComponent = claims[i];\n                id = claimComponent.id;\n\n                errorBuffer |= (id.toAllocatorId() != firstAllocatorId).or(\n                    id.scopeNotMultichain(sponsorDomainSeparator)\n                ).asUint256();\n\n                // Include the id and amount in idsAndAmounts.\n                idsAndAmounts[i] = [id, claimComponent.allocatedAmount];\n            }\n\n            // Revert if any errors occurred.\n            assembly (\"memory-safe\") {\n                if errorBuffer {\n                    // revert InvalidBatchAllocation()\n                    mstore(0, 0x3a03d3bb)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for verifying and processing components. Ensures that the\n     * sum of amounts doesn't exceed the allocated amount, checks for arithmetic overflow,\n     * and executes the specified operation for each recipient. Reverts if the total claimed\n     * amount exceeds the allocation or if arithmetic overflow occurs during summation.\n     * @param claimants       Array of components specifying recipients and their amounts.\n     * @param sponsor         The address of the claim sponsor.\n     * @param id              The ERC6909 token identifier of the resource lock.\n     * @param allocatedAmount The total amount allocated for this claim.\n     */\n    function verifyAndProcessComponents(\n        Component[] calldata claimants,\n        address sponsor,\n        uint256 id,\n        uint256 allocatedAmount\n    ) internal {\n        // Initialize tracking variables.\n        uint256 totalClaims = claimants.length;\n        uint256 spentAmount;\n        uint256 errorBuffer;\n\n        unchecked {\n            // Process each component while tracking total amount and checking for overflow.\n            for (uint256 i = 0; i < totalClaims; ++i) {\n                Component calldata component = claimants[i];\n                uint256 amount = component.amount;\n\n                // Track total amount claimed, checking for overflow.\n                uint256 updatedSpentAmount = amount + spentAmount;\n                errorBuffer |= (updatedSpentAmount < spentAmount).asUint256();\n                spentAmount = updatedSpentAmount;\n\n                sponsor.performOperation(id, component.claimant, amount);\n            }\n        }\n\n        // Revert if an overflow occurred or if total claimed amount exceeds allocation.\n        errorBuffer |= (allocatedAmount < spentAmount).asUint256();\n        assembly (\"memory-safe\") {\n            if errorBuffer {\n                // revert AllocatedAmountExceeded(allocatedAmount, amount);\n                mstore(0, 0x3078b2f6)\n                mstore(0x20, allocatedAmount)\n                mstore(0x40, spentAmount)\n                revert(0x1c, 0x44)\n            }\n        }\n    }\n\n    /**\n     * @notice Internal pure function for summing all amounts in a Component array.\n     * Checks for arithmetic overflow during summation and reverts if detected.\n     * @param recipients A Component struct array containing transfer details.\n     * @return sum Total amount across all components.\n     */\n    function aggregate(Component[] calldata recipients) internal pure returns (uint256 sum) {\n        // Retrieve the total number of components.\n        uint256 totalComponents = recipients.length;\n\n        uint256 amount;\n        uint256 errorBuffer;\n        unchecked {\n            // Iterate over each additional component in calldata.\n            for (uint256 i = 0; i < totalComponents; ++i) {\n                amount = recipients[i].amount;\n                sum += amount;\n                errorBuffer |= (sum < amount).asUint256();\n            }\n        }\n\n        if (errorBuffer.asBool()) {\n            revert Overflow();\n        }\n    }\n\n    /**\n     * @notice Private function for performing a set of transfers or withdrawals\n     * given an array of components and an ID for an associated resource lock.\n     * Executes the transfer or withdrawal operation targeting multiple recipients.\n     * @param recipients A Component struct array containing transfer details.\n     * @param id         The ERC6909 token identifier of the resource lock.\n     */\n    function _processTransferComponents(Component[] calldata recipients, uint256 id) private {\n        // Retrieve the total number of components.\n        uint256 totalComponents = recipients.length;\n\n        unchecked {\n            // Iterate over each additional component in calldata.\n            for (uint256 i = 0; i < totalComponents; ++i) {\n                // Navigate to location of the component in calldata.\n                Component calldata component = recipients[i];\n\n                // Perform the transfer or withdrawal for the portion.\n                msg.sender.performOperation(id, component.claimant, component.amount);\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/lib/EventLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/**\n * @title EventLib\n * @notice Library contract implementing logic for internal functions to\n * emit various events.\n * @dev Note that most events are still emitted using inline logic; this\n * library only implements a few events.\n */\nlibrary EventLib {\n    // keccak256(bytes(\"Claim(address,address,address,bytes32,uint256)\")).\n    uint256 private constant _CLAIM_EVENT_SIGNATURE = 0x9a071f16ca19062495c8c0e832e4541b4453cd2995fd631b0b7e9f0ee300ff12;\n\n    // keccak256(bytes(\"ForcedWithdrawalStatusUpdated(address,uint256,bool,uint256)\")).\n    uint256 private constant _FORCED_WITHDRAWAL_STATUS_UPDATED_SIGNATURE =\n        0xe27f5e0382cf5347965fc81d5c81cd141897fe9ce402d22c496b7c2ddc84e5fd;\n\n    /**\n     * @notice Internal function for emitting claim events. The sponsor and allocator\n     * addresses are sanitized before emission.\n     * @param sponsor   The account sponsoring the compact that the claim is for.\n     * @param claimHash The EIP-712 hash of the claim message.\n     * @param allocator The account mediating the claim.\n     * @param nonce     The nonce on the claimed compact.\n     */\n    function emitClaim(address sponsor, bytes32 claimHash, address allocator, uint256 nonce) internal {\n        assembly (\"memory-safe\") {\n            // Emit the Claim event:\n            //  - topic1: Claim event signature\n            //  - topic2: sponsor address (sanitized)\n            //  - topic3: allocator address (sanitized)\n            //  - topic4: caller address\n            //  - data: messageHash, nonce\n            mstore(0, claimHash)\n            mstore(0x20, nonce)\n            log4(\n                0,\n                0x40,\n                _CLAIM_EVENT_SIGNATURE,\n                shr(0x60, shl(0x60, sponsor)),\n                shr(0x60, shl(0x60, allocator)),\n                caller()\n            )\n        }\n    }\n\n    /**\n     * @notice Internal function for emitting forced withdrawal status update events.\n     * @param id             The ERC6909 token identifier of the resource lock.\n     * @param withdrawableAt The timestamp when withdrawal becomes possible.\n     */\n    function emitForcedWithdrawalStatusUpdatedEvent(uint256 id, uint256 withdrawableAt) internal {\n        assembly (\"memory-safe\") {\n            // Emit ForcedWithdrawalStatusUpdated event:\n            //  - topic1: Event signature\n            //  - topic2: Caller address\n            //  - topic3: Token id\n            //  - data: [activating flag, withdrawableAt timestamp]\n            mstore(0, iszero(iszero(withdrawableAt)))\n            mstore(0x20, withdrawableAt)\n            log3(0, 0x40, _FORCED_WITHDRAWAL_STATUS_UPDATED_SIGNATURE, caller(), id)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/TransferFunctionCastLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { AllocatedBatchTransfer } from \"../types/BatchClaims.sol\";\nimport { AllocatedTransfer } from \"../types/Claims.sol\";\nimport { TransferComponent, ComponentsById } from \"../types/Components.sol\";\n\n/**\n * @title TransferFunctionCastLib\n * @notice Library contract implementing function casts used in TransferLogic as well as\n * in HashLib. The input function operates on a function that takes some argument that\n * differs from what is currently available. The output function modifies one or more\n * argument types so that they match the arguments that are being used to call the\n * function. Note that from the perspective of the function being modified, the original\n * type is still in force; great care should be taken to preserve offsets and general\n * structure between the two structs.\n */\nlibrary TransferFunctionCastLib {\n    /**\n     * @notice Function cast to provide a BatchTransfer calldata struct while\n     * treating it as a BasicTransfer calldata struct.\n     * @param fnIn   Function pointer to `TransferLogic._notExpiredAndAuthorizedByAllocator`.\n     * @return fnOut Modified function used in `TransferLogic._processBatchTransfer`.\n     */\n    function usingBatchTransfer(\n        function (bytes32, address, AllocatedTransfer calldata, uint256[2][] memory) internal fnIn\n    )\n        internal\n        pure\n        returns (function (bytes32, address, AllocatedBatchTransfer calldata, uint256[2][] memory) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n}\n"},"lib/the-compact/src/lib/EmissaryLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IdLib } from \"./IdLib.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { EmissaryConfig, EmissaryStatus } from \"../types/EmissaryStatus.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { IEmissary } from \"../interfaces/IEmissary.sol\";\n\n/**\n * @title EmissaryLib\n * @notice This library manages the assignment and verification of emissaries for sponsors\n * within the system. An emissary is an address that can verify claims on behalf of a sponsor.\n * The library enforces security constraints and scheduling rules to ensure proper delegation.\n *\n * @dev The library uses a storage-efficient design with a single storage slot for all emissary\n * configurations, using mappings to organize data by sponsor and allocator ID. This allows for\n * efficient storage and access while maintaining data isolation between different sponsors.\n *\n * Key Components:\n * - EmissarySlot: Storage structure that maps sponsors to their allocator ID configurations\n * - EmissaryConfig: Configuration data for each emissary assignment, including reset periods\n * - Assignment scheduling: Enforces cooldown periods between assignments to prevent abuse\n * - Verification: Delegates claim verification to the assigned emissary contract\n *\n * Security Features:\n * - Timelock mechanism for reassignment to prevent rapid succession of emissaries\n * - Clear state management with Disabled/Enabled/Scheduled statuses\n * - Storage cleanup when emissaries are removed\n */\nlibrary EmissaryLib {\n    using IdLib for bytes12;\n    using IdLib for address;\n    using IdLib for uint256;\n    using IdLib for ResetPeriod;\n    using IdLib for uint96;\n    using EfficiencyLib for bytes12;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n\n    // Sentinel value of type(uint96).max representing an emissary without a scheduled assignment.\n    uint96 private constant NOT_SCHEDULED = 0xffffffffffffffffffffffff;\n\n    // Scope for storage slots containing emissary configurations.\n    // bytes4(keccak256(\"_EMISSARY_SCOPE\")).\n    uint256 private constant _EMISSARY_SCOPE = 0x2d5c707e;\n\n    // bytes4(keccak256(\"verifyClaim(address,bytes32,bytes32,bytes,bytes12)\")).\n    uint32 private constant _VERIFY_CLAIM_SELECTOR = 0xf699ba1c;\n\n    // keccak256(\"EmissaryAssigned(address,bytes12,address)\").\n    uint256 private constant _EMISSARY_ASSIGNED_EVENT_SIGNATURE =\n        0x92de0e90f030663724bafa9b7a9ba2643e3f4ced55f1cfee8b01e2682aeb45fd;\n\n    // keccak256(\"EmissaryAssignmentScheduled(address,bytes12,uint256)\").\n    uint256 private constant _EMISSARY_ASSIGNMENT_SCHEDULED_EVENT_SIGNATURE =\n        0x16c05a1aea0a2659b53f72fda6b47106e4aa07338b16993a01ece024df9d8cc4;\n\n    /**\n     * @notice Internal function to assign or remove an emissary for a specific sponsor and\n     * lock tag. This ensures that the assignment process adheres to the scheduling rules\n     * and prevents invalid or premature assignments. It also clears the configuration\n     * when removing an emissary to keep storage clean and avoid stale data.\n     * @param lockTag     The lockTag of the emissary.\n     * @param newEmissary The address of the new emissary, or address(0) to remove.\n     */\n    function assignEmissary(bytes12 lockTag, address newEmissary) internal {\n        EmissaryConfig storage config = _getEmissaryConfig(msg.sender, lockTag);\n        uint256 assignableAt = config.assignableAt;\n        address currentEmissary = config.emissary;\n\n        // Ensure assigment has been properly scheduled if an emissary is currently set.\n        // Note that assigment can occur immediately if no emissary is set. Emissaries that\n        // do not have a scheduled assigment will have an assignableAt of type(uint96).max\n        // which will prohibit assignment as the timestamp cannot exceed that value.\n        assembly (\"memory-safe\") {\n            if and(iszero(iszero(currentEmissary)), gt(assignableAt, timestamp())) {\n                // Revert EmissaryAssignmentUnavailable(assignableAt);\n                mstore(0, 0x174f0776)\n                mstore(0x20, assignableAt)\n                revert(0x1c, 0x24)\n            }\n        }\n\n        // If new Emissary is address(0), that means that the sponsor wants to remove their emissary.\n        // In that event, wipe all related storage.\n        if (newEmissary == address(0)) {\n            // If the new emissary is address(0), this means the emissary should be removed.\n            // Clear all related storage fields to maintain a clean state and avoid stale data.\n            delete config.emissary;\n            delete config.assignableAt;\n        }\n        // Otherwise, set the provided newEmissary.\n        else {\n            config.emissary = newEmissary;\n            config.assignableAt = NOT_SCHEDULED;\n        }\n\n        assembly (\"memory-safe\") {\n            // Emit EmissaryAssigned(msg.sender, lockTag, newEmissary) event.\n            log4(0, 0, _EMISSARY_ASSIGNED_EVENT_SIGNATURE, caller(), lockTag, newEmissary)\n        }\n    }\n\n    /**\n     * @notice Internal function to schedule a future assignment for an emissary.\n     * The scheduling mechanism ensures that emissaries cannot be reassigned arbitrarily,\n     * enforcing a reset period that must elapse before a new assignment is possible.\n     * This prevents abuse of the system by requiring a cooldown period between assignments.\n     * @param lockTag       The lock tag for the assignment.\n     * @return assignableAt The timestamp when the assignment becomes available.\n     */\n    function scheduleEmissaryAssignment(bytes12 lockTag) internal returns (uint256 assignableAt) {\n        // Get the current emissary config from storage.\n        EmissaryConfig storage emissaryConfig = _getEmissaryConfig(msg.sender, lockTag);\n\n        unchecked {\n            // Extract five bit resetPeriod from lockTag, convert to seconds, & add to current time.\n            assignableAt = block.timestamp + lockTag.toResetPeriod().toSeconds();\n        }\n\n        // Write the resultant value to storage. Note that assignableAt is expected to remain in uint96\n        // range, as block timestamps will not reach upper uint96 range in realistic timeframes and\n        // ResetPeriod is capped at thirty days.\n        emissaryConfig.assignableAt = uint96(assignableAt);\n\n        assembly (\"memory-safe\") {\n            // Emit EmissaryAssignmentScheduled(msg.sender, lockTag, assignableAt) event.\n            mstore(0, assignableAt)\n            log3(0, 0x20, _EMISSARY_ASSIGNMENT_SCHEDULED_EVENT_SIGNATURE, caller(), lockTag)\n        }\n    }\n\n    /**\n     * @notice Internal view function to verify a claim using the assigned emissary.\n     * This function delegates the verification logic to the emissary contract,\n     * ensuring that the verification process is modular and can be updated independently.\n     * If no emissary is assigned, the verification fails, enforcing the requirement\n     * for an active emissary to validate claims.\n     * @param digest    The digest of the claim on the notarized chain.\n     * @param claimHash The hash of the claim to verify.\n     * @param sponsor   The address of the sponsor.\n     * @param lockTag   The lock tag for the claim.\n     * @param signature The signature to verify.\n     */\n    function verifyWithEmissary(\n        bytes32 digest,\n        bytes32 claimHash,\n        address sponsor,\n        bytes12 lockTag,\n        bytes calldata signature\n    ) internal view {\n        // Retrieve the emissary for the sponsor and lock tag from storage.\n        EmissaryConfig storage emissaryConfig = _getEmissaryConfig(sponsor, lockTag);\n\n        // Delegate the verification process to the assigned emissary contract.\n        _callVerifyClaim(emissaryConfig.emissary, sponsor, digest, claimHash, signature, lockTag);\n    }\n\n    /**\n     * @notice Internal view function to retrieve the current status of an emissary for a given\n     * sponsor and lock tag. The status provides insight into whether the emissary is active,\n     * disabled, or scheduled for reassignment. This provides visibility into the state of the\n     * emissary system without needing to interpret raw configuration data.\n     * @param sponsor          The address of the sponsor.\n     * @param lockTag          The lock tag for the emissary.\n     * @return status          The current status of the emissary.\n     * @return assignableAt    The timestamp when the emissary can be reassigned.\n     * @return currentEmissary The address of the currently assigned emissary.\n     */\n    function getEmissaryStatus(address sponsor, bytes12 lockTag)\n        internal\n        view\n        returns (EmissaryStatus status, uint256 assignableAt, address currentEmissary)\n    {\n        EmissaryConfig storage emissaryConfig = _getEmissaryConfig(sponsor, lockTag);\n        assignableAt = emissaryConfig.assignableAt;\n        currentEmissary = emissaryConfig.emissary;\n\n        // Determine the emissary's status based on its current state:\n        // - If there is no current emissary, the status is Disabled and assignableAt must be zero.\n        // - If assignableAt is NOT_SCHEDULED, the emissary is Enabled and active.\n        // - If assignableAt is set to a future timestamp, the emissary is Scheduled for reassignment.\n        if (currentEmissary == address(0)) {\n            status = EmissaryStatus.Disabled;\n        } else if (assignableAt == NOT_SCHEDULED) {\n            status = EmissaryStatus.Enabled;\n        } else {\n            status = EmissaryStatus.Scheduled;\n        }\n    }\n\n    /**\n     * @notice Internal pure function to extract and verify that all IDs in a given idsAndAmounts array have\n     * the same lock tag.\n     * @param idsAndAmounts Array of [id, amount] pairs.\n     * @return lockTag      The common lock tag across all IDs.\n     */\n    function extractSameLockTag(uint256[2][] memory idsAndAmounts) internal pure returns (bytes12 lockTag) {\n        // Store the first lockTag for the first id. Note that idsAndAmounts is known to be non-zero\n        // length at this point, as it gets checked in _buildIdsAndAmounts in ComponentLib.\n        lockTag = idsAndAmounts[0][0].toLockTag();\n\n        // Initialize an error buffer.\n        uint256 errorBuffer;\n\n        // Retrieve the length of the array.\n        uint256 idsAndAmountsLength = idsAndAmounts.length;\n\n        // Iterate over remaining array elements.\n        unchecked {\n            for (uint256 i = 1; i < idsAndAmountsLength; ++i) {\n                // Set the error buffer if lockTag does not match initial lockTag.\n                errorBuffer |= (idsAndAmounts[i][0].toLockTag() != lockTag).asUint256();\n            }\n        }\n\n        // Ensure that no lockTag values differ.\n        assembly (\"memory-safe\") {\n            if errorBuffer {\n                // Revert InvalidLockTag();\n                mstore(0, 0xbbfc3c51)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Private view function to perform a low-level verifyClaim staticcall to an\n     * emissary, ensuring that the expected magic value (verifyClaim function selector) is\n     * returned. Reverts if the magic value is not returned successfully.\n     * @param emissary  The emissary to perform the call to.\n     * @param sponsor   The address of the sponsor.\n     * @param digest    The digest of the claim to verify.\n     * @param claimHash The hash of the claim to verify.\n     * @param signature The signature to verify.\n     * @param lockTag   The lock tag for the claim.\n     */\n    function _callVerifyClaim(\n        address emissary,\n        address sponsor,\n        bytes32 digest,\n        bytes32 claimHash,\n        bytes calldata signature,\n        bytes12 lockTag\n    ) private view {\n        assembly (\"memory-safe\") {\n            // Retrieve the free memory pointer; memory will be left dirtied.\n            let m := mload(0x40)\n\n            // Derive offset to start of data for the call from memory pointer.\n            let dataStart := add(m, 0x1c)\n\n            // Prepare fixed-location components of calldata.\n            mstore(add(m, 0x20), sponsor)\n            mstore(add(m, 0x0c), 0) // Clear any dirty upper bits on sponsor.\n            mstore(m, _VERIFY_CLAIM_SELECTOR)\n            mstore(add(m, 0x40), digest)\n            mstore(add(m, 0x60), claimHash)\n            mstore(add(m, 0x80), 0xa0)\n            mstore(add(m, 0xa0), lockTag)\n            mstore(add(m, 0xac), 0) // clear any dirty lower bits on lock tag.\n            mstore(add(m, 0xc0), signature.length)\n            calldatacopy(add(m, 0xe0), signature.offset, signature.length)\n\n            // Ensure sure initial scratch space is cleared as an added precaution.\n            mstore(0, 0)\n\n            // Perform a staticcall to emissary and write response to scratch space.\n            let success := staticcall(gas(), emissary, dataStart, add(0xc4, signature.length), 0, 0x20)\n\n            // Revert if the required magic value was not received back.\n            if iszero(eq(mload(0), shl(0xe0, _VERIFY_CLAIM_SELECTOR))) {\n                // Bubble up if the call failed and there's data. Note that remaining gas is not evaluated before\n                // copying the returndata buffer into memory. Out-of-gas errors can be triggered via revert bombing.\n                if iszero(or(success, iszero(returndatasize()))) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n\n                // revert InvalidSignature();\n                mstore(0, 0x8baa579f)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Private pure function to retrieve the configuration for a given emissary.\n     * This ensures that emissary-specific settings (like reset period and assignment time)\n     * are stored and retrieved in a consistent and isolated manner to prevent conflicts.\n     * The function uses a combination of sponsor address, lockTag, and a scope constant\n     * to compute a unique storage slot for the configuration.\n     * @param sponsor The address of the sponsor that the emissary is associated with.\n     * @param lockTag The lock tag to which the emissary assignment is associated.\n     * @return config The configuration for the emissary in storage.\n     */\n    function _getEmissaryConfig(address sponsor, bytes12 lockTag)\n        private\n        pure\n        returns (EmissaryConfig storage config)\n    {\n        // Pack and hash scope, sponsor, and lock tag to derive emissary config storage slot.\n        assembly (\"memory-safe\") {\n            // Start by writing the sponsor address to scratch space so that the 20 bytes of\n            // address data are placed at memory location 0x20. The first 12 bytes of the\n            // variable for the sponsor are unused and overwritten by the subsequent write.\n            mstore(0x14, sponsor)\n\n            // Next, write the emissary scope value to scratch space so that the 4 bytes of\n            // scope data are placed at the memory location 0x1c. The first 28 bytes of the\n            // variable for the emissary scope are unused and will be omitted from the slot\n            // derivation; a right-aligned value is preferred over a left-aligned one like\n            // bytes4 to reduce code size requirements without needing bitshift operations.\n            mstore(0, _EMISSARY_SCOPE)\n\n            // Then, write the lock tag value to scratch space so that the 12 bytes of\n            // lock tag data are placed at memory location 0x34. This data is left-aligned\n            // and so it can be placed directly at the intended memory location, and the\n            // final 20 bytes will not be included in the slot derivation. Note that these\n            // unused least-significant bits will overflow into the free memory pointer and\n            // will need to be cleared in a subsequent step if there are any dirty lower bits\n            // on the lockTag value. Since a valid free memory pointer can never grow to a\n            // value that would require the 20 most-significant bytes in the pointer (as this\n            // would certainly exhaust memory long before they were needed), these bytes can\n            // safely be used as long as they are cleared before accessing the pointer again.\n            mstore(0x34, lockTag)\n\n            // Compute storage slot from packed data.\n            // Start at offset 0x1c (28 bytes) and hash 0x24 (36 bytes) of data in total:\n            // - _EMISSARY_SCOPE (4 bytes from at 0x1c to 0x20)\n            // - Sponsor address (20 bytes from 0x20 to 0x34)\n            // - Lock tag (12 bytes from 0x34 to 0x40)\n            config.slot := keccak256(0x1c, 0x24)\n\n            // Finally, wipe the leftmost 20 bytes of the free memory pointer that may have\n            // been set when writing the lock tag (assuming dirty lower bits were present).\n            mstore(0x34, 0)\n        }\n    }\n}\n"},"lib/the-compact/src/interfaces/IAllocator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IAllocator {\n    /**\n     * @notice Called on standard transfers to validate the transfer.\n     * @param operator The address performing the transfer.\n     * @param from     The address tokens are being transferred from.\n     * @param to       The address tokens are being transferred to.\n     * @param id       The ERC6909 token identifier being transferred.\n     * @param amount   The amount of tokens being transferred.\n     * @return         Must return this function selector (0x1a808f91).\n     */\n    function attest(address operator, address from, address to, uint256 id, uint256 amount) external returns (bytes4);\n\n    /**\n     * @notice Authorize a claim. Called from The Compact as part of claim processing.\n     * @param claimHash      The message hash representing the claim.\n     * @param arbiter        The account tasked with verifying and submitting the claim.\n     * @param sponsor        The account to source the tokens from.\n     * @param nonce          A parameter to enforce replay protection, scoped to allocator.\n     * @param expires        The time at which the claim expires.\n     * @param idsAndAmounts  The allocated token IDs and amounts.\n     * @param allocatorData  Arbitrary data provided by the arbiter.\n     * @return               Must return the function selector (0x7bb023f7).\n     */\n    function authorizeClaim(\n        bytes32 claimHash,\n        address arbiter,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        uint256[2][] calldata idsAndAmounts,\n        bytes calldata allocatorData\n    ) external returns (bytes4);\n\n    /**\n     * @notice Check if given allocatorData authorizes a claim. Intended to be called offchain.\n     * @param claimHash      The message hash representing the claim.\n     * @param arbiter        The account tasked with verifying and submitting the claim.\n     * @param sponsor        The account to source the tokens from.\n     * @param nonce          A parameter to enforce replay protection, scoped to allocator.\n     * @param expires        The time at which the claim expires.\n     * @param idsAndAmounts  The allocated token IDs and amounts.\n     * @param allocatorData  Arbitrary data provided by the arbiter.\n     * @return               A boolean indicating whether the claim is authorized.\n     */\n    function isClaimAuthorized(\n        bytes32 claimHash,\n        address arbiter,\n        address sponsor,\n        uint256 nonce,\n        uint256 expires,\n        uint256[2][] calldata idsAndAmounts,\n        bytes calldata allocatorData\n    ) external view returns (bool);\n}\n"},"lib/solady/src/utils/FixedPointMathLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18)  135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s  6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0  p1_1 | z_0   z_1 |\n                    // Final:  |   0   p1_0 | p1_1  z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"},"lib/the-compact/src/lib/ClaimProcessorLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ComponentLib } from \"./ComponentLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { EventLib } from \"./EventLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { RegistrationLib } from \"./RegistrationLib.sol\";\nimport { ValidityLib } from \"./ValidityLib.sol\";\n\nimport { AllocatorLib } from \"./AllocatorLib.sol\";\n\n/**\n * @title ClaimProcessorLib\n * @notice Library contract implementing internal functions with helper logic for\n * processing claims against a signed or registered compact.\n * @dev IMPORTANT NOTE: logic for processing claims assumes that the utilized structs are\n * formatted in a very specific manner if parameters are rearranged or new parameters\n * are inserted, much of this functionality will break. Proceed with caution when making\n * any changes.\n */\nlibrary ClaimProcessorLib {\n    using ComponentLib for bytes32;\n    using ClaimProcessorLib for uint256;\n    using ClaimProcessorLib for bytes32;\n    using EfficiencyLib for bool;\n    using EfficiencyLib for uint256;\n    using EfficiencyLib for bytes32;\n    using EventLib for address;\n    using HashLib for uint256;\n    using IdLib for uint256;\n    using ValidityLib for uint256;\n    using ValidityLib for uint96;\n    using ValidityLib for bytes32;\n    using RegistrationLib for address;\n    using AllocatorLib for address;\n\n    /**\n     * @notice Internal function for validating claim execution parameters. Extracts and validates\n     * signatures from calldata, checks expiration, verifies allocator registration, consumes the\n     * nonce, derives the domain separator, and validates both the sponsor authorization (either\n     * through direct registration or a provided signature or EIP-1271 call) and the (potentially\n     * qualified) allocator authorization. Finally, emits a Claim event.\n     * @dev caller of this function MUST implement reentrancy guard.\n     * @param messageHash              The EIP-712 hash of the claim message.\n     * @param allocatorId              The unique identifier for the allocator mediating the claim.\n     * @param calldataPointer          Pointer to the location of the associated struct in calldata.\n     * @param domainSeparator          The local domain separator.\n     * @param sponsorDomainSeparator   The domain separator for the sponsor's signature, or zero for non-exogenous claims.\n     * @param idsAndAmounts            The claimable resource lock IDs and amounts.\n     * @param typehash                 The EIP-712 typehash used for the claim message.\n     * @return sponsor                 The extracted address of the claim sponsor.\n     */\n    function validate(\n        bytes32 messageHash,\n        uint96 allocatorId,\n        uint256 calldataPointer,\n        bytes32 domainSeparator,\n        bytes32 sponsorDomainSeparator,\n        bytes32 typehash,\n        uint256[2][] memory idsAndAmounts\n    ) internal returns (address sponsor) {\n        // Extract sponsor, nonce, and expires from calldata.\n        uint256 nonce;\n        uint256 expires;\n        assembly (\"memory-safe\") {\n            // Extract sponsor address from calldata, sanitizing upper 96 bits.\n            sponsor := shr(0x60, calldataload(add(calldataPointer, 0x4c)))\n\n            // Extract nonce and expiration timestamp from calldata.\n            nonce := calldataload(add(calldataPointer, 0x60))\n            expires := calldataload(add(calldataPointer, 0x80))\n\n            // Swap domain separator for provided sponsorDomainSeparator if a nonzero value was supplied.\n            sponsorDomainSeparator := add(sponsorDomainSeparator, mul(iszero(sponsorDomainSeparator), domainSeparator))\n        }\n\n        // Ensure that the claim hasn't expired.\n        expires.later();\n\n        // Retrieve allocator address and consume nonce, ensuring it has not already been consumed.\n        address allocator = allocatorId.fromRegisteredAllocatorIdWithConsumed(nonce);\n\n        // Validate that the sponsor has authorized the claim.\n        _validateSponsor(sponsor, messageHash, calldataPointer, sponsorDomainSeparator, typehash, idsAndAmounts);\n\n        // Validate that the allocator has authorized the claim.\n        _validateAllocator(allocator, sponsor, messageHash, calldataPointer, idsAndAmounts, nonce, expires);\n\n        // Emit claim event.\n        sponsor.emitClaim(messageHash, allocator, nonce);\n    }\n\n    /**\n     * @notice Internal function for processing simple claims with local domain\n     * signatures. Extracts claim parameters from calldata, validates the claim,\n     * and executes operations for multiple recipients. Uses the zero sponsor\n     * domain separator.\n     * @param messageHash      The EIP-712 hash of the claim message.\n     * @param calldataPointer  Pointer to the location of the associated struct in calldata.\n     * @param typehash         The EIP-712 typehash used for the claim message.\n     * @param domainSeparator  The local domain separator.\n     */\n    function processSimpleClaim(bytes32 messageHash, uint256 calldataPointer, bytes32 typehash, bytes32 domainSeparator)\n        internal\n    {\n        messageHash.processClaimWithComponents(calldataPointer, 0, typehash, domainSeparator, validate);\n    }\n\n    /**\n     * @notice Internal function for processing simple batch claims with local domain\n     * signatures. Extracts batch claim parameters from calldata, validates the claim,\n     * and executes operations for multiple resource locks to multiple recipients. Uses the\n     * message hash itself as the qualification message and a zero sponsor domain separator.\n     * @param messageHash      The EIP-712 hash of the claim message.\n     * @param calldataPointer  Pointer to the location of the associated struct in calldata.\n     * @param typehash         The EIP-712 typehash used for the claim message.\n     * @param domainSeparator  The local domain separator.\n     */\n    function processSimpleBatchClaim(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        bytes32 typehash,\n        bytes32 domainSeparator\n    ) internal {\n        messageHash.processClaimWithBatchComponents(calldataPointer, 0, typehash, domainSeparator, validate);\n    }\n\n    /**\n     * @notice Internal function for processing claims with sponsor domain signatures.\n     * Extracts claim parameters from calldata, validates the claim using the provided\n     * sponsor domain, and executes operations for multiple recipients. Uses the message\n     * hash itself as the qualification message.\n     * @param messageHash      The EIP-712 hash of the claim message.\n     * @param calldataPointer  Pointer to the location of the associated struct in calldata.\n     * @param sponsorDomain    The domain separator for the sponsor's signature.\n     * @param typehash         The EIP-712 typehash used for the claim message.\n     * @param domainSeparator  The local domain separator.\n     */\n    function processClaimWithSponsorDomain(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        bytes32 sponsorDomain,\n        bytes32 typehash,\n        bytes32 domainSeparator\n    ) internal {\n        messageHash.processClaimWithComponents(calldataPointer, sponsorDomain, typehash, domainSeparator, validate);\n    }\n\n    /**\n     * @notice Internal function for processing batch claims with sponsor domain\n     * signatures. Extracts batch claim parameters from calldata, validates the claim\n     * using the provided sponsor domain, and executes operations for multiple resource\n     * locks to multiple recipients. Uses the message hash itself as the qualification\n     * message.\n     * @param messageHash      The EIP-712 hash of the claim message.\n     * @param calldataPointer  Pointer to the location of the associated struct in calldata.\n     * @param sponsorDomain    The domain separator for the sponsor's signature.\n     * @param typehash         The EIP-712 typehash used for the claim message.\n     * @param domainSeparator  The local domain separator.\n     */\n    function processBatchClaimWithSponsorDomain(\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        bytes32 sponsorDomain,\n        bytes32 typehash,\n        bytes32 domainSeparator\n    ) internal {\n        messageHash.processClaimWithBatchComponents(calldataPointer, sponsorDomain, typehash, domainSeparator, validate);\n    }\n\n    /**\n     * @notice Private view function to validate that a sponsor has authorized a given claim.\n     * @dev Extracts the sponsor signature from calldata and validates authorization through\n     * ECDSA, direct registration, EIP1271, or emissary.\n     * @param sponsor                The address of the sponsor of the claimed compact.\n     * @param messageHash            The EIP-712 message hash of the claim.\n     * @param calldataPointer        Pointer to the location of the associated struct in calldata.\n     * @param sponsorDomainSeparator The domain separator for the sponsor's signature.\n     * @param typehash               The EIP-712 typehash used for the claim message.\n     * @param idsAndAmounts          The claimable resource lock IDs and amounts.\n     */\n    function _validateSponsor(\n        address sponsor,\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        bytes32 sponsorDomainSeparator,\n        bytes32 typehash,\n        uint256[2][] memory idsAndAmounts\n    ) private {\n        bytes calldata sponsorSignature;\n        assembly (\"memory-safe\") {\n            // Extract sponsor signature from calldata using offset stored at calldataPointer + 0x20.\n            let sponsorSignaturePtr := add(calldataPointer, calldataload(add(calldataPointer, 0x20)))\n            sponsorSignature.offset := add(0x20, sponsorSignaturePtr)\n            sponsorSignature.length := calldataload(sponsorSignaturePtr)\n        }\n\n        // Validate sponsor authorization through either ECDSA, direct registration, EIP1271, or emissary.\n        messageHash.validateSponsorAndConsumeRegistration(\n            sponsor, sponsorSignature, sponsorDomainSeparator, idsAndAmounts, typehash\n        );\n    }\n\n    /**\n     * @notice Private function to validate that an allocator has authorized a given claim.\n     * @dev Extracts allocator data from calldata and validates allocator authorization through the allocator interface.\n     * @param allocator       The address of the allocator mediating the claim.\n     * @param sponsor         The address of the sponsor of the claimed compact.\n     * @param messageHash     The EIP-712 message hash of the claim.\n     * @param calldataPointer Pointer to the location of the associated struct in calldata.\n     * @param idsAndAmounts   The claimable resource lock IDs and amounts.\n     * @param nonce           The nonce used for the claim.\n     * @param expires         The expiration timestamp for the claim.\n     */\n    function _validateAllocator(\n        address allocator,\n        address sponsor,\n        bytes32 messageHash,\n        uint256 calldataPointer,\n        uint256[2][] memory idsAndAmounts,\n        uint256 nonce,\n        uint256 expires\n    ) private {\n        // Extract allocator signature from calldata using offset stored at calldataPointer.\n        bytes calldata allocatorData;\n        assembly (\"memory-safe\") {\n            let allocatorDataPtr := add(calldataPointer, calldataload(calldataPointer))\n            allocatorData.offset := add(0x20, allocatorDataPtr)\n            allocatorData.length := calldataload(allocatorDataPtr)\n        }\n\n        _validateAllocatorUsingExtractedData(\n            allocator, sponsor, messageHash, allocatorData, idsAndAmounts, nonce, expires\n        );\n    }\n\n    /**\n     * @notice Private function to validate that the allocator has authorized the claim.\n     * @dev Validates allocator authorization through the allocator interface using provided allocator data.\n     * @param allocator     The address of the allocator mediating the claim.\n     * @param sponsor       The address of the sponsor of the claimed compact.\n     * @param messageHash   The EIP-712 message hash of the claim.\n     * @param allocatorData The allocator-specific data for claim authorization.\n     * @param idsAndAmounts The claimable resource lock IDs and amounts.\n     * @param nonce         The nonce used for the claim.\n     * @param expires       The expiration timestamp for the claim.\n     */\n    function _validateAllocatorUsingExtractedData(\n        address allocator,\n        address sponsor,\n        bytes32 messageHash,\n        bytes calldata allocatorData,\n        uint256[2][] memory idsAndAmounts,\n        uint256 nonce,\n        uint256 expires\n    ) private {\n        // Validate allocator authorization through the allocator interface.\n        allocator.callAuthorizeClaim(messageHash, sponsor, nonce, expires, idsAndAmounts, allocatorData);\n    }\n}\n"},"lib/the-compact/src/lib/ClaimProcessorFunctionCastLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Claim } from \"../types/Claims.sol\";\n\nimport { BatchClaim } from \"../types/BatchClaims.sol\";\n\nimport { MultichainClaim, ExogenousMultichainClaim } from \"../types/MultichainClaims.sol\";\n\nimport { BatchMultichainClaim, ExogenousBatchMultichainClaim } from \"../types/BatchMultichainClaims.sol\";\n\n/**\n * @title ClaimProcessorFunctionCastLib\n * @notice Library contract implementing function casts used in ClaimProcessorLogic.\n * The input function operates on a function that takes some argument that differs\n * from what is currently available. The output function modifies one or more\n * argument types so that they match the arguments that are being used to call the\n * function. Note that from the perspective of the function being modified, the\n * original type is still in force; great care should be taken to preserve offsets\n * and general structure between the two structs.\n * @dev Note that some of these function casts may no longer be in use.\n */\nlibrary ClaimProcessorFunctionCastLib {\n    /**\n     * @notice Function cast to provide a Claim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimProcessorLib.processSimpleClaim`.\n     * @return fnOut Modified function used in `ClaimProcessorLogic._processClaim`.\n     */\n    function usingClaim(function(bytes32, uint256, bytes32, bytes32) internal fnIn)\n        internal\n        pure\n        returns (function(bytes32, Claim calldata, bytes32, bytes32) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a BatchClaim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimProcessorLib.processSimpleBatchClaim`.\n     * @return fnOut Modified function used in `ClaimProcessorLogic._processBatchClaim`.\n     */\n    function usingBatchClaim(function(bytes32, uint256, bytes32, bytes32) internal fnIn)\n        internal\n        pure\n        returns (function(bytes32, BatchClaim calldata, bytes32, bytes32) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a MultichainClaim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimProcessorLib.processSimpleClaim`.\n     * @return fnOut Modified function used in `ClaimProcessorLogic._processMultichainClaim`.\n     */\n    function usingMultichainClaim(function(bytes32, uint256, bytes32, bytes32) internal fnIn)\n        internal\n        pure\n        returns (function(bytes32, MultichainClaim calldata, bytes32, bytes32) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a BatchMultichainClaim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimProcessorLib.processSimpleBatchClaim`.\n     * @return fnOut Modified function used in `ClaimProcessorLogic._processBatchMultichainClaim`.\n     */\n    function usingBatchMultichainClaim(function(bytes32, uint256, bytes32, bytes32) internal fnIn)\n        internal\n        pure\n        returns (function(bytes32, BatchMultichainClaim calldata, bytes32, bytes32) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a ExogenousMultichainClaim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimProcessorLib.processClaimWithSponsorDomain`.\n     * @return fnOut Modified function used in `ClaimProcessorLogic._processExogenousMultichainClaim`.\n     */\n    function usingExogenousMultichainClaim(function(bytes32, uint256, bytes32, bytes32, bytes32) internal fnIn)\n        internal\n        pure\n        returns (function(bytes32, ExogenousMultichainClaim calldata, bytes32, bytes32, bytes32) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a ExogenousBatchMultichainClaim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimProcessorLib.processBatchClaimWithSponsorDomain`.\n     * @return fnOut Modified function used in `ClaimProcessorLogic._processExogenousBatchMultichainClaim`.\n     */\n    function usingExogenousBatchMultichainClaim(function(bytes32, uint256, bytes32, bytes32, bytes32) internal fnIn)\n        internal\n        pure\n        returns (function(bytes32, ExogenousBatchMultichainClaim calldata, bytes32, bytes32, bytes32) internal fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n}\n"},"lib/the-compact/src/types/EIP712Types.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// Message signed by the sponsor that specifies the conditions under which their\n// tokens can be claimed; the specified arbiter verifies that those conditions\n// have been met and specifies a set of beneficiaries that will receive up to the\n// specified amount of tokens.\nstruct Compact {\n    address arbiter; // The account tasked with verifying and submitting the claim.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    bytes12 lockTag; // A tag representing the allocator, reset period, and scope.\n    address token; // The locked token, or address(0) for native tokens.\n    uint256 amount; // The amount of ERC6909 tokens to commit from the lock.\n        // Optional witness may follow.\n}\n\n// keccak256(bytes(\"Compact(address arbiter,address sponsor,uint256 nonce,uint256 expires,bytes12 lockTag,address token,uint256 amount)\"))\nbytes32 constant COMPACT_TYPEHASH = 0x73b631296de001508966ddfc334593ad8f850ccd3be4d2c58a9ed469844eebc7;\n\n// abi.decode(bytes(\"Compact(address arbiter,address \"), (bytes32))\nbytes32 constant COMPACT_TYPESTRING_FRAGMENT_ONE = 0x436f6d70616374286164647265737320617262697465722c6164647265737320;\n\n// abi.decode(bytes(\"sponsor,uint256 nonce,uint256 ex\"), (bytes32))\nbytes32 constant COMPACT_TYPESTRING_FRAGMENT_TWO = 0x73706f6e736f722c75696e74323536206e6f6e63652c75696e74323536206578;\n\n// abi.decode(bytes(\"pires,bytes12 lockTag,address to\"), (bytes32))\nbytes32 constant COMPACT_TYPESTRING_FRAGMENT_THREE = 0x70697265732c62797465733132206c6f636b5461672c6164647265737320746f;\n\n// abi.decode(bytes(\"ken,uint256 amount,Mandate manda\"), (bytes32))\nbytes32 constant COMPACT_TYPESTRING_FRAGMENT_FOUR = 0x6b656e2c75696e7432353620616d6f756e742c4d616e64617465206d616e6461;\n\n// uint88(abi.decode(bytes(\"te)Mandate(\"), (bytes11)))\nuint88 constant COMPACT_TYPESTRING_FRAGMENT_FIVE = 0x7465294d616e6461746528;\n\n// A batch or multichain compact can contain commitments from multiple resource locks.\nstruct Lock {\n    bytes12 lockTag; // A tag representing the allocator, reset period, and scope.\n    address token; // The locked token, or address(0) for native tokens.\n    uint256 amount; // The maximum committed amount of tokens.\n}\n\n// keccak256(bytes(\"Lock(bytes12 lockTag,address token,uint256 amount)\"))\nbytes32 constant LOCK_TYPEHASH = 0xfb7744571d97aa61eb9c2bc3c67b9b1ba047ac9e95afb2ef02bc5b3d9e64fbe5;\n\n// Message signed by the sponsor that specifies the conditions under which a set of\n// tokens, each sharing an allocator, can be claimed; the specified arbiter verifies\n// that those conditions have been met and specifies a set of beneficiaries that will\n// receive up to the specified amounts of each token.\nstruct BatchCompact {\n    address arbiter; // The account tasked with verifying and submitting the claim.\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    Lock[] commitments; // The committed locks with lock tags, tokens, & amounts.\n        // Optional witness may follow.\n}\n\n// keccak256(bytes(\"BatchCompact(address arbiter,address sponsor,uint256 nonce,uint256 expires,Lock[] commitments)Lock(bytes12 lockTag,address token,uint256 amount)\"))\nbytes32 constant BATCH_COMPACT_TYPEHASH = 0x179fcd593ea3b4b32623a455fb55eb007c5040f4c85774f2e3f18d98e87eb76b;\n\n// abi.decode(bytes(\"BatchCompact(address arbiter,add\"), (bytes32))\nbytes32 constant BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE =\n    0x4261746368436f6d70616374286164647265737320617262697465722c616464;\n\n// abi.decode(bytes(\"ress sponsor,uint256 nonce,uint2\"), (bytes32))\nbytes32 constant BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO =\n    0x726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e7432;\n\n// abi.decode(bytes(\"56 expires,Lock[] commitments,Ma\"), (bytes32))\nbytes32 constant BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE =\n    0x353620657870697265732c4c6f636b5b5d20636f6d6d69746d656e74732c4d61;\n\n// abi.decode(bytes(\"ndate mandate)Lock(bytes12 lockT\"), (bytes32))\nbytes32 constant BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR =\n    0x6e64617465206d616e64617465294c6f636b2862797465733132206c6f636b54;\n\n// abi.decode(bytes(\"ag,address token,uint256 amount)\"), (bytes32))\nbytes32 constant BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE =\n    0x61672c6164647265737320746f6b656e2c75696e7432353620616d6f756e7429;\n\n// uint64(abi.decode(bytes(\"Mandate(\"), (bytes8)))\nuint64 constant BATCH_COMPACT_TYPESTRING_FRAGMENT_SIX = 0x4d616e6461746528;\n\n// A multichain compact can commit tokens from resource locks on multiple chains, each\n// designated by their chainId. Any committed tokens on an exogenous domain (e.g. all\n// but the first element) must designate the Multichain scope. Elements may designate\n// unique arbiters for the chain in question. Note that the witness data is distinct\n// for each element, but all elements must share the same EIP-712 witness typestring.\nstruct Element {\n    address arbiter; // The account tasked with verifying and submitting the claim.\n    uint256 chainId; // The chainId where the tokens are located.\n    Lock[] commitments; // The committed locks with lock tags, tokens, & amounts.\n        // Mandate (witness) must follow.\n}\n\n// Message signed by the sponsor that specifies the conditions under which a set of\n// tokens across a number of different chains can be claimed; the specified arbiter on\n// each chain verifies that those conditions have been met and specifies a set of\n// beneficiaries that will receive up to the specified amounts of each token.\nstruct MultichainCompact {\n    address sponsor; // The account to source the tokens from.\n    uint256 nonce; // A parameter to enforce replay protection, scoped to allocator.\n    uint256 expires; // The time at which the claim expires.\n    Element[] elements; // Arbiter, chainId, ids & amounts, and mandate for each chain.\n}\n\n// keccak256(bytes(\"MultichainCompact(address sponsor,uint256 nonce,uint256 expires,Element[] elements)Element(address arbiter,uint256 chainId,Lock[] commitments)Lock(bytes12 lockTag,address token,uint256 amount)\"))\nbytes32 constant MULTICHAIN_COMPACT_TYPEHASH = 0x172d857ea70e48d30dcad00bb0fc789a34f09c5545da1245400da01d4ef6c8a2;\n\n// abi.decode(bytes(\"MultichainCompact(address sponso\"), (bytes32))\nbytes32 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_ONE =\n    0x4d756c7469636861696e436f6d7061637428616464726573732073706f6e736f;\n\n// abi.decode(bytes(\"r,uint256 nonce,uint256 expires,\"), (bytes32))\nbytes32 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_TWO =\n    0x722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c;\n\n// abi.decode(bytes(\"Element[] elements)Element(addre\"), (bytes32))\nbytes32 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_THREE =\n    0x456c656d656e745b5d20656c656d656e747329456c656d656e74286164647265;\n\n// abi.decode(bytes(\"ss arbiter,uint256 chainId,Lock[\"), (bytes32))\nbytes32 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FOUR =\n    0x737320617262697465722c75696e7432353620636861696e49642c4c6f636b5b;\n\n// abi.decode(bytes(\"] commitments,Mandate mandate)Lo\"), (bytes32))\nbytes32 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_FIVE =\n    0x5d20636f6d6d69746d656e74732c4d616e64617465206d616e64617465294c6f;\n\n// abi.decode(bytes(\"ck(bytes12 lockTag,address token\"), (bytes32))\nbytes32 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SIX =\n    0x636b2862797465733132206c6f636b5461672c6164647265737320746f6b656e;\n\n// uint200(abi.decode(bytes(\",uint256 amount)Mandate(\"), (bytes24))\nuint192 constant MULTICHAIN_COMPACT_TYPESTRING_FRAGMENT_SEVEN = 0x2c75696e7432353620616d6f756e74294d616e6461746528;\n\n// keccak256(bytes(\"Element(address arbiter,uint256 chainId,Lock[] commitments)Lock(bytes12 lockTag,address token,uint256 amount)\"))\nbytes32 constant ELEMENT_TYPEHASH = 0xc3e0b49b35866f940704f2fb568b9d5dae17a245971e2c095778b60ea177f03b;\n\n/// @dev `keccak256(bytes(\"CompactDeposit(bytes12 lockTag,address recipient)\"))`.\nbytes32 constant PERMIT2_DEPOSIT_WITNESS_FRAGMENT_HASH =\n    0xaced9f7c53bfda31d043cbef88f9ee23b8171ec904889af3d5d0b9b81914a404;\n\n/// @dev `keccak256(bytes(\"Activation(address activator,uint256 id,Compact compact)Compact(address arbiter,address sponsor,uint256 nonce,uint256 expires,bytes12 lockTag,address token,uint256 amount)\"))`.\nbytes32 constant COMPACT_ACTIVATION_TYPEHASH = 0x8b05b54b25c4a22095273abeb15e89077542cdca8be672282102c3473780942c;\n\n/// @dev `keccak256(bytes(\"Activation(address activator,uint256 id,BatchCompact compact)BatchCompact(address arbiter,address sponsor,uint256 nonce,uint256 expires,Lock[] commitments)Lock(bytes12 lockTag,address token,uint256 amount)\"))`.\nbytes32 constant BATCH_COMPACT_ACTIVATION_TYPEHASH = 0x5a6488a03f679efdf6390ea1cada208092f98514652ffa4036265fd48bcdbf4f;\n\n/// @dev `keccak256(bytes(\"BatchActivation(address activator,uint256[] ids,Compact compact)Compact(address arbiter,address sponsor,uint256 nonce,uint256 expires,bytes12 lockTag,address token,uint256 amount)\"))`.\nbytes32 constant COMPACT_BATCH_ACTIVATION_TYPEHASH = 0x25686dcdaf36339365d8aad4b420a3460867a181238971ffae587b16c6d9660f;\n\n/// @dev `keccak256(bytes(\"BatchActivation(address activator,uint256[] ids,BatchCompact compact)BatchCompact(address arbiter,address sponsor,uint256 nonce,uint256 expires,Lock[] commitments)Lock(bytes12 lockTag,address token,uint256 amount)\"))`.\nbytes32 constant BATCH_COMPACT_BATCH_ACTIVATION_TYPEHASH =\n    0xa794ed1a28cdf297ac45a3eee4643e35d29b295a389368da5f6baa420872c9b7;\n\n// abi.decode(bytes(\"Activation witness)Activation(ad\"), (bytes32))\nbytes32 constant PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE =\n    0x41637469766174696f6e207769746e6573732941637469766174696f6e286164;\n\n// uint216(abi.decode(bytes(\"dress activator,uint256 id,\"), (bytes27)))\nuint216 constant PERMIT2_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO =\n    0x647265737320616374697661746f722c75696e743235362069642c;\n\n// abi.decode(bytes(\"BatchActivation witness)BatchAct\"), (bytes32))\nbytes32 constant PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_ONE =\n    0x426174636841637469766174696f6e207769746e657373294261746368416374;\n\n// abi.decode(bytes(\"ivation(address activator,uint25\"), (bytes32))\nbytes32 constant PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_TWO =\n    0x69766174696f6e286164647265737320616374697661746f722c75696e743235;\n\n// uint64(abi.decode(bytes(\"6[] ids,\"), (bytes8)))\nuint64 constant PERMIT2_BATCH_DEPOSIT_WITH_ACTIVATION_TYPESTRING_FRAGMENT_THREE = 0x365b5d206964732c;\n\n// abi.decode(bytes(\"Compact compact)Compact(address \"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_ONE =\n    0x436f6d7061637420636f6d7061637429436f6d70616374286164647265737320;\n\n// abi.decode(bytes(\"arbiter,address sponsor,uint256 \"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_TWO =\n    0x617262697465722c616464726573732073706f6e736f722c75696e7432353620;\n\n// abi.decode(bytes(\"nonce,uint256 expires,bytes12 lo\"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_THREE =\n    0x6e6f6e63652c75696e7432353620657870697265732c62797465733132206c6f;\n\n// abi.decode(bytes(\"ckTag,address token,uint256 amou\"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FOUR =\n    0x636b5461672c6164647265737320746f6b656e2c75696e7432353620616d6f75;\n\n// uint216(abi.decode(bytes(\"nt,Mandate mandate)Mandate(\"), (bytes27)))\nuint216 constant PERMIT2_ACTIVATION_COMPACT_TYPESTRING_FRAGMENT_FIVE =\n    0x6e742c4d616e64617465206d616e64617465294d616e6461746528;\n\n// abi.decode(bytes(\"BatchCompact compact)BatchCompac\"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_ONE =\n    0x4261746368436f6d7061637420636f6d70616374294261746368436f6d706163;\n\n// abi.decode(bytes(\"t(address arbiter,address sponso\"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_TWO =\n    0x74286164647265737320617262697465722c616464726573732073706f6e736f;\n\n// abi.decode(bytes(\"r,uint256 nonce,uint256 expires,\"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_THREE =\n    0x722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c;\n\n// uint144(abi.decode(bytes(\"Lock[] commitments\"), (bytes18)))\nuint144 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FOUR = 0x4c6f636b5b5d20636f6d6d69746d656e7473;\n\n// uint128(abi.decode(bytes(\",Mandate mandate\"), (bytes16)))\nuint128 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_MANDATE_FRAGMENT_ONE = 0x2c4d616e64617465206d616e64617465;\n\n// abi.decode(bytes(\")Lock(bytes12 lockTag,address to\"), (bytes32))\nbytes32 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_FIVE =\n    0x294c6f636b2862797465733132206c6f636b5461672c6164647265737320746f;\n\n// uint152(abi.decode(bytes(\"ken,uint256 amount)\"), (bytes19)))\nuint152 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_FRAGMENT_SIX = 0x6b656e2c75696e7432353620616d6f756e7429;\n\n// uint64(abi.decode(bytes(\"Mandate(\"), (bytes8)))\nuint64 constant PERMIT2_ACTIVATION_BATCH_COMPACT_TYPESTRING_MANDATE_FRAGMENT_TWO = 0x4d616e6461746528;\n\n// abi.decode(bytes(\")TokenPermissions(address token,\"), (bytes32))\nbytes32 constant TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_ONE =\n    0x29546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c;\n\n// uint120(abi.decode(bytes(\"uint256 amount)\"), (bytes15)))\nuint120 constant TOKEN_PERMISSIONS_TYPESTRING_FRAGMENT_TWO = 0x75696e7432353620616d6f756e7429;\n\n// abi.decode(bytes(\"CompactDeposit witness)CompactDe\"), (bytes32))\nuint256 constant COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_ONE =\n    0x436f6d706163744465706f736974207769746e65737329436f6d706163744465;\n\n// abi.decode(bytes(\"posit(bytes12 lockTag,address re\"), (bytes32))\nuint256 constant COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_TWO =\n    0x706f7369742862797465733132206c6f636b5461672c61646472657373207265;\n\n// abi.decode(bytes(\"cipient)TokenPermissions(address\"), (bytes32))\nuint256 constant COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_THREE =\n    0x63697069656e7429546f6b656e5065726d697373696f6e732861646472657373;\n\n// uint176(abi.decode(bytes(\" token,uint256 amount)\"), (bytes22)))\nuint176 constant COMPACT_DEPOSIT_TYPESTRING_FRAGMENT_FOUR = 0x20746f6b656e2c75696e7432353620616d6f756e7429;\n"},"lib/the-compact/src/lib/TransferBenchmarkLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// Storage scope for native token benchmarks:\n// slot: _NATIVE_TOKEN_BENCHMARK_SCOPE => benchmark.\nuint32 constant _NATIVE_TOKEN_BENCHMARK_SCOPE = 0x655e83a8;\n\n// Storage scope for erc20 token benchmarks:\n// slot: _ERC20_TOKEN_BENCHMARK_SCOPE => benchmark.\nuint32 constant _ERC20_TOKEN_BENCHMARK_SCOPE = 0x824664ed;\n\n/**\n * @title TransferBenchmarkLib\n * @notice Library contract implementing setters and getters for the approximate\n * cost of both native token withdrawals as well as generic ERC20 token withdrawals.\n */\nlibrary TransferBenchmarkLib {\n    /**\n     * @notice Internal view function to ensure there is sufficient gas remaining to\n     * cover the benchmarked cost of a token withdrawal. Reverts if the remaining gas\n     * is less than the benchmark for the specified token type.\n     * @param token The address of the token (address(0) for native tokens).\n     */\n    function ensureBenchmarkExceeded(address token) internal view {\n        assembly (\"memory-safe\") {\n            // Select the appropriate scope based on the token in question.\n            let scope :=\n                xor(\n                    _ERC20_TOKEN_BENCHMARK_SCOPE,\n                    mul(xor(_ERC20_TOKEN_BENCHMARK_SCOPE, _NATIVE_TOKEN_BENCHMARK_SCOPE), iszero(token))\n                )\n\n            // Load benchmarked value and ensure it does not exceed available gas.\n            if gt(sload(scope), gas()) {\n                // revert InsufficientStipendForWithdrawalFallback();\n                mstore(0, 0xc5274598)\n                revert(0x1c, 4)\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/lib/MetadataRenderer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { MetadataLib } from \"./MetadataLib.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\n\n/**\n * @title MetadataRenderer\n * @notice Deployed contract implementing functionality for deriving and displaying\n * ERC6909 metadata as well as metadata specific to various underlying tokens.\n */\ncontract MetadataRenderer {\n    using EfficiencyLib for uint256;\n    using MetadataLib for address;\n    using MetadataLib for uint256;\n\n    address public immutable theCompact;\n\n    constructor() {\n        theCompact = msg.sender;\n    }\n\n    /**\n     * @notice External view function for generating the URI for a resource lock's ERC6909\n     * token. The URI is derived from the lock's details and token identifier.\n     * @param id          The ERC6909 token identifier.\n     * @return            The generated URI string.\n     */\n    function uri(uint256 id) external view returns (string memory) {\n        (address token, address allocator, ResetPeriod resetPeriod, Scope scope) = id.toLockDetails(theCompact);\n        return token.toURI(allocator, resetPeriod, scope, id);\n    }\n\n    /**\n     * @notice External view function for generating the name of an ERC6909 token. Combines\n     * \"Compact\" with the underlying token's name, falling back to a default if needed.\n     * @param id The ERC6909 token identifier.\n     * @return   The generated name string.\n     */\n    function name(uint256 id) external view returns (string memory) {\n        return string.concat(\"Compact \", id.asSanitizedAddress().readNameWithDefaultValue());\n    }\n\n    /**\n     * @notice External view function for generating the symbol of an ERC6909 token. Combines\n     * a handshake emoji with the underlying token's symbol, falling back to a default if\n     * needed.\n     * @param id The ERC6909 token identifier.\n     * @return   The generated symbol string.\n     */\n    function symbol(uint256 id) external view returns (string memory) {\n        return string.concat(unicode\"-\", id.asSanitizedAddress().readSymbolWithDefaultValue());\n    }\n\n    /**\n     * @notice External view function for retrieving the decimals of an ERC6909 token.\n     * Returns the decimals of the underlying token, falling back to a default if needed.\n     * @param id The ERC6909 token identifier.\n     * @return   The number of decimals for the token.\n     */\n    function decimals(uint256 id) external view returns (uint8) {\n        return id.asSanitizedAddress().readDecimalsAsUint8WithDefaultValue();\n    }\n}\n"},"lib/the-compact/src/lib/TransferBenchmarker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { BenchmarkERC20 } from \"./BenchmarkERC20.sol\";\n\n/**\n * @title TransferBenchmarker\n * @notice External contract for measuring the cost of native and generic ERC20 token\n * transfers. Designed to account for the idiosyncrasies of gas pricing across various\n * chains, as well as to have functionality for updating the benchmarks should gas\n * prices change on a given chain.\n */\ncontract TransferBenchmarker {\n    // Declare an immutable argument for the account of the benchmark ERC20 token.\n    address private immutable _BENCHMARK_ERC20;\n\n    // Storage scope for erc20 token benchmark transaction uniqueness.\n    // slot: _ERC20_TOKEN_BENCHMARK_SENTINEL => block.number\n    uint32 private constant _ERC20_TOKEN_BENCHMARK_SENTINEL = 0x83ceba49;\n\n    error InvalidBenchmark();\n\n    error InsufficientStipendForWithdrawalFallback();\n\n    constructor() {\n        // Deploy reference ERC20 for benchmarking generic ERC20 token withdrawals. Note\n        // that benchmark cannot be evaluated as part of contract creation as it requires\n        // that the token account is not already warm as part of deriving the benchmark.\n        _BENCHMARK_ERC20 = address(new BenchmarkERC20());\n    }\n\n    /**\n     * @notice External function to benchmark the gas costs of token transfers.\n     * Measures both native token and ERC20 token transfer costs and stores them.\n     * @param salt A bytes32 value used to derive a cold account for benchmarking.\n     */\n    function __benchmark(bytes32 salt)\n        external\n        payable\n        returns (uint256 nativeTransferBenchmark, uint256 erc20TransferBenchmark)\n    {\n        nativeTransferBenchmark = _getNativeTokenBenchmark(salt);\n        erc20TransferBenchmark = _getERC20TokenBenchmark();\n    }\n\n    /**\n     * @notice Internal function for benchmarking the cost of native token transfers.\n     * Uses a deterministic address derived from the contract address and provided salt\n     * to measure the gas cost to transfer native tokens to a cold address with no balance.\n     * @param salt A bytes32 value used to derive a cold account for benchmarking.\n     * @return benchmark The measured gas cost of the native token transfer.\n     */\n    function _getNativeTokenBenchmark(bytes32 salt) internal returns (uint256 benchmark) {\n        assembly (\"memory-safe\") {\n            // Derive the target for native token transfer using address.this & salt.\n            mstore(0, address())\n            mstore(0x20, salt)\n            let target := shr(0x60, keccak256(0x0c, 0x34))\n\n            // First: measure transfer cost to an uncreated account  note that the\n            // balance check prior to making the transfer will warm the account.\n            // Ensure callvalue is exactly 2 wei and the target balance is zero.\n            if or(iszero(eq(callvalue(), 2)), iszero(iszero(balance(target)))) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            // Get gas before first call.\n            let gasCheckpointOne := gas()\n\n            // Perform the first call, sending 1 wei.\n            let success1 := call(gas(), target, 1, codesize(), 0, codesize(), 0)\n\n            // Get gas before second call.\n            let gasCheckpointTwo := gas()\n\n            // Perform the second call, sending 1 wei.\n            let success2 := call(gas(), target, 1, codesize(), 0, codesize(), 0)\n\n            // Get gas after second call.\n            let gasCheckpointThree := gas()\n\n            // Derive a second address directly from the salt where a simple balance\n            // check can be performed to assess the cost of warming an account.\n            let balanceOne := balance(salt)\n\n            // Get gas after the first balance check.\n            let gasCheckpointFour := gas()\n\n            // Check balance again now that the account is warm.\n            let balanceTwo := balance(salt)\n\n            // Get gas after second balance check.\n            let gasCheckpointFive := gas()\n\n            // Determine the cost of the first transfer to the uncreated account.\n            let transferToWarmUncreatedAccountCost := sub(gasCheckpointOne, gasCheckpointTwo)\n\n            // Determine the difference between the cost of the first balance check\n            // and the cost of the second balance check.\n            let warmAccountAccessCost :=\n                sub(sub(gasCheckpointThree, gasCheckpointFour), sub(gasCheckpointFour, gasCheckpointFive))\n\n            // Ensure that both calls succeeded and that the cost of the first call\n            // exceeded that of the second, indicating that the account was created.\n            // Also ensure the first balance check cost exceeded the second, and use\n            // the balances to ensure the checks are not removed during optimization.\n            if or(\n                or(iszero(success1), iszero(success2)),\n                or(\n                    iszero(gt(transferToWarmUncreatedAccountCost, sub(gasCheckpointTwo, gasCheckpointThree))),\n                    or(iszero(warmAccountAccessCost), xor(balanceOne, balanceTwo))\n                )\n            ) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            // Derive benchmark cost using first transfer cost and warm access cost.\n            benchmark := add(transferToWarmUncreatedAccountCost, warmAccountAccessCost)\n        }\n    }\n\n    /**\n     * @notice Internal function for benchmarking the cost of ERC20 token transfers.\n     * Measures the gas cost of transferring tokens to a zero-balance account and\n     * includes the overhead of interacting with a cold token contract.\n     * @return benchmark The measured gas cost of the ERC20 token transfer.\n     */\n    function _getERC20TokenBenchmark() internal returns (uint256 benchmark) {\n        // Set the reference ERC20 as the token.\n        address token = _BENCHMARK_ERC20;\n\n        // Set the caller as the target.\n        address target = msg.sender;\n\n        assembly (\"memory-safe\") {\n            {\n                // Retrieve sentinel value.\n                let sentinel := sload(_ERC20_TOKEN_BENCHMARK_SENTINEL)\n\n                // Ensure it is not set to the current block number.\n                if eq(sentinel, number()) {\n                    mstore(0, 0x9f608b8a)\n                    revert(0x1c, 4)\n                }\n\n                // Store the current block number for the sentinel value.\n                sstore(_ERC20_TOKEN_BENCHMARK_SENTINEL, number())\n            }\n\n            // Store function selector for name().\n            mstore(0, 0x06fdde03)\n\n            let firstCallCost\n            let secondCallCost\n\n            {\n                // Get gas before first call.\n                let firstStart := gas()\n\n                // Perform the first call.\n                let success1 := call(gas(), token, 0, 0x1c, 4, codesize(), 0)\n\n                // Get gas before second call.\n                let secondStart := gas()\n\n                // Perform the second call.\n                let success2 := call(gas(), token, 0, 0x1c, 4, codesize(), 0)\n\n                // Get gas after second call.\n                let secondEnd := gas()\n\n                // Derive the benchmark cost of the call.\n                firstCallCost := sub(firstStart, secondStart)\n                secondCallCost := sub(secondStart, secondEnd)\n\n                // Ensure that both calls succeeded and that the cost of the first call\n                // exceeded that of the second, indicating that the account was not warm.\n                if or(or(iszero(success1), iszero(success2)), iszero(gt(firstCallCost, secondCallCost))) {\n                    mstore(0, 0x9f608b8a)\n                    revert(0x1c, 4)\n                }\n            }\n\n            // Get gas before third call.\n            let thirdStart := gas()\n\n            mstore(0x14, target) // Store target `to` argument in memory.\n            mstore(0x34, 1) // Store an `amount` argument of 1 in memory.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n\n            // Perform the third call and ensure it succeeds.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0, 0x20)\n                )\n            ) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n\n            // Get gas after third call.\n            let thirdEnd := gas()\n\n            // Derive the execution benchmark cost using the difference.\n            let thirdCallCost := sub(thirdStart, thirdEnd)\n\n            // Combine cost of first and third calls, and remove the second call due\n            // to the fact that a single call is performed, to derive the benchmark.\n            benchmark := sub(add(firstCallCost, thirdCallCost), secondCallCost)\n\n            // Burn the transferred tokens from the target.\n            mstore(0, 0x89afcb44)\n            mstore(0x20, target)\n            if iszero(call(gas(), token, 0, 0x1c, 0x24, codesize(), 0)) {\n                mstore(0, 0x9f608b8a)\n                revert(0x1c, 4)\n            }\n        }\n    }\n}\n"},"lib/the-compact/src/lib/Tstorish.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\n\ncontract Tstorish {\n    using EfficiencyLib for bool;\n    using EfficiencyLib for address;\n\n    // Declare a storage variable indicating when TSTORE support will be\n    // activated assuming it was not already active at initial deployment.\n    uint256 private _tstoreSupportActiveAt;\n\n    /*\n     * ------------------------------------------------------------------------+\n     * Opcode      | Mnemonic         | Stack              | Memory            |\n     * ------------------------------------------------------------------------|\n     * 60 0x02     | PUSH1 0x02       | 0x02               |                   |\n     * 60 0x1e     | PUSH1 0x1e       | 0x1e 0x02          |                   |\n     * 61 0x3d5c   | PUSH2 0x3d5c     | 0x3d5c 0x1e 0x02   |                   |\n     * 3d          | RETURNDATASIZE   | 0 0x3d5c 0x1e 0x02 |                   |\n     *                                                                         |\n     * :: store deployed bytecode in memory: (3d) RETURNDATASIZE (5c) TLOAD :: |\n     * 52          | MSTORE           | 0x1e 0x02          | [0..0x20): 0x3d5c |\n     * f3          | RETURN           |                    | [0..0x20): 0x3d5c |\n     * ------------------------------------------------------------------------+\n     */\n    uint80 constant _TLOAD_TEST_PAYLOAD = 0x6002_601e_613d5c_3d_52_f3;\n    uint8 constant _TLOAD_TEST_PAYLOAD_LENGTH = 0x0a;\n    uint8 constant _TLOAD_TEST_PAYLOAD_OFFSET = 0x16;\n\n    // Declare an immutable variable to store the tstore test contract address.\n    address private immutable _tloadTestContract;\n\n    // Declare an immutable variable to store the initial TSTORE support status.\n    bool private immutable _tstoreInitialSupport;\n\n    // Declare an immutable function type variable for the _setTstorish function\n    // based on chain support for tstore at time of deployment.\n    function(uint256,uint256) internal immutable _setTstorish;\n\n    // Declare an immutable function type variable for the _getTstorish function\n    // based on chain support for tstore at time of deployment.\n    function(uint256) view returns (uint256) internal immutable _getTstorish;\n\n    // Declare an immutable function type variable for the _clearTstorish function\n    // based on chain support for tstore at time of deployment.\n    function(uint256) internal immutable _clearTstorish;\n\n    // Declare a few custom revert error types.\n    error TStoreAlreadyActivated();\n    error TStoreNotSupported();\n    error TloadTestContractDeploymentFailed();\n\n    /**\n     * @dev Determine TSTORE availability during deployment. This involves\n     *      attempting to deploy a contract that utilizes TLOAD as part of the\n     *      contract construction bytecode, and configuring initial support for\n     *      using TSTORE in place of SSTORE based on the result.\n     */\n    constructor() {\n        // Deploy the contract testing TLOAD support and store the address.\n        address tloadTestContract = _prepareTloadTest();\n\n        // Ensure the deployment was successful.\n        if (tloadTestContract.isNullAddress()) {\n            revert TloadTestContractDeploymentFailed();\n        }\n\n        // Determine if TSTORE is supported.\n        bool tstoreInitialSupport = _testTload(tloadTestContract);\n\n        if (tstoreInitialSupport) {\n            // If TSTORE is supported, set functions to their versions that use\n            // tstore/tload directly without support checks.\n            _setTstorish = _setTstore;\n            _getTstorish = _getTstore;\n            _clearTstorish = _clearTstore;\n        } else {\n            // If TSTORE is not supported, set functions to their versions that\n            // fallback to sstore/sload until _tstoreSupportActiveAt is set to\n            // a block number before the current block number.\n            _setTstorish = _setTstorishWithSstoreFallback;\n            _getTstorish = _getTstorishWithSloadFallback;\n            _clearTstorish = _clearTstorishWithSstoreFallback;\n        }\n\n        _tstoreInitialSupport = tstoreInitialSupport;\n\n        // Set the address of the deployed TLOAD test contract as an immutable.\n        _tloadTestContract = tloadTestContract;\n    }\n\n    /**\n     * @dev External function to activate TSTORE usage. Does not need to be\n     *      called if TSTORE is supported from deployment, and only needs to be\n     *      called once. Reverts if TSTORE has already been activated or if the\n     *      opcode is not available.\n     */\n    function __activateTstore() external {\n        // Determine if TSTORE can potentially be activated.\n        if (_tstoreInitialSupport.or(_tstoreSupportActiveAt != 0)) {\n            assembly (\"memory-safe\") {\n                mstore(0, 0xf45b98b0) // `TStoreAlreadyActivated()`.\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Determine if TSTORE can be activated and revert if not.\n        if (!_testTload(_tloadTestContract)) {\n            assembly (\"memory-safe\") {\n                mstore(0, 0x70a4078f) // `TStoreNotSupported()`.\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Mark TSTORE as activated as of the next block.\n        unchecked {\n            _tstoreSupportActiveAt = block.number + 1;\n        }\n    }\n\n    /**\n     * @dev Private function to set a TSTORISH value. Assigned to _setTstorish\n     *      internal function variable at construction if chain has tstore support.\n     *\n     * @param storageSlot The slot to write the TSTORISH value to.\n     * @param value       The value to write to the given storage slot.\n     */\n    function _setTstore(uint256 storageSlot, uint256 value) private {\n        assembly (\"memory-safe\") {\n            tstore(storageSlot, value)\n        }\n    }\n\n    /**\n     * @dev Private function to set a TSTORISH value with sstore fallback.\n     *      Assigned to _setTstorish internal function variable at construction\n     *      if chain does not have tstore support.\n     *\n     * @param storageSlot The slot to write the TSTORISH value to.\n     * @param value       The value to write to the given storage slot.\n     */\n    function _setTstorishWithSstoreFallback(uint256 storageSlot, uint256 value) private {\n        if (_useSstoreFallback()) {\n            assembly (\"memory-safe\") {\n                sstore(storageSlot, value)\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                tstore(storageSlot, value)\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to read a TSTORISH value. Assigned to _getTstorish\n     *      internal function variable at construction if chain has tstore support.\n     *\n     * @param storageSlot The slot to read the TSTORISH value from.\n     *\n     * @return value The TSTORISH value at the given storage slot.\n     */\n    function _getTstore(uint256 storageSlot) private view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(storageSlot)\n        }\n    }\n\n    /**\n     * @dev Private function to read a TSTORISH value with sload fallback.\n     *      Assigned to _getTstorish internal function variable at construction\n     *      if chain does not have tstore support.\n     *\n     * @param storageSlot The slot to read the TSTORISH value from.\n     *\n     * @return value The TSTORISH value at the given storage slot.\n     */\n    function _getTstorishWithSloadFallback(uint256 storageSlot) private view returns (uint256 value) {\n        if (_useSstoreFallback()) {\n            assembly (\"memory-safe\") {\n                value := sload(storageSlot)\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                value := tload(storageSlot)\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to clear a TSTORISH value. Assigned to _clearTstorish internal\n     *      function variable at construction if chain has tstore support.\n     *\n     * @param storageSlot The slot to clear the TSTORISH value for.\n     */\n    function _clearTstore(uint256 storageSlot) private {\n        assembly (\"memory-safe\") {\n            tstore(storageSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Private function to clear a TSTORISH value with sstore fallback.\n     *      Assigned to _clearTstorish internal function variable at construction\n     *      if chain does not have tstore support.\n     *\n     * @param storageSlot The slot to clear the TSTORISH value for.\n     */\n    function _clearTstorishWithSstoreFallback(uint256 storageSlot) private {\n        if (_useSstoreFallback()) {\n            assembly (\"memory-safe\") {\n                sstore(storageSlot, 0)\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                tstore(storageSlot, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to deploy a test contract that utilizes TLOAD as\n     *      part of its fallback logic.\n     */\n    function _prepareTloadTest() private returns (address contractAddress) {\n        // Utilize assembly to deploy a contract testing TLOAD support.\n        assembly (\"memory-safe\") {\n            // Write the contract deployment code payload to scratch space.\n            mstore(0, _TLOAD_TEST_PAYLOAD)\n\n            // Deploy the contract.\n            contractAddress := create(0, _TLOAD_TEST_PAYLOAD_OFFSET, _TLOAD_TEST_PAYLOAD_LENGTH)\n        }\n    }\n\n    /**\n     * @dev Private view function to determine if TSTORE/TLOAD are supported by\n     *      the current EVM implementation by attempting to call the test\n     *      contract, which utilizes TLOAD as part of its fallback logic.\n     */\n    function _testTload(address tloadTestContract) private view returns (bool ok) {\n        // Call the test contract, which will perform a TLOAD test. If the call\n        // does not revert, then TLOAD/TSTORE is supported. Do not forward all\n        // available gas, as all forwarded gas will be consumed on revert.\n        // Note that this assumes that the contract was successfully deployed.\n        assembly (\"memory-safe\") {\n            ok := staticcall(div(gas(), 10), tloadTestContract, 0, 0, 0, 0)\n        }\n    }\n\n    /**\n     * @dev Private view function to determine whether the sstore fallback must\n     *      still be utilized. In cases where tstore is not supported at the time\n     *      of initial deployment but becomes supported by the EVM environment,\n     *      __activateTstore() can be called to schedule activation as of the\n     *      next block. This prevents potential reentrancy during mid-transaction\n     *      activations where Tstorish is used to implement a reentrancy guard.\n     *\n     * @return useSstore A boolean indicating whether to use the sstore fallback.\n     */\n    function _useSstoreFallback() private view returns (bool useSstore) {\n        assembly (\"memory-safe\") {\n            // Load the storage slot tracking the tstore activation block number.\n            let tstoreSupportActiveAt := sload(_tstoreSupportActiveAt.slot)\n\n            // Use sstore if no value is set or if value is greater than current block number.\n            useSstore := or(iszero(tstoreSupportActiveAt), gt(tstoreSupportActiveAt, number()))\n        }\n    }\n}\n"},"lib/the-compact/src/lib/ClaimHashFunctionCastLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Claim } from \"../types/Claims.sol\";\n\nimport { BatchClaim } from \"../types/BatchClaims.sol\";\n\nimport { MultichainClaim, ExogenousMultichainClaim } from \"../types/MultichainClaims.sol\";\n\nimport { BatchMultichainClaim, ExogenousBatchMultichainClaim } from \"../types/BatchMultichainClaims.sol\";\n\n/**\n * @title ClaimHashFunctionCastLib\n * @notice Library contract implementing function casts used throughout the codebase,\n * particularly as part of processing claims. The input function operates on a\n * function that takes some argument that differs from what is currently available.\n * The output function modifies one or more argument types so that they match the\n * arguments that are being used to call the function. Note that from the perspective\n * of the function being modified, the original type is still in force; great care\n * should be taken to preserve offsets and general structure between the two structs.\n * @dev Note that some of these function casts may no longer be in use.\n */\nlibrary ClaimHashFunctionCastLib {\n    /**\n     * @notice Function cast to provide a BatchMultichainClaim calldata struct\n     * while treating it as a uint256 representing a calldata pointer location with witness data.\n     * @param fnIn   Function pointer to `ClaimHashLib._toGenericMultichainClaimWithWitnessMessageHash`.\n     * @return fnOut Modified function used in `ClaimHashLib.toMessageHashes(BatchMultichainClaim calldata)`.\n     */\n    function usingBatchMultichainClaim(\n        function (uint256, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n            fnIn\n    )\n        internal\n        pure\n        returns (\n            function (BatchMultichainClaim calldata, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n                fnOut\n        )\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide an ExogenousBatchMultichainClaim calldata\n     * struct while treating it as a uint256 representing a calldata pointer location with witness data.\n     * @param fnIn   Function pointer to `ClaimHashLib._toGenericMultichainClaimWithWitnessMessageHash`.\n     * @return fnOut Modified function used in `ClaimHashLib.toMessageHashes(ExogenousBatchMultichainClaim calldata)`.\n     */\n    function usingExogenousBatchMultichainClaim(\n        function (uint256, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n            fnIn\n    )\n        internal\n        pure\n        returns (\n            function (ExogenousBatchMultichainClaim calldata, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n                fnOut\n        )\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a Claim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `HashLib.toClaimHash(uint256)`.\n     * @return fnOut Modified function used in `ClaimHashLib.toMessageHashes(Claim calldata)`.\n     */\n    function usingClaim(function (uint256) internal view returns (bytes32, bytes32) fnIn)\n        internal\n        pure\n        returns (function (Claim calldata) internal view returns (bytes32, bytes32) fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a BatchClaim calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `HashLib.toBatchClaimHash(uint256, uint256)`.\n     * @return fnOut Modified function used in `BatchClaim.toMessageHashes(BatchClaimWithWitness calldata)`.\n     */\n    function usingBatchClaim(function (uint256, uint256) internal view returns (bytes32, bytes32) fnIn)\n        internal\n        pure\n        returns (function (BatchClaim calldata, uint256) internal view returns (bytes32, bytes32) fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a MultichainClaimWithWitness calldata struct while\n     * treating it as a uint256 representing a calldata pointer location with witness data.\n     * @param fnIn   Function pointer to `ClaimHashLib._toGenericMultichainClaimWithWitnessMessageHash`.\n     * @return fnOut Modified function used in `ClaimHashLib.toMessageHashes(MultichainClaimWithWitness calldata)`.\n     */\n    function usingMultichainClaimWithWitness(\n        function (uint256, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n            fnIn\n    )\n        internal\n        pure\n        returns (\n            function (MultichainClaim calldata, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n                fnOut\n        )\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a MultichainClaimWithWitness calldata struct while\n     * treating it as a uint256 representing a calldata pointer location with witness data.\n     * @param fnIn   Function pointer to `ClaimHashLib._toGenericMultichainClaimWithWitnessMessageHash`.\n     * @return fnOut Modified function used in `ClaimHashLib.toMessageHashes(MultichainClaimWithWitness calldata)`.\n     */\n    function usingExogenousMultichainClaimWithWitness(\n        function (uint256, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n            fnIn\n    )\n        internal\n        pure\n        returns (\n            function (ExogenousMultichainClaim calldata, uint256, function (uint256, uint256, bytes32, bytes32, uint256) internal view returns (bytes32)) internal view returns (bytes32, bytes32)\n                fnOut\n        )\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a MultichainClaimWithWitness calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimHashLib._toMultichainClaimWithWitnessMessageHash(MultichainClaimWithWitness calldata)`.\n     * @return fnOut Modified function used in `ClaimHashLib._toMultichainClaimWithWitnessMessageHash(MultichainClaimWithWitness calldata)`.\n     */\n    function usingMultichainClaimWithWitness(function (uint256) internal pure returns (uint256) fnIn)\n        internal\n        pure\n        returns (function (MultichainClaim calldata) internal pure returns (uint256) fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n\n    /**\n     * @notice Function cast to provide a MultichainClaimWithWitness calldata struct while\n     * treating it as a uint256 representing a calldata pointer location.\n     * @param fnIn   Function pointer to `ClaimHashLib._toMultichainClaimWithWitnessMessageHash(MultichainClaimWithWitness calldata)`.\n     * @return fnOut Modified function used in `ClaimHashLib._toMultichainClaimWithWitnessMessageHash(MultichainClaimWithWitness calldata)`.\n     */\n    function usingExogenousMultichainClaimWithWitness(function (uint256) internal pure returns (uint256) fnIn)\n        internal\n        pure\n        returns (function (ExogenousMultichainClaim calldata) internal pure returns (uint256) fnOut)\n    {\n        assembly (\"memory-safe\") {\n            fnOut := fnIn\n        }\n    }\n}\n"},"lib/the-compact/src/interfaces/IEmissary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IEmissary {\n    /**\n     * @notice Verify a claim. Called from The Compact as part of claim processing.\n     * @param sponsor    The sponsor of the claim.\n     * @param digest     The message digest representing the claim on the norarized hain.\n     * @param claimHash  The message hash representing the claim.\n     * @param signature  The signature to verify.\n     * @param lockTag    The lock tag containing allocator ID, reset period, and scope.\n     * @return           Must return the function selector (0xcd4d6588).\n     */\n    function verifyClaim(address sponsor, bytes32 digest, bytes32 claimHash, bytes calldata signature, bytes12 lockTag)\n        external\n        view\n        returns (bytes4);\n}\n"},"lib/the-compact/src/lib/MetadataLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ITheCompact } from \"../interfaces/ITheCompact.sol\";\nimport { ResetPeriod } from \"../types/ResetPeriod.sol\";\nimport { Scope } from \"../types/Scope.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\nimport { LibString } from \"solady/utils/LibString.sol\";\nimport { MetadataReaderLib } from \"solady/utils/MetadataReaderLib.sol\";\nimport { Base64 } from \"solady/utils/Base64.sol\";\n\n/**\n * @title MetadataLib\n * @notice Library contract implementing logic for deriving and displaying\n * ERC6909 metadata as well as metadata specific to various underlying tokens.\n */\nlibrary MetadataLib {\n    using EfficiencyLib for Scope;\n    using EfficiencyLib for ResetPeriod;\n    using EfficiencyLib for address;\n    using EfficiencyLib for uint96;\n    using IdLib for address;\n    using IdLib for uint96;\n    using LibString for string;\n    using LibString for address;\n    using LibString for uint256;\n    using LibString for uint96;\n    using MetadataReaderLib for address;\n    using MetadataLib for address;\n    using MetadataLib for ResetPeriod;\n    using MetadataLib for Scope;\n    using MetadataLib for Lock;\n\n    struct Lock {\n        address token;\n        address allocator;\n        ResetPeriod resetPeriod;\n        Scope scope;\n    }\n\n    /**\n     * @notice Internal pure function for converting a ResetPeriod enum to a human-readable string.\n     * @param resetPeriod The ResetPeriod enum value to convert.\n     * @return resetPeriodString A string representation of the reset period.\n     */\n    function toString(ResetPeriod resetPeriod) internal pure returns (string memory resetPeriodString) {\n        // Equivalent to:\n        // if (resetPeriod == ResetPeriod.OneSecond) {\n        //     return \"1s\";\n        // } else if (resetPeriod == ResetPeriod.FifteenSeconds) {\n        //     return \"15s\";\n        // } else if (resetPeriod == ResetPeriod.OneMinute) {\n        //     return \"1m\";\n        // } else if (resetPeriod == ResetPeriod.TenMinutes) {\n        //     return \"10m\";\n        // } else if (resetPeriod == ResetPeriod.OneHourAndFiveMinutes) {\n        //     return \"1h 5m\";\n        // } else if (resetPeriod == ResetPeriod.OneDay) {\n        //     return \"24h\";\n        // } else if (resetPeriod == ResetPeriod.SevenDaysAndOneHour) {\n        //     return \"7d 1h\";\n        // } else {\n        //     return \"30d\";\n        // }\n\n        bytes4 chunk;\n        uint256 length;\n        assembly (\"memory-safe\") {\n            chunk :=\n                shl(0xe0, shr(shl(5, resetPeriod), 0x3330640037643168323468003168356d31306d00316d00003135730031730000))\n            let lastByteIsZero := iszero(shl(0x18, chunk))\n            length := sub(5, add(shl(1, lastByteIsZero), iszero(shl(0x10, chunk))))\n            if iszero(lastByteIsZero) {\n                chunk :=\n                    xor(shl(0xe8, xor(and(0xffff00, shr(0xe8, chunk)), 0x20)), shl(0xd8, and(0xffff, shr(0xe0, chunk))))\n            }\n        }\n\n        resetPeriodString = new string(length);\n\n        assembly (\"memory-safe\") {\n            mstore(add(resetPeriodString, 0x20), chunk)\n        }\n    }\n\n    /**\n     * @notice Internal pure function for converting a Scope enum to a human-readable string.\n     * @param scope The Scope enum value to convert.\n     * @return A string representation of the scope.\n     */\n    function toString(Scope scope) internal pure returns (string memory) {\n        // Equivalent to:\n        // if (scope == Scope.Multichain) {\n        //     return \"Multichain\";\n        // } else {\n        //     return \"Chain-specific\";\n        // }\n\n        string memory scopeString = new string(14);\n        assembly (\"memory-safe\") {\n            mstore(\n                add(scopeString, 0x1f),\n                shl(\n                    add(0x88, shl(5, iszero(scope))),\n                    shr(mul(0x78, iszero(scope)), 0x0a4d756c7469636861696e0e436861696e2d7370656369666963)\n                )\n            )\n        }\n        return scopeString;\n    }\n\n    function toLockDetails(uint256 id, address theCompact)\n        internal\n        view\n        returns (address token, address allocator, ResetPeriod resetPeriod, Scope scope)\n    {\n        (token, allocator, resetPeriod, scope,) = ITheCompact(theCompact).getLockDetails(id);\n    }\n\n    /**\n     * @notice Internal view function for generating a token URI for a given lock and ID.\n     * @param token       The address of the underlying token (or address(0) for native tokens).\n     * @param allocator   The address of the allocator mediating the resource lock.\n     * @param resetPeriod The duration after which the underlying tokens can be withdrawn once a forced withdrawal is initiated.\n     * @param scope       The scope of the resource lock (multichain or single chain).\n     * @param id          The ERC6909 token identifier.\n     * @return uri A JSON string containing token metadata.\n     */\n    function toURI(address token, address allocator, ResetPeriod resetPeriod, Scope scope, uint256 id)\n        internal\n        view\n        returns (string memory uri)\n    {\n        Lock memory lock = Lock({ token: token, allocator: allocator, resetPeriod: resetPeriod, scope: scope });\n        string memory name = string.concat('{\"name\": \"Compact ', lock.token.readSymbolWithDefaultValue(), '\",');\n        string memory image;\n        {\n            // Generate dynamic SVG and Base64 encode it\n            string memory svg = _generateSvgImage(lock);\n            string memory encodedSvg = Base64.encode(bytes(svg));\n            image = string.concat('\"image\": \"data:image/svg+xml;base64,', encodedSvg, '\",');\n        }\n\n        uri = string.concat(name, _getDescription(lock), image, _getAttributes(lock, id));\n    }\n\n    /**\n     * @notice Internal view function for generating the attributes section of the token metadata.\n     * @param lock The lock.\n     * @param id The ERC6909 token identifier.\n     * @return attributes The attributes section of the token metadata.\n     */\n    function _getAttributes(Lock memory lock, uint256 id) internal view returns (string memory attributes) {\n        // Initialize the attributes string and add Token details\n        {\n            (\n                string memory tokenAddress,\n                string memory tokenName,\n                string memory tokenSymbol,\n                string memory tokenDecimals\n            ) = _getTokenDetails(lock);\n\n            attributes = string.concat(\n                '\"attributes\": [',\n                _makeAttribute(\"ID\", id.toHexString(), false, true),\n                _makeAttribute(\"Token Address\", tokenAddress, false, true),\n                _makeAttribute(\"Token Name\", tokenName, false, true),\n                _makeAttribute(\"Token Symbol\", tokenSymbol, false, true),\n                _makeAttribute(\"Token Decimals\", tokenDecimals, false, false)\n            );\n        }\n\n        // Allocator & Lock details, then close the JSON array and object\n        {\n            attributes = string.concat(\n                attributes,\n                _makeAttribute(\"Allocator Address\", lock.allocator.toHexStringChecksummed(), false, true),\n                _makeAttribute(\"Allocator Name\", _tryReadAllocatorName(lock.allocator), false, true),\n                _makeAttribute(\"Scope\", lock.scope.toString(), false, true),\n                _makeAttribute(\"Reset Period\", lock.resetPeriod.toString(), false, true),\n                _makeAttribute(\"Lock Tag\", uint96(lock.toLockTag()).toHexString(), false, true),\n                _makeAttribute(\"Origin Chain\", block.chainid.toString(), true, true),\n                \"]}\"\n            );\n        }\n    }\n\n    /**\n     * @notice Internal view function for generating the description section of the token metadata.\n     * @param lock The lock containing token, allocator, reset period, and scope information.\n     * @return description The description section of the token metadata as a JSON string.\n     */\n    function _getDescription(Lock memory lock) internal view returns (string memory description) {\n        (string memory tokenAddress, string memory tokenName,,) = _getTokenDetails(lock);\n        string memory allocatorName = _tryReadAllocatorName(lock.allocator);\n        string memory resetPeriod = lock.resetPeriod.toString();\n        string memory scope = lock.scope.toString();\n        description = string.concat(\n            '\"description\": \"[The Compact v1] ',\n            tokenName,\n            \" (\",\n            tokenAddress,\n            \") resource lock using \",\n            allocatorName,\n            \" (\",\n            lock.allocator.toHexStringChecksummed(),\n            \"), \",\n            scope,\n            \" scope, and a \",\n            resetPeriod,\n            ' reset period\",'\n        );\n    }\n\n    /**\n     * @notice Internal view function for retrieving token details.\n     * @param lock The lock containing the token address.\n     * @return tokenAddress The token's address as a checksummed hex string.\n     * @return tokenName The token's name or a default value if not available.\n     * @return tokenSymbol The token's symbol or a default value if not available.\n     * @return tokenDecimals The token's decimals as a string or a default value if not available.\n     */\n    function _getTokenDetails(Lock memory lock)\n        internal\n        view\n        returns (\n            string memory tokenAddress,\n            string memory tokenName,\n            string memory tokenSymbol,\n            string memory tokenDecimals\n        )\n    {\n        tokenAddress = lock.token.toHexStringChecksummed();\n        tokenName = lock.token.readNameWithDefaultValue();\n        tokenSymbol = lock.token.readSymbolWithDefaultValue();\n        tokenDecimals = uint256(lock.token.readDecimalsAsUint8WithDefaultValue()).toString();\n    }\n\n    /**\n     * @notice Internal view function to generate a dynamic SVG image for the token.\n     * @param lock The lock containing token, allocator, reset period, and scope information.\n     * @return A string containing the complete SVG image markup.\n     */\n    function _generateSvgImage(Lock memory lock) internal view returns (string memory) {\n        return string.concat(\n            '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n            _getSvgDefs(lock),\n            _getSvgBackground(),\n            _getSvgBorder(),\n            _getSvgAnimatedText(lock),\n            _getSvgTitleSection(lock),\n            _getSvgDetailsSection(lock),\n            \"</svg>\"\n        );\n    }\n\n    /**\n     * @notice Dynamically generate a color scheme based on a given token address.\n     * @param token The address of the token to generate colors for.\n     * @return bgColor1 The first background color.\n     * @return bgColor2 The second background color.\n     * @return bgColor3 The third background color.\n     */\n    function _generateColors(address token) internal pure returns (string memory, string memory, string memory) {\n        bytes32 tokenHash = keccak256(abi.encodePacked(token));\n\n        string memory bgColor1 = LibString.toHexStringNoPrefix(uint24(bytes3(tokenHash)));\n        string memory bgColor2 =\n            LibString.toHexStringNoPrefix(uint24(bytes3(bytes32(uint256(uint256(tokenHash) >> 96)))));\n        string memory bgColor3 =\n            LibString.toHexStringNoPrefix(uint24(bytes3(bytes32(uint256(uint256(tokenHash) >> 192)))));\n\n        return (bgColor1, bgColor2, bgColor3);\n    }\n\n    /**\n     * @notice Returns the SVG definitions section with filters, gradients, and paths.\n     * @param lock The lock containing the token address used for color generation.\n     * @return A string containing the SVG definitions markup.\n     */\n    function _getSvgDefs(Lock memory lock) internal pure returns (string memory) {\n        (string memory bgColor1, string memory bgColor2, string memory bgColor3) = _generateColors(lock.token);\n\n        // Filter definitions for background generation (used to create the gradient effect)\n        string memory filterDefs = string.concat(\n            // feImage 1 (main background)\n            '<defs><filter id=\"f1\"><feImage result=\"p0\" xlink:href=\"data:image/svg+xml;base64,',\n            Base64.encode(\n                bytes(\n                    string.concat(\n                        '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"500px\" height=\"290px\" fill=\"#',\n                        bgColor1,\n                        '\"/></svg>'\n                    )\n                )\n            ),\n            // feImage 2 (first circle overlay)\n            '\"/><feImage result=\"p1\" xlink:href=\"data:image/svg+xml;base64,',\n            Base64.encode(\n                bytes(\n                    string.concat(\n                        '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"400\" cy=\"100\" r=\"150px\" fill=\"#',\n                        bgColor2,\n                        '\"/></svg>'\n                    )\n                )\n            ),\n            // feImage 3 (second circle overlay)\n            '\"/><feImage result=\"p2\" xlink:href=\"data:image/svg+xml;base64,',\n            Base64.encode(\n                bytes(\n                    string.concat(\n                        '<svg width=\"500\" height=\"290\" viewBox=\"0 0 500 290\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"120\" cy=\"200\" r=\"120px\" fill=\"#',\n                        bgColor3,\n                        '\"/></svg>'\n                    )\n                )\n            ),\n            // Blending directives (enhances the gradient effect), Blur filter (makes the gradient smoother), Drop shadow filter (makes the text more readable)\n            '\"/><feBlend mode=\"overlay\" in=\"p0\" in2=\"p1\" /><feBlend mode=\"exclusion\" in2=\"p2\" /><feGaussianBlur stdDeviation=\"42\" /></filter><filter id=\"tb\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"24\" /></filter><filter id=\"ts\" x=\"-20%\" y=\"-20%\" width=\"140%\" height=\"140%\"><feDropShadow dx=\"0\" dy=\"0\" stdDeviation=\"1\" flood-opacity=\"0.8\" flood-color=\"black\" /></filter>'\n        );\n\n        return filterDefs.concat(\n            // Outer clip path (clips the entire SVG), Path for the animated text (creates a looped animation), & Gradient mask for the title text (fades out towards the right edge of the canvas)\n            '<clipPath id=\"c\"><rect width=\"500\" height=\"290\" rx=\"42\" ry=\"42\" /></clipPath><path id=\"tp\" d=\"M40 12 H460 A28 28 0 0 1 488 40 V250 A28 28 0 0 1 460 278 H40 A28 28 0 0 1 12 250 V40 A28 28 0 0 1 40 12 z\" /><linearGradient id=\"gs\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\"><stop offset=\"0.7\" stop-color=\"white\" stop-opacity=\"1\" /><stop offset=\".95\" stop-color=\"white\" stop-opacity=\"0\" /></linearGradient><mask id=\"fs\" maskContentUnits=\"userSpaceOnUse\"><rect width=\"440px\" height=\"200px\" fill=\"url(#gs)\" /></mask></defs>'\n        );\n    }\n\n    /**\n     * @notice Returns the SVG background section with gradient and filter effects.\n     * @return A string containing the SVG background markup.\n     */\n    function _getSvgBackground() internal pure returns (string memory) {\n        return\n        '<g clip-path=\"url(#c)\"><rect fill=\"none\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"290px\" /><rect style=\"filter: url(#f1)\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"290px\" /><g style=\"filter:url(#tb); transform:scale(1.5); transform-origin:left top;\"><rect fill=\"none\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"290px\" /><ellipse cx=\"25%\" cy=\"0px\" rx=\"180px\" ry=\"120px\" fill=\"#000\" opacity=\"0.85\" /></g></g>';\n    }\n\n    /**\n     * @notice Returns the SVG border elements that frame the token image.\n     * @return A string containing the SVG border markup.\n     */\n    function _getSvgBorder() internal pure returns (string memory) {\n        return\n        '<rect x=\"0\" y=\"0\" width=\"500\" height=\"290\" rx=\"42\" ry=\"42\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.2)\" /><rect x=\"16\" y=\"16\" width=\"468\" height=\"258\" rx=\"26\" ry=\"26\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.2)\" />';\n    }\n\n    /**\n     * @notice Returns the SVG animated text that moves along the border.\n     * @return The SVG animated text.\n     */\n    function _getSvgAnimatedText(Lock memory lock) internal view returns (string memory) {\n        (string memory tokenAddress, string memory tokenName, string memory tokenSymbol,) = _getTokenDetails(lock);\n        string memory middot = unicode\"  \";\n        string memory token = string.concat(\n            tokenName,\n            middot,\n            tokenSymbol,\n            middot,\n            tokenAddress,\n            middot,\n            \"Lock Tag \",\n            uint96(toLockTag(lock)).toHexString()\n        );\n        string memory allocator = string.concat(\n            \"The Compact v1\",\n            middot,\n            lock.scope.toString(),\n            \" Resource Lock\",\n            middot,\n            _tryReadAllocatorName(lock.allocator),\n            \" @ \",\n            lock.allocator.toHexStringChecksummed()\n        );\n\n        // Paths are duplicated to create a looped animation\n        return string.concat(\n            '<text text-rendering=\"optimizeSpeed\" filter=\"url(#ts)\">',\n            _getTextPath(token, \"-100%\"),\n            _getTextPath(token, \"0%\"),\n            _getTextPath(allocator, \"50%\"),\n            _getTextPath(allocator, \"-50%\"),\n            \"</text>\"\n        );\n    }\n\n    /**\n     * @notice Builds a textPath element that moves along the border.\n     * @param text The text to display.\n     * @param startOffset The starting offset of the text.\n     * @return The SVG animated text.\n     */\n    function _getTextPath(string memory text, string memory startOffset) internal pure returns (string memory) {\n        return string.concat(\n            '<textPath startOffset=\"',\n            startOffset,\n            '\" fill=\"white\" font-family=\"monospace\" font-size=\"10px\" xlink:href=\"#tp\">',\n            text,\n            '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath>'\n        );\n    }\n\n    /**\n     * @notice Returns the SVG title section.\n     * @param lock The lock.\n     * @return The SVG title section.\n     */\n    function _getSvgTitleSection(Lock memory lock) internal view returns (string memory) {\n        (,, string memory tokenSymbol,) = _getTokenDetails(lock);\n        string memory scope = lock.scope.toString();\n        string memory lockId = lock.toId().toHexString();\n        return string.concat(\n            '<g id=\"title\"><text y=\"60px\" x=\"32px\" fill=\"white\" font-family=\"monospace\" font-weight=\"100\" font-size=\"32px\" filter=\"url(#ts)\">Compact ',\n            tokenSymbol,\n            '</text><text y=\"90px\" x=\"32px\" fill=\"rgba(255,255,255,0.6)\" font-family=\"monospace\" font-weight=\"50\" font-size=\"22px\" filter=\"url(#ts)\">',\n            scope,\n            ' Resource Lock</text><text y=\"110px\" x=\"32px\" fill=\"rgba(255,255,255,0.6)\" font-family=\"monospace\" font-weight=\"100\" font-size=\"10px\" filter=\"url(#ts)\">ID: ',\n            lockId,\n            \"</text></g>\"\n        );\n    }\n\n    /**\n     * @notice Returns the SVG details section\n     * @dev This section contains the details of the lock, including the token, allocator, and reset period.\n     * @param lock The lock.\n     * @return The SVG details section.\n     */\n    function _getSvgDetailsSection(Lock memory lock) internal view returns (string memory) {\n        (, string memory tokenName, string memory tokenSymbol,) = _getTokenDetails(lock);\n        string memory allocatorName = _tryReadAllocatorName(lock.allocator);\n        string memory resetPeriod = lock.resetPeriod.toString();\n        string memory scope = lock.scope.toString();\n        // Handshake Icon\n        string memory iconSvg =\n            unicode'<g style=\"transform:translate(420px, 50px)\"><text x=\"20px\" y=\"28px\" text-anchor=\"middle\" font-size=\"64px\" opacity=\"0.4\">';\n\n        // Detail Boxes\n        string memory detailBoxesSvg = string.concat(\n            // Left column & Locked Token\n            '</text></g><g style=\"transform:translate(32px, 140px)\"><rect width=\"200px\" height=\"64px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"rgba(255,255,255,0.6)\">Locked Token: </text>',\n            _makeWrappable(string.concat(tokenName, \" (\", tokenSymbol, \")\"), \"190px\", \"40px\"),\n            // Reset Period\n            '</g><g style=\"transform:translate(32px, 212px)\"><rect width=\"200px\" height=\"26px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"white\"><tspan fill=\"rgba(255,255,255,0.6)\">Reset Period: </tspan>',\n            resetPeriod,\n            // Right column & Allocator\n            '</text></g><g style=\"transform:translate(260px, 140px)\"><rect width=\"210px\" height=\"64px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"rgba(255,255,255,0.6)\">Allocator: </text>',\n            _makeWrappable(allocatorName, \"190px\", \"40px\"),\n            // Resource lock tag\n            '</g><g style=\"transform:translate(260px, 212px)\"><rect width=\"210px\" height=\"26px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"12px\" y=\"17px\" font-family=\"monospace\" font-size=\"12px\" fill=\"white\"><tspan fill=\"rgba(255,255,255,0.6)\">Scope: </tspan>',\n            scope,\n            // Bottom row (Origin Chain)\n            '</text></g><g><text x=\"50%\" y=\"260px\" font-family=\"monospace\" font-size=\"12px\" fill=\"white\" text-anchor=\"middle\" filter=\"url(#ts)\"><tspan fill=\"rgba(255,255,255,0.6)\">Origin Chain: </tspan>',\n            LibString.toString(block.chainid),\n            \"</text></g>\"\n        );\n\n        return iconSvg.concat(detailBoxesSvg);\n    }\n\n    /**\n     * @notice Internal pure function for formatting a metadata attribute as a JSON string.\n     * @param trait      The trait name.\n     * @param value      The trait value.\n     * @param terminal   Whether this is the last attribute in the list.\n     * @param quoted     Whether the value should be quoted.\n     * @return attribute The formatted attribute string.\n     */\n    function _makeAttribute(string memory trait, string memory value, bool terminal, bool quoted)\n        internal\n        pure\n        returns (string memory attribute)\n    {\n        string memory maybeQuote = quoted ? '\"' : \"\";\n        string memory terminator = terminal ? \"}\" : \"},\";\n        attribute = string.concat('{\"trait_type\": \"', trait, '\", \"value\": ', maybeQuote, value, maybeQuote, terminator);\n    }\n\n    /**\n     * @notice Wraps text in a foreignObject element to allow for text wrapping.\n     * @param text The text to wrap.\n     * @param width The width of the foreignObject.\n     * @param height The height of the foreignObject.\n     * @return The wrapped text.\n     */\n    function _makeWrappable(string memory text, string memory width, string memory height)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(\n            '<foreignObject x=\"12px\" y=\"22px\" width=\"',\n            width,\n            '\" height=\"',\n            height,\n            '\"><span xmlns=\"http://www.w3.org/1999/xhtml\" style=\"font-family: monospace;font-size: 14px;color: white;\">',\n            text,\n            \"</span></foreignObject>\"\n        );\n    }\n\n    /**\n     * @notice Try to read the name from the allocator contract.\n     * @param allocatorAddress The address of the allocator.\n     * @return The name of the allocator or \"Unnamed Allocator\" if not readable.\n     */\n    function _tryReadAllocatorName(address allocatorAddress) internal view returns (string memory) {\n        string memory name = allocatorAddress.readName();\n        if (bytes(name).length == 0) {\n            name = \"Unnamed Allocator\";\n        }\n        return name;\n    }\n\n    /**\n     * @notice Internal view function for retrieving a token's name with a fallback value.\n     * @param token The address of the token.\n     * @return name The token's name or a default value if not available.\n     */\n    function readNameWithDefaultValue(address token) internal view returns (string memory name) {\n        // Use \"Native Token\" as the default name for address(0). Note that this will not be the\n        // correct name on some chains.\n        if (token == address(0)) {\n            return \"Native Token\";\n        }\n\n        name = token.readName().escapeJSON();\n        if (bytes(name).length == 0) {\n            name = \"Unknown Token\";\n        }\n    }\n\n    /**\n     * @notice Internal view function for retrieving a token's symbol with a fallback value.\n     * @param token   The address of the token.\n     * @return symbol The token's symbol or a default value if not available.\n     */\n    function readSymbolWithDefaultValue(address token) internal view returns (string memory symbol) {\n        // Use \"ETH\" as the default symbol for address(0). Note that this will not be the\n        // correct symbol on some chains.\n        if (token.isNullAddress()) {\n            return \"ETH\";\n        }\n\n        symbol = token.readSymbol().escapeJSON();\n        if (bytes(symbol).length == 0) {\n            symbol = \"???\";\n        }\n    }\n\n    /**\n     * @notice Internal view function for retrieving a token's decimals as a uint8 with a fallback value.\n     * @param token     The address of the token.\n     * @return decimals The token's decimals as a uint8 or a default value if not available.\n     */\n    function readDecimalsAsUint8WithDefaultValue(address token) internal view returns (uint8 decimals) {\n        if (token.isNullAddress()) {\n            return 18;\n        }\n        decimals = token.readDecimals();\n    }\n\n    /**\n     * @notice Internal pure function for generating a lock tag from a lock.\n     * @param lock The lock.\n     * @return lockTag The lock tag.\n     */\n    function toLockTag(Lock memory lock) internal pure returns (bytes12) {\n        uint96 allocatorId = lock.allocator.toAllocatorId();\n        return allocatorId.toLockTag(lock.scope, lock.resetPeriod);\n    }\n\n    /**\n     * @notice Internal pure function for deriving a resource lock ID from lock details.\n     * @param lock The lock.\n     * @return id The ID.\n     */\n    function toId(Lock memory lock) internal pure returns (uint256 id) {\n        id = (\n            (lock.scope.asUint256() << 255) | (lock.resetPeriod.asUint256() << 252)\n                | (lock.allocator.toAllocatorId().asUint256() << 160) | lock.token.asUint256()\n        );\n    }\n}\n"},"lib/the-compact/src/lib/BenchmarkERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { ERC20 } from \"solady/tokens/ERC20.sol\";\nimport { EfficiencyLib } from \"./EfficiencyLib.sol\";\n\n/**\n * @title BenchmarkERC20\n * @notice Contract implementing a simple ERC20 token used for benchmarking purposes.\n * The deployer receives the maximum possible token supply and has exclusive rights\n * to burn tokens from any address.\n */\ncontract BenchmarkERC20 is ERC20 {\n    using EfficiencyLib for bool;\n\n    address private immutable deployer;\n\n    /**\n     * @notice Error thrown when a non-deployer address attempts to burn tokens or\n     * when the target for the token burn is the deployer address.\n     */\n    error InvalidBurn();\n\n    /**\n     * @notice Returns the name of the token.\n     * @return The name of the token as a string.\n     */\n    function name() public view virtual override returns (string memory) {\n        return \"Benchmark ERC20\";\n    }\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return The symbol of the token as a string.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return \"BENCHMARK_ERC20\";\n    }\n\n    /**\n     * @notice Constructor that sets the deployer address and mints the maximum\n     * possible token supply to the deployer.\n     */\n    constructor() {\n        deployer = msg.sender;\n\n        _mint(deployer, type(uint256).max);\n    }\n\n    /**\n     * @notice Burns all tokens from a target address. Can only be called by the deployer.\n     * @param target The address from which to burn all tokens.\n     */\n    function burn(address target) external {\n        if ((msg.sender != deployer).or(target == deployer)) {\n            revert InvalidBurn();\n        }\n\n        _burn(target, balanceOf(target));\n    }\n}\n"},"lib/solady/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibBytes} from \"./LibBytes.sol\";\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STRUCTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Goated string storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native string storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so its mad tight.\n    struct StringStorage {\n        bytes32 _spacer;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for '0123456789'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for '01234567'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for ' \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                 STRING STORAGE OPERATIONS                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function set(StringStorage storage $, string memory s) internal {\n        LibBytes.set(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to the empty string.\n    function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty string \"\".\n    function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }\n\n    /// @dev Helper to cast `$` to a `BytesStorage`.\n    function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2 + 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is not prefixed with \"0x\" and is encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Encodes `s` so that it can be safely used in a URI,\n    /// just like `encodeURIComponent` in JavaScript.\n    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    /// See: https://datatracker.ietf.org/doc/html/rfc2396\n    /// See: https://datatracker.ietf.org/doc/html/rfc3986\n    function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(string memory a, string memory b) internal pure returns (int256) {\n        return LibBytes.cmp(bytes(a), bytes(b));\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n"},"lib/solady/src/utils/MetadataReaderLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for reading contract metadata robustly.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MetadataReaderLib.sol)\nlibrary MetadataReaderLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Default gas stipend for contract reads. High enough for most practical use cases\n    /// (able to SLOAD about 1000 bytes of data), but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev Default string byte length limit.\n    uint256 internal constant STRING_LIMIT_DEFAULT = 1000;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                METADATA READING OPERATIONS                 */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Best-effort string reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Returns the empty string for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns empty string.\n    // 2. Attempts to `abi.decode` the returndata into a string.\n    // 3. With any remaining gas, scans the returndata from start to end for the\n    //    null byte '\\0', to interpret the returndata as a null-terminated string.\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"))`.\n    function readName(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit)`.\n    function readName(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"name()\"), limit, gasStipend)`.\n    function readName(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"))`.\n    function readSymbol(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit)`.\n    function readSymbol(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Equivalent to `readString(abi.encodeWithSignature(\"symbol()\"), limit, gasStipend)`.\n    function readSymbol(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `STRING_LIMIT_DEFAULT` (1000) bytes.\n    function readString(address target, bytes memory data) internal view returns (string memory) {\n        return _string(target, _ptr(data), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort string query on `target` with `data` as the calldata.\n    /// The string will be truncated to `limit` bytes.\n    function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, gasStipend);\n    }\n\n    // Best-effort unsigned integer reading operations.\n    // Should NOT revert as long as sufficient gas is provided.\n    //\n    // Performs the following in order:\n    // 1. Attempts to `abi.decode` the result into a uint256\n    //    (equivalent across all Solidity uint types, downcast as needed).\n    // 2. Returns zero for the following cases:\n    //     - Reverts.\n    //     - No returndata (e.g. function returns nothing, EOA).\n    //     - Returns zero.\n    //     - `abi.decode` failure.\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimals()\")))`.\n    function readDecimals(address target) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), GAS_STIPEND_NO_GRIEF));\n    }\n\n    /// @dev Equivalent to `uint8(readUint(abi.encodeWithSignature(\"decimals()\"), gasStipend))`.\n    function readDecimals(address target, uint256 gasStipend) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), gasStipend));\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data) internal view returns (uint256) {\n        return _uint(target, _ptr(data), GAS_STIPEND_NO_GRIEF);\n    }\n\n    /// @dev Performs a best-effort uint query on `target` with `data` as the calldata.\n    function readUint(address target, bytes memory data, uint256 gasStipend)\n        internal\n        view\n        returns (uint256)\n    {\n        return _uint(target, _ptr(data), gasStipend);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Attempts to read and return a string at `target`.\n    function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\n        private\n        view\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\n                let m := mload(0x40) // Grab the free memory pointer.\n                let s := add(0x20, m) // Start of the string's bytes in memory.\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\n                if iszero(lt(returndatasize(), 0x40)) {\n                    let o := mload(0x00) // Load the string's offset in the returndata.\n                    // If the string's offset is within bounds.\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\n                        // If the full string's end is within bounds.\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\n                        // for compliance purposes, regardless if the truncated string can fit.\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\n                            let n := min(mload(m), limit) // Truncate if needed.\n                            mstore(m, n) // Overwrite the length.\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\n                            result := m\n                            break\n                        }\n                    }\n                }\n                // Try interpreting as a null-terminated string.\n                let n := min(returndatasize(), limit) // Truncate if needed.\n                returndatacopy(s, 0, n) // Copy the string's bytes.\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\n                let i := s // Pointer to the next byte to scan.\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\0'.\n                mstore(m, sub(i, s)) // Store the string's length.\n                mstore(i, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\n                result := m\n                break\n            }\n        }\n    }\n\n    /// @dev Attempts to read and return a uint at `target`.\n    function _uint(address target, bytes32 ptr, uint256 gasStipend)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Casts the function selector `s` into a pointer.\n    function _ptr(uint256 s) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Layout the calldata in the scratch space for temporary usage.\n            mstore(0x04, s) // Store the function selector.\n            mstore(result, 4) // Store the length.\n        }\n    }\n\n    /// @dev Casts the `data` into a pointer.\n    function _ptr(bytes memory data) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := data\n        }\n    }\n}\n"},"lib/solady/src/utils/Base64.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"},"lib/solady/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /// @dev The allowance of Permit2 is fixed at infinity.\n    error Permit2AllowanceIsFixedAtInfinity();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    /// If you need to use a different version, override `_versionHash`.\n    bytes32 private constant _DEFAULT_VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @dev The canonical Permit2 address.\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\n    /// To enable, override `_givePermit2InfiniteAllowance()`.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           ERC20                            */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return type(uint256).max;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        // Code duplication is for zero-cost abstraction if possible.\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                if iszero(eq(caller(), _PERMIT2)) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x20, caller())\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                    let allowanceSlot := keccak256(0x0c, 0x34)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if not(allowance_) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                // Compute the allowance slot and load its value.\n                mstore(0x20, caller())\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                let allowanceSlot := keccak256(0x0c, 0x34)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if not(allowance_) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          EIP-2612                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev If you need a different value, override this function.\n    function _versionHash() internal view virtual returns (bytes32 result) {\n        result = _DEFAULT_VERSION_HASH;\n    }\n\n    /// @dev For inheriting contracts to increment the nonce.\n    function _incrementNonce(address owner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\n        }\n    }\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if not(allowance_) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          PERMIT2                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\n    ///\n    /// This value should be kept constant after contract initialization,\n    /// or else the actual allowance values may not match with the {Approval} events.\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\n        return false;\n    }\n}\n"},"lib/solady/src/utils/LibBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STRUCTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so its mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }\n\n    /// @dev Reduces the size of `subject` to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }\n\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Directly returns `a` with minimal copying.\n    function directReturn(bytes[] memory a) internal pure {\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(load(a, offset)))`.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(loadCalldata(a, offset)))`.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\n    function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }\n}\n"}},"settings":{"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/","bitcoinprism-evm/=lib/bitcoinprism-evm/","the-compact/=lib/the-compact/","permit2/=lib/permit2/","solady/=lib/solady/src/","OIF/=lib/OIF/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/","soledge/=lib/the-compact/lib/soledge/src/","solmate/=lib/permit2/lib/solmate/"],"optimizer":{"enabled":true,"runs":4294967295},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
