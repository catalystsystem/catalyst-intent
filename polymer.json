{"language":"Solidity","sources":{"lib/OIF/src/oracles/polymer/PolymerOracleMapped.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { ChainMap } from \"../ChainMap.sol\";\nimport { PolymerOracle } from \"./PolymerOracle.sol\";\n\n/**\n * @notice Polymer Oracle with mapped chainIds\n */\ncontract PolymerOracleMapped is ChainMap, PolymerOracle {\n    constructor(address _owner, address crossL2Prover) ChainMap(_owner) PolymerOracle(crossL2Prover) { }\n\n    function _getChainId(\n        uint256 protocolId\n    ) internal view override returns (uint256 chainId) {\n        return _getMappedChainId(protocolId);\n    }\n}\n"},"lib/OIF/src/oracles/ChainMap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { Ownable } from \"solady/auth/Ownable.sol\";\n\n/**\n * @notice Add chainmapping functionality to an oracle.\n * @dev If this oracle extension is used, it is important that transparent maps are not used; If a chain does not have a\n * corresponding configured id, it cannot be returned as is. The owner can later change this mapping unexpectedly. This\n * is not true for configured mappings.\n */\nabstract contract ChainMap is Ownable {\n    error AlreadySet();\n    error ZeroValue();\n\n    event ChainMapConfigured(uint256 protocolChainIdentifier, uint256 chainId);\n\n    mapping(uint256 protocolChainidentifier => uint256 chainId) public chainIdMap;\n    mapping(uint256 chainId => uint256 protocolChainidentifier) public reverseChainIdMap;\n\n    constructor(\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n    }\n\n    // --- Chain ID Functions --- //\n\n    /**\n     * @dev Wrapper for translating chainIds. Intended to override the implementation of the oracle.\n     * @param protocolId ChainId of a message.\n     * @return chainId \"Canonical\" chain id.\n     */\n    function _getMappedChainId(\n        uint256 protocolId\n    ) internal view virtual returns (uint256 chainId) {\n        chainId = chainIdMap[protocolId];\n        if (chainId == 0) revert ZeroValue();\n    }\n\n    /**\n     * @notice Sets an immutable map between 2 chain identifiers.\n     * @dev Can only be called once for every chain.\n     * @param protocolChainIdentifier Messaging protocol's chain identifier.\n     * @param chainId \"Canonical\" chain id. For EVM, should be block.chainid.\n     */\n    function setChainMap(uint256 protocolChainIdentifier, uint256 chainId) external onlyOwner {\n        if (protocolChainIdentifier == 0) revert ZeroValue();\n        if (chainId == 0) revert ZeroValue();\n\n        if (chainIdMap[protocolChainIdentifier] != 0) revert AlreadySet();\n        if (reverseChainIdMap[chainId] != 0) revert AlreadySet();\n\n        chainIdMap[protocolChainIdentifier] = chainId;\n        reverseChainIdMap[chainId] = protocolChainIdentifier;\n\n        emit ChainMapConfigured(protocolChainIdentifier, chainId);\n    }\n}\n"},"lib/OIF/src/oracles/polymer/PolymerOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { LibBytes } from \"solady/utils/LibBytes.sol\";\n\nimport { MandateOutput, MandateOutputEncodingLib } from \"../../libs/MandateOutputEncodingLib.sol\";\n\nimport { BaseOracle } from \"../BaseOracle.sol\";\nimport { ICrossL2Prover } from \"./ICrossL2Prover.sol\";\n\n/**\n * @notice Polymer Oracle.\n * Polymer uses the fill event to reconstruct the payload for verification instead of sending messages cross-chain.\n */\ncontract PolymerOracle is BaseOracle {\n    ICrossL2Prover CROSS_L2_PROVER;\n\n    constructor(\n        address crossL2Prover\n    ) {\n        CROSS_L2_PROVER = ICrossL2Prover(crossL2Prover);\n    }\n\n    function _getChainId(\n        uint256 protocolId\n    ) internal view virtual returns (uint256 chainId) {\n        return protocolId;\n    }\n\n    function _proofPayloadHash(\n        bytes32 orderId,\n        bytes32 solver,\n        uint32 timestamp,\n        MandateOutput memory mandateOutput\n    ) internal pure returns (bytes32 outputHash) {\n        return outputHash =\n            keccak256(MandateOutputEncodingLib.encodeFillDescriptionM(solver, orderId, timestamp, mandateOutput));\n    }\n\n    function _processMessage(\n        bytes calldata proof\n    ) internal {\n        (uint32 chainId, address emittingContract, bytes memory topics, bytes memory unindexedData) =\n            CROSS_L2_PROVER.validateEvent(proof);\n\n        // OrderId is topic[1] which is 32 to 64 bytes.\n        bytes32 orderId = bytes32(LibBytes.slice(topics, 32, 64));\n\n        (bytes32 solver, uint32 timestamp, MandateOutput memory output) =\n            abi.decode(unindexedData, (bytes32, uint32, MandateOutput));\n\n        bytes32 payloadHash = _proofPayloadHash(orderId, solver, timestamp, output);\n\n        // Convert the Polymer ChainID into the canonical chainId.\n        uint256 remoteChainId = _getChainId(uint256(chainId));\n\n        bytes32 application = bytes32(uint256(uint160(emittingContract)));\n        _attestations[remoteChainId][bytes32(uint256(uint160(address(this))))][application][payloadHash] = true;\n\n        emit OutputProven(remoteChainId, bytes32(uint256(uint160(address(this)))), application, payloadHash);\n    }\n\n    function receiveMessage(\n        bytes calldata proof\n    ) external {\n        _processMessage(proof);\n    }\n\n    function receiveMessage(\n        bytes[] calldata proofs\n    ) external {\n        uint256 numProofs = proofs.length;\n        for (uint256 i; i < numProofs; ++i) {\n            _processMessage(proofs[i]);\n        }\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"lib/solady/src/utils/LibBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }\n\n    /// @dev Reduces the size of `subject` to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }\n\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Directly returns `a` with minimal copying.\n    function directReturn(bytes[] memory a) internal pure {\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(load(a, offset)))`.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(loadCalldata(a, offset)))`.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\n    function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }\n}\n"},"lib/OIF/src/libs/MandateOutputEncodingLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { MandateOutput } from \"../input/types/MandateOutputType.sol\";\n\n/**\n * @notice Converts MandateOutputs to and from byte payloads.\n * @dev This library defines 2 payload encodings, one for internal usage and one for cross-chain communication.\n * - MandateOutput serialisation of the exact output on a output chain (encodes the entirety MandateOutput struct). This\n * encoding may be used to obtain a collision free hash to uniquely identify a MandateOutput.\n * - FillDescription serialisation to describe describe what has been filled on a remote chain. Its purpose is to\n * provide a source of truth of a remote action.\n * The encoding scheme uses 2 bytes long length identifiers. As a result, neither call nor context exceed 65'535 bytes.\n *\n * Serialised MandateOutput\n *      REMOTE_ORACLE           0               (32 bytes)\n *      + REMOTE_FILLER         32              (32 bytes)\n *      + CHAIN_ID              64              (32 bytes)\n *      + COMMON_PAYLOAD        96\n *\n * Serialised FillDescription\n *      SOLVER                  0               (32 bytes)\n *      + ORDERID               32              (32 bytes)\n *      + TIMESTAMP             64              (4 bytes)\n *      + COMMON_PAYLOAD        68\n *\n * Common Payload. Is identical between both schemes\n *      + TOKEN                 Y               (32 bytes)\n *      + AMOUNT                Y+32            (32 bytes)\n *      + RECIPIENT             Y+64            (32 bytes)\n *      + CALL_LENGTH           Y+96            (2 bytes)\n *      + CALL                  Y+98            (LENGTH bytes)\n *      + CONTEXT_LENGTH        Y+98+RC_LENGTH  (2 bytes)\n *      + CONTEXT               Y+100+RC_LENGTH (LENGTH bytes)\n *\n * where Y is the offset from the specific encoding (either 68 or 96)\n */\nlibrary MandateOutputEncodingLib {\n    error ContextOutOfRange();\n    error CallOutOfRange();\n\n    // --- MandateOutput --- //\n\n    /**\n     * @notice Predictable encoding of MandateOutput that deliberately overlaps with the payload encoding.\n     * @dev The encoding scheme uses 2 bytes long length identifiers. As a result, neither call nor context exceed\n     * 65'535 bytes.\n     */\n    function encodeMandateOutput(\n        MandateOutput calldata mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        bytes calldata call = mandateOutput.call;\n        bytes calldata context = mandateOutput.context;\n        if (call.length > type(uint16).max) revert CallOutOfRange();\n        if (context.length > type(uint16).max) revert ContextOutOfRange();\n\n        return encodedOutput = abi.encodePacked(\n            mandateOutput.oracle,\n            mandateOutput.settler,\n            mandateOutput.chainId,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            uint16(call.length), // To protect against data collisions\n            call,\n            uint16(context.length), // To protect against data collisions\n            context\n        );\n    }\n\n    function encodeMandateOutputMemory(\n        MandateOutput memory mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        bytes memory call = mandateOutput.call;\n        bytes memory context = mandateOutput.context;\n        if (call.length > type(uint16).max) revert CallOutOfRange();\n        if (context.length > type(uint16).max) revert ContextOutOfRange();\n\n        return encodedOutput = abi.encodePacked(\n            mandateOutput.oracle,\n            mandateOutput.settler,\n            mandateOutput.chainId,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            uint16(call.length), // To protect against data collisions\n            call,\n            uint16(context.length), // To protect against data collisions\n            context\n        );\n    }\n\n    /**\n     * @notice Hash of an MandateOutput intended for output identification.\n     * @dev This identifier is purely intended for the remote chain. It should never be ferried cross-chain.\n     * Chains or VMs may hash data differently.\n     */\n    function getMandateOutputHash(\n        MandateOutput calldata output\n    ) internal pure returns (bytes32) {\n        return keccak256(encodeMandateOutput(output));\n    }\n\n    function getMandateOutputHashMemory(\n        MandateOutput memory output\n    ) internal pure returns (bytes32) {\n        return keccak256(encodeMandateOutputMemory(output));\n    }\n\n    // --- FillDescription Encoding --- //\n\n    /**\n     * @notice FillDescription encoding.\n     * @dev The encoding scheme uses 2 bytes long length identifiers. As a result, neither call nor context exceed\n     * 65'535 bytes.\n     */\n    function encodeFillDescription(\n        bytes32 solver,\n        bytes32 orderId,\n        uint32 timestamp,\n        bytes32 token,\n        uint256 amount,\n        bytes32 recipient,\n        bytes memory call,\n        bytes memory context\n    ) internal pure returns (bytes memory encodedOutput) {\n        if (call.length > type(uint16).max) revert CallOutOfRange();\n        if (context.length > type(uint16).max) revert ContextOutOfRange();\n\n        return encodedOutput = abi.encodePacked(\n            solver,\n            orderId,\n            timestamp,\n            token,\n            amount,\n            recipient,\n            uint16(call.length), // To protect against data collisions\n            call,\n            uint16(context.length), // To protect against data collisions\n            context\n        );\n    }\n\n    /**\n     * @notice Encodes an output description into a fill description.\n     */\n    function encodeFillDescription(\n        bytes32 solver,\n        bytes32 orderId,\n        uint32 timestamp,\n        MandateOutput calldata mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        return encodedOutput = encodeFillDescription(\n            solver,\n            orderId,\n            timestamp,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            mandateOutput.call,\n            mandateOutput.context\n        );\n    }\n\n    function encodeFillDescriptionM(\n        bytes32 solver,\n        bytes32 orderId,\n        uint32 timestamp,\n        MandateOutput memory mandateOutput\n    ) internal pure returns (bytes memory encodedOutput) {\n        return encodedOutput = encodeFillDescription(\n            solver,\n            orderId,\n            timestamp,\n            mandateOutput.token,\n            mandateOutput.amount,\n            mandateOutput.recipient,\n            mandateOutput.call,\n            mandateOutput.context\n        );\n    }\n}\n"},"lib/OIF/src/oracles/BaseOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\n/**\n * @notice Base implementation for storing and exposting attesations for consumers. Maintains a storage slot which is\n * exposed through 'xProven' interfaces.\n */\nabstract contract BaseOracle is IOracle {\n    error NotDivisible(uint256 value, uint256 divisor);\n    error NotProven();\n\n    event OutputProven(uint256 chainid, bytes32 remoteIdentifier, bytes32 application, bytes32 payloadHash);\n\n    /**\n     * @notice Stores payload attestations.\n     * @dev For gas efficiency, payloads are not stored but instead the hash of the payloads are.\n     * To recover a payload, provide the payload (or memory) in calldata then hash it and check.\n     */\n    mapping(\n        uint256 remoteChainId\n            => mapping(bytes32 senderIdentifier => mapping(bytes32 application => mapping(bytes32 dataHash => bool)))\n    ) internal _attestations;\n\n    //--- Data Attestation Validation ---//\n\n    /**\n     * @notice Check if some data has been attested to on some chain.\n     * @param remoteChainId ChainId of data origin.\n     * @param remoteOracle Attestor on the data origin chain.\n     * @param application Application that the data originated from.\n     * @param dataHash Hash of data.\n     * @return bool Whether the hashed data has been attested to.\n     */\n    function _isProven(\n        uint256 remoteChainId,\n        bytes32 remoteOracle,\n        bytes32 application,\n        bytes32 dataHash\n    ) internal view virtual returns (bool) {\n        return _attestations[remoteChainId][remoteOracle][application][dataHash];\n    }\n\n    /**\n     * @notice Check if some data has been attested to on some chain.\n     * @param remoteChainId ChainId of data origin.\n     * @param remoteOracle Attestor on the data origin chain.\n     * @param application Application that the data originated from.\n     * @param dataHash Hash of data.\n     * @return bool Whether the hashed data has been attested to.\n     */\n    function isProven(\n        uint256 remoteChainId,\n        bytes32 remoteOracle,\n        bytes32 application,\n        bytes32 dataHash\n    ) external view returns (bool) {\n        return _isProven(remoteChainId, remoteOracle, application, dataHash);\n    }\n\n    /**\n     * @notice Check if a series of data has been attested to.\n     * @dev More efficient implementation of isProven. Does not return a boolean, instead reverts if false.\n     * This function returns true if proofSeries is empty.\n     * @param proofSeries remoteChainId, remoteOracle, application, and dataHash encoded in chucks of 32*4=128 bytes.\n     */\n    function efficientRequireProven(\n        bytes calldata proofSeries\n    ) external view {\n        unchecked {\n            uint256 proofBytes = proofSeries.length;\n            uint256 series = proofBytes / (32 * 4);\n            if (series * (32 * 4) != proofBytes) revert NotDivisible(proofBytes, 32 * 4); // unchecked: trivial\n\n            uint256 offset;\n            uint256 end;\n            assembly (\"memory-safe\") {\n                offset := proofSeries.offset\n                // unchecked: proofSeries.offset + proofBytes indicates a point in calldata.\n                end := add(proofSeries.offset, proofBytes)\n            }\n            bool state = true;\n            for (; offset < end;) {\n                // Load the proof description.\n                uint256 remoteChainId;\n                bytes32 remoteOracle;\n                bytes32 application;\n                bytes32 dataHash;\n                assembly (\"memory-safe\") {\n                    remoteChainId := calldataload(offset)\n                    offset := add(offset, 0x20)\n                    remoteOracle := calldataload(offset)\n                    offset := add(offset, 0x20)\n                    application := calldataload(offset)\n                    offset := add(offset, 0x20)\n                    dataHash := calldataload(offset)\n                    offset := add(offset, 0x20)\n                }\n                state = state && _isProven(remoteChainId, remoteOracle, application, dataHash);\n            }\n            if (!state) revert NotProven();\n        }\n    }\n}\n"},"lib/OIF/src/oracles/polymer/ICrossL2Prover.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICrossL2Prover {\n    /**\n     * @return chainId Source chain identifier\n     * @return emittingContract Emitting contract address\n     * @return topics Concatenated Event topics\n     * @return unindexedData Non-indexed event parameters\n     */\n    function validateEvent(\n        bytes calldata proof\n    ) external returns (uint32 chainId, address emittingContract, bytes memory topics, bytes memory unindexedData);\n}\n"},"lib/OIF/src/input/types/MandateOutputType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nstruct MandateOutput {\n    /// @dev Oracle implementation responsible for collecting the proof from settler on output chain.\n    bytes32 oracle;\n    /// @dev Output Settler on the output chain responsible for settling the output payment.\n    bytes32 settler;\n    uint256 chainId;\n    bytes32 token;\n    uint256 amount;\n    bytes32 recipient;\n    /// @dev Data that will be delivered to recipient through the settlement callback on the output chain. Can be used\n    /// to schedule additional actions.\n    bytes call;\n    /// @dev Additional output context for the output settlement, encoding order types or other information.\n    bytes context;\n}\n\n/**\n * @notice Helper library for the Output description order type.\n * TYPE_PARTIAL: An incomplete type. Is missing a field.'\n * TYPE_STUB: Type has no subtypes.\n * TYPE: Is complete including sub-types.\n */\nlibrary MandateOutputType {\n    //--- Outputs Types ---//\n\n    bytes constant MANDATE_OUTPUT_TYPE_STUB = bytes(\n        \"MandateOutput(bytes32 oracle,bytes32 settler,uint256 chainId,bytes32 token,uint256 amount,bytes32 recipient,bytes call,bytes context)\"\n    );\n\n    bytes32 constant MANDATE_OUTPUT_TYPE_HASH = keccak256(MANDATE_OUTPUT_TYPE_STUB);\n\n    function hashOutput(\n        MandateOutput calldata output\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                MANDATE_OUTPUT_TYPE_HASH,\n                output.oracle,\n                output.settler,\n                output.chainId,\n                output.token,\n                output.amount,\n                output.recipient,\n                keccak256(output.call),\n                keccak256(output.context)\n            )\n        );\n    }\n\n    function hashOutputs(\n        MandateOutput[] calldata outputs\n    ) internal pure returns (bytes32) {\n        unchecked {\n            bytes memory currentHash = new bytes(32 * outputs.length);\n\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                bytes32 outputHash = hashOutput(outputs[i]);\n                assembly {\n                    mstore(add(add(currentHash, 0x20), mul(i, 0x20)), outputHash)\n                }\n            }\n            return keccak256(currentHash);\n        }\n    }\n\n    // Memory copy of the above:\n    function hashOutputM(\n        MandateOutput memory output\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                MANDATE_OUTPUT_TYPE_HASH,\n                output.oracle,\n                output.settler,\n                output.chainId,\n                output.token,\n                output.amount,\n                output.recipient,\n                keccak256(output.call),\n                keccak256(output.context)\n            )\n        );\n    }\n\n    function hashOutputsM(\n        MandateOutput[] memory outputs\n    ) internal pure returns (bytes32) {\n        unchecked {\n            bytes memory currentHash = new bytes(32 * outputs.length);\n\n            for (uint256 i = 0; i < outputs.length; ++i) {\n                bytes32 outputHash = hashOutputM(outputs[i]);\n                assembly {\n                    mstore(add(add(currentHash, 0x20), mul(i, 0x20)), outputHash)\n                }\n            }\n            return keccak256(currentHash);\n        }\n    }\n}\n"},"lib/OIF/src/interfaces/IOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IOracle {\n    /**\n     * @notice Check if some data has been attested to on the remote chain.\n     * @param remoteChainId ChainId of data origin.\n     * @param remoteOracle Attestor on the data origin chain.\n     * @param application Application that the data originated from.\n     * @param dataHash Hash of data.\n     */\n    function isProven(\n        uint256 remoteChainId,\n        bytes32 remoteOracle,\n        bytes32 application,\n        bytes32 dataHash\n    ) external view returns (bool);\n\n    /**\n     * @notice Check if a series of data has been attested to.\n     * @dev More efficient implementation of isProven. Does not return a boolean, instead reverts if false.\n     * This function returns true if proofSeries is empty.\n     * @param proofSeries remoteChainId, remoteOracle, application, and dataHash encoded in chucks of 32*4=128 bytes.\n     */\n    function efficientRequireProven(\n        bytes calldata proofSeries\n    ) external view;\n}\n"}},"settings":{"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/","bitcoinprism-evm/=lib/bitcoinprism-evm/","the-compact/=lib/the-compact/","permit2/=lib/permit2/","solady/=lib/solady/src/","OIF/=lib/OIF/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","openzeppelin-contracts/=lib/permit2/lib/openzeppelin-contracts/","soledge/=lib/the-compact/lib/soledge/src/","solmate/=lib/permit2/lib/solmate/"],"optimizer":{"enabled":true,"runs":4294967295},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
